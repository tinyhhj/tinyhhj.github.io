{"componentChunkName":"component---src-templates-blog-post-js","path":"/python-2/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"c3840603-c715-5f9c-976e-fe05634ebd26","excerpt":"patchmatch 위 논문을 대략적으로 훑어봤지만, 무슨 내용인지…","html":"<h2><a href=\"https://gfx.cs.princeton.edu/pubs/Barnes_2009_PAR/\">patchmatch</a></h2>\n<p>위 논문을 대략적으로 훑어봤지만, 무슨 내용인지 1도 이해가 안됐다. 아무래도 논문에 아직 익숙하지 않고, 영어 독해능력이 미숙하고, 이미지 처리 분야에 낯설기 때문이라 생각된다. 이 논문에서는 소스코드를 공개하였는데, 간단한 코어 함수의 소스코드를 보니까, 논문을 읽었을 때보다 훨씬 쉽게 이해가 됐다.<br>\n속도 향상을 위해서 랜덤적 요소를 도입한 부분도 인상적이었다. </p>\n<h3>흐름</h3>\n<ol>\n<li>각 소스 패치와 타겟 패치의 매핑을 랜덤으로 정한다.</li>\n<li>소스패치 주변을 탐색하면서 더 나은 타겟 매핑이 있다면 이동한다.</li>\n<li>지금까지 찾은 최선점에서 다시 한번 랜덤으로 해당 구역내에서 더 나은 매핑을 찾는다.</li>\n<li>2와3을 여러번 반복한다.</li>\n</ol>\n<h3>구현 문제점</h3>\n<ul>\n<li>깔끔하고 이해하기 쉬운 알고리즘임에도 불구하고, 구현 중 디버깅의 어려움.</li>\n<li>동작에 대한 확신이 없음(동작을 제대로 하는듯 싶으나 이게 맞는지 모름)</li>\n<li>속도가 너무 느림</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from PIL import Image\nimport random\nimport sys\n\nsize=7\niter=5\n\nclass Node:\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        self.dist = 0\n    def setDist(self,pos,dist):\n        self.x = pos[1]\n        self.y = pos[0]\n        self.dist = dist\n\ndef getL2Norm(p1,p2):\n    return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2\ndef dist(img1,img2,p1,p2,sat = sys.maxsize):\n    ans = 0\n    for i in range(size):\n        for j in range(size):\n            ans += getL2Norm(img1.getpixel((p1[1]+j,p1[0]+i)), img2.getpixel((p2[1]+j, p2[0]+i)))\n        if ans &gt;= sat:\n            return sat\n    return ans\n\ndef unsigned(i):\n    return i &amp; 0xffffffffffffffff\n\ndef patchmatch(img1,img2):\n    _width, _height = img1.size\n    __width, __height = img2.size\n    target = [[Node() for _ in range(_width)] for _ in range(_height)]\n    for i in range(_height-size+1):\n        for j in range(_width-size+1):\n            x = random.randrange(0,__width-size+1)\n            y = random.randrange(0,__height-size+1)\n            target[i][j].setDist((y,x), dist(img1,img2,(i,j),(y,x)))\n    print(&quot;random initialization finish&quot;)\n    # iter만큼 반복한다.\n    for it in range(iter):\n        # 방향을 왼&gt;오,위&gt;아래 or 반대\n        xst,xend,xd = 0,_width-size+1,1\n        yst,yend,yd = 0,_height-size+1,1\n        if it %2 == 1:\n            xst, xend,xd = _width-size, -1,-1\n            yst, yend,yd = _height-size,-1,-1\n        for i in range(yst,yend,yd):\n            for j in range(xst,xend,xd):\n                # 최선의 매핑지점 in img2\n                bestY = target[i][j].y\n                bestX = target[i][j].x\n                bestDist = target[i][j].dist\n\n                # x축 이전단계와 비교하여 더 비슷한 매핑을 따른다\n                # j-xd = j == 0 일때 -1이 되야함\n                # j == _width-size+1+x 이 -1 x = -_width+size-2\n                # j-xd = _width-size + 1 = -1\n                if  unsigned(j-xd) &lt; unsigned(_width-size+1):\n                    compareY = target[i][j-xd].y\n                    compareX = target[i][j - xd].x + xd\n                    if unsigned(compareX) &lt; unsigned(__width-size+1):\n                        compareDist = dist(img1, img2, (i, j), (compareY, compareX), bestDist)\n                        if bestDist &gt; compareDist:\n                            bestY = compareY\n                            bestX = compareX\n                            bestDist = compareDist\n\n                # y축 이전단계와 비교\n                if unsigned(i-yd) &lt; unsigned(_height-size+1):\n                    compareY = target[i-yd][j].y+yd\n                    compareX = target[i-yd][j].x\n                    if unsigned(compareY) &lt; unsigned(__height-size+1):\n                        compareDist = dist(img1,img2,(i,j),(compareY,compareX),bestDist)\n                        if bestDist &gt; compareDist:\n                            bestY = compareY\n                            bestX = compareX\n                            bestDist = compareDist\n\n                # best guess 주변에서 탐색\n                r = max(__width,__height)\n                while r &gt;= 1:\n                    #print(&quot;r is %d&quot;%r)\n                    xmin = max(0,bestX - r)\n                    xmax = min(bestX+r+1, __width-size+1)\n                    ymin = max(0, bestY - r)\n                    ymax = min(bestY+r+1, __height-size+1)\n                    xp = random.randrange(xmin,xmax)\n                    yp = random.randrange(ymin,ymax)\n                    compareDist = dist(img1,img2,(i,j),(yp,xp),bestDist)\n                    if bestDist &gt; compareDist:\n                        bestY = yp\n                        bestX = xp\n                        bestDist = compareDist\n                    r = r//2\n                target[i][j].setDist((bestY, bestX),bestDist)\n        #print(&quot;iter: %d&quot;%it)\n\n    return target;\nif __name__ == &#39;__main__&#39;:\n    img1 = Image.open(&#39;a.png&#39;)\n    img2 = Image.open(&#39;b.png&#39;)\n\n    # img1.show()\n    # img2.show()\n    img3 = patchmatch(img2,img1)\n    img4 = Image.new(&#39;RGB&#39;,img2.size)\n    # (200,0,380,200)\n    for i in range(img2.size[1]):\n        for j in range(img2.size[0]):\n            print(&quot;%d %d mapping %d %d&quot;%(i,j,img3[i][j].y,img3[i][j].x))\n            img4.putpixel((j,i),img1.getpixel((img3[i][j].x, img3[i][j].y)))\n    img4.save(&#39;c.png&#39;)</code></pre></div>","frontmatter":{"title":"[python]patchmatch","date":"January 19, 2020","description":"language"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/python-2/","previous":{"fields":{"slug":"/ml-imageprocessing1/"},"frontmatter":{"title":"[ml-imageprocessing]준비"}},"next":{"fields":{"slug":"/python-1/"},"frontmatter":{"title":"[python]연습"}}}}}