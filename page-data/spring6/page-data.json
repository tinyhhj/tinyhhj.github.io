{"componentChunkName":"component---src-templates-blog-post-js","path":"/spring6/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"2eebe322-1361-5f2a-b40d-8c4a31922e3e","excerpt":"AOP…","html":"<h1>AOP</h1>\n<h2>프록시</h2>\n<p>서비스 추상화를 통해서, 트랜잭션을 적용하는 내용을 데이터 액세스 기술에 관계없이 적용할 수 있게끔 <code class=\"language-text\">전략패턴</code>으로 분리 시켰지만,\n비지니스 로직자체에 트랜잭션을 적용시키는(부가기능) 코드는 그대로 남아있다. 트랜잭션을 적용시키는 부분까지도 비지니스 로직에서 제거하기 위해서\n인터페이스를 통해 구현부분을 분리시켜 <code class=\"language-text\">부기가능</code>이 <code class=\"language-text\">핵심기능</code>을 사용하도록 구조를 만든다.</p>\n<p>여기서 주의할 점은 클라이언트가 직접 <code class=\"language-text\">핵심기능</code>을 사용하지 못하도록 <code class=\"language-text\">부가기능</code>이 마치 <code class=\"language-text\">핵심기능</code>인것처럼 꾸며 클라이언트의 요청을 가로채야 한다는 사실이다. 여기서 <code class=\"language-text\">부가기능</code>은 프록시, <code class=\"language-text\">핵심기능</code>은 타겟이라고 부른다.</p>\n<p>프록시는 두가지로 구분할 수 있는데</p>\n<ol>\n<li>클라이언트가 타겟에 접근하는 방법을 제어하기 위해서</li>\n<li>타겟에 부가적은 기능을 부여해주기 위해서</li>\n</ol>\n<p>각각을 목적에 따라 디자인 패턴에서는 다른 패턴으로 구분한다.</p>\n<h2>데코레이터 패턴</h2>\n<p>부가기능을 부여하기 위해서 프록시를 사용하는 패턴이다. 프록시를 여러개를 사용해 각각 다른 부가기능을 타겟 기능에 부여할 수 있다. </p>\n<p>예) 선물포장하기</p>\n<p>선물포장요청-> 리본묶기 -> 포장지 감싸기 -> 선물</p>\n<h2>프록시 패턴</h2>\n<p>타겟에 접근하는 방법을 제어하기 위해서 사용하는 패턴이다. <strong>프록시 패턴의 프록시는 타겟의 기능을 확장하거나 추가하지 않는다.</strong></p>\n<p>예) lazy init</p>\n<ol>\n<li>타겟이 당장 쓰이지 않지만, 참조값이 필요할 때 프록시를 미리 생성해두고 클라이언트가 프록시를 통해 메소드를 호출할 때, 타겟을 생성해서 요청을 위임한다. 즉, 타겟을 직접 사용할 때까지 최대한 생성을 늦춘다. </li>\n<li>원격 오브젝트에 대한 접근방법을 제공해줄 때 사용할 수 있다. 원격 오브젝트에 대한 프록시를 만들어두고 클라이언트는 마치 로컬 오브젝트에게 요청하듯이 작업을 요청하고, 프록시는 내부에서 원격오브젝트를 실행하여 결과를 돌려주는 식이다.</li>\n<li>타겟에 대한 접근권한을 제어하기 위해서도 사용할 수 있다.</li>\n</ol>\n<p>예) Collections.unmodifiableCollection</p>\n<p>데코레이터와 프록시는 유사해보이지만, 생성을 지연하는 프록시의 경우 구체적인 생성 방법을 알아야하므로 타겟에 대한 구체적인 정보를 알고 있는 경우가 많다.</p>\n<h2>프록시 작성의 문제점</h2>\n<ol>\n<li>타겟의 인터페이스를 구현하는게 번거롭다. 단순 위임형식이어도 일일이 코드를 작성해야하고, 타겟의 메소드가 추가되거나 변경될 경우 함께 수정해야한다.</li>\n<li>부가기능 코드가 중복될 가능성이 많다. 각 메소드마다 부가기능이 들어간다면 부가기능은 각각 메소드마다 항상 중복되어 나타나게 된다.</li>\n</ol>\n<h2>다이나믹 프록시</h2>\n<p><code class=\"language-text\">프록시 팩토리</code>에 의해서 런타임 시 다이나믹하게 만들어지는 객체이다. 타겟의 메소드 수가 몇개이던 상관없이 타겟 인터페이스의 정보와 프록시 메소드 호출 시 실행되는 <code class=\"language-text\">InvocationHandler</code>만 구현하면 프록시 적용이 가능하다. 또한 타겟의 적용 대상이 제한되있지 않으므로 재사용성이 높다.</p>\n<p>예) 리턴 타입이 string인 것만 uppercase적용, 메소드 이름이 say로 시작하는 경우에만 uppercase 적용</p>\n<p><strong>주의</strong>\nInvocationHandler를 구현할 때, 타겟의 Exception은 InvocationTargetException으로 감싸져 던져지므로 InvocationTargetException으로 캐치를 한뒤 , getTargetException으로 해당 예외처리를 해야한다.</p>\n<h2>다이나믹 프록시 문제점</h2>\n<p>다이나믹 프록시와 InvocationHandler를 통해서 프록시를 적용할 수 있으므로, 프록시를 스프링 DI를 통해 주입시킬 수 있어야한다. 하지만 <strong>DI의 대상이 되는 다이나믹 프록시 객체는 클래스 명이 없으므로 일반적으로 DI될 수 있는 방법이 없다</strong></p>\n<blockquote>\n<p>스프링의 빈을 만드는 방법은 클래스의 디폴터 생성자를 이용하는 방법 이외에도 여러가지 방법을 제공하는데 그 중 하나가 <code class=\"language-text\">팩토리 빈</code>을 이용하는 방법이다.\n<code class=\"language-text\">팩토리 빈</code>을 만드는 방법에는 여러가지가 있는데 가장 간단한 방법은 FactoryBean 인터페이스를 구현하는것이다.</p>\n</blockquote>\n<h3>팩토리 빈</h3>\n<p>팩토리 빈의 등록방법은 여타 빈의 등록방법과 다르지 않다. 아래 예제에서 등록되는 aaa의 빈의 경우 FactoryBean의 객체가 등록되는것이 아닌\nFactoryBean의 getObject 메소드가 생성해주는 객체가 aaa빈으로 등록이되며, 타입은 팩토리 빈의 getObjectType이 리턴하는 타입으로 결정된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;bean id =&quot;aaa&quot; class=&quot;factoryBeanclass&quot;&gt; \n    &lt;property name=&quot;bbb&quot; value=&quot;testString&quot;&gt;\n&lt;/bean&gt;</code></pre></div>\n<ul>\n<li>팩토리 빈은 빈 이름앞에 <code class=\"language-text\">&amp;</code>를 붙여주면 얻을 수 있다.</li>\n<li>팩토리 빈은 빈을 생성할 때 필요한 정보들을 프로퍼티로 가지고 있다가, 빈을 생성할 때 해당 프로퍼티를 전달하면서 객체를 생성한다.</li>\n</ul>\n<p><strong>즉 프록시를 생성하는 팩토리 빈과 타겟을 빈으로 등록하여 프록시를 빈으로 등록하여 사용할 수 있다.</strong></p>\n<h2>팩토리 빈의 장점과 한계</h2>\n<h3>장점</h3>\n<p>프록시 팩토리 빈의 장점은 타겟에 제한없이 재사용이 가능하다는 점이다. 또한 다이나믹 프록시의 문제점 2가지 일일이 메소드를 구현해야한다는 점과,\n부가기능의 코드가 메소드마다 중복되어 나타나는 문제점을 <code class=\"language-text\">프록시 팩토리 빈</code>으로 해결할 수 있다.</p>\n<h3>한계</h3>\n<ol>\n<li>한번에 여러 클래스에 공통적인 부가기능을 제공하는 것은 불가능하다. (하나의 클래스는 가능, 즉 여러개의 팩토리 빈 설정이 중복) - 200개의 클래스에 여러 부가기능을 적용시키려면 200 * 부가기능갯수 만큼의 팩토리 빈 설정이 필요 </li>\n<li>InvocationHandler는 타겟 객체를 프로퍼티로 지니고 있으므로, 프록시 팩토리 빈 갯수만큼 만들어진다. </li>\n</ol>\n<h2>프록시 팩토리 빈</h2>\n<p>jdk에서는 다이나믹 프록시 외에도 프록시를 만들 수 있도록 다양한 기술을 지원한다. 따라서 스프링은 일관된 방법으로 프록시를 만들 수 있게끔 추상화 된 레이어를 제공한다.</p>\n<h3>MethodInterceptor vs InvocationHandler</h3>\n<p>invocationHandler.invoke는 타겟에 대한 정보를 제공하지 않기 때문에 직접 invocationHandler가 타겟을 알고 있어야 하지만, MethodInterceptor의 invoke는 proxyFactoryBean으로부터 타겟 정보도 제공받으므로, MethodInterceptor의 경우 타겟과 독립적으로 만들어지고,사용될 수 있다.</p>","frontmatter":{"title":"Spring Chap. 6","date":"January 04, 2020","description":"Toby Spring"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/spring6/","previous":{"fields":{"slug":"/algospot-picnic/"},"frontmatter":{"title":"[algospot]picnic"}},"next":{"fields":{"slug":"/algospot-boardcover/"},"frontmatter":{"title":"[algospot]boardcover"}}}}}