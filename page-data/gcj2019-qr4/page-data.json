{"componentChunkName":"component---src-templates-blog-post-js","path":"/gcj2019-qr4/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"1f4b5272-0e8d-548b-931c-5c90b4cbe96f","excerpt":"Dat Bae 비트 연산자?? 입력: n개의 비트\n출력: 부서진 워커 id n개의 비트가 주어졌을 때, 부서진 워커를 제외하고 응답이 옴. 워커의 index가 곧 id…","html":"<h1><a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de\">Dat Bae</a></h1>\n<h2>비트 연산자??</h2>\n<p>입력: n개의 비트\n출력: 부서진 워커 id</p>\n<p>n개의 비트가 주어졌을 때, 부서진 워커를 제외하고 응답이 옴. 워커의 index가 곧 id이기때문에 몇번째 워커가 죽었는지 판단하면 됨.</p>\n<ol>\n<li>무식하게 풀 수 있을까?\n처음 문제를 보고 드는 생각은 재귀형식이었다. 비트가 n/2로 나눠도 크기가 작지만 같은 문제이기 때문에?\nn개의 비트중에 응답이 없는게 있으므로 순서 자체가 바뀌지 않았지만, 출력에 대응되는 index가 바뀌었다.\nn개를 입력으로 줬을경우에 n-b가 출력된다고 가정</li>\n</ol>\n<p>N = 5 and the 0th and 3rd workers are broken (so B = 2).\nTEST<em>STORE 01101 returns 111.\nTEST</em>STORE 00110 returns 010.\nTEST<em>STORE 01010 returns 100.\nTEST</em>STORE 11010 also returns 100.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1차 set에는 10번까지 query할 수 있고, 2차 set에서는 5번까지 query할 수 있지만, 기본적인 흐름도 구현을 못한채, 난 오로지 더 효율적인 알고리즘(방법)만을 생각했다.(주어진 기회를 모두 활용할 생각조차 애초에 안했다.) 문득 문제를 풀때마다, 자주 발견되는 실수인데 최대의 효율만을 목표로 삼아 정작 문제는 하나도 건들이지 못한 경우가 많다. 이 문제에서도 바로 그런 실수를 했던것 같다.</code></pre></div>\n<p>해결: 결국 혼자 너무 많은 시간을 낭비하기보다 주어진 답안을 어느정도 참고하는게 좋다고 생각이 들어서 1차 set의 솔루션을 참고했다.\n즉 10번의 query를 던질 수 있으며 최대 비트수는 1024이다. 즉 2^10은 1024이기때문에 어느정도 문제 출제자가 힌트를 준셈이나 마찬가지였다.\nn개의 비트를 10번 던져서 몇번 비트가 고장났는지 찾기 힘든이유는 0과 1만 사용할 수 있기 때문이다. 0과 1 밖에 없기때문에 01010이 나왔을 때, 순서를\n기억하지 못하기 때문이다. 즉 0-9까지 사용할 수 있다고 생각한다면 10자리 비트의 경우에 1번의 query로 몇번 비트가 고장났는지 알 수 있다.\n0123456789 -> 01234589 일경우 (67이 빠짐을 바로 알 수 있다.), 즉 각 비트마다 고유의 값으로 구분할 수 있다면 어느 비트가 고장났는지 알 수 있다. 따라서 query를 10번 던질수 있다는 말은 10번의 쿼리를 던져서 각 순서마다 고유한 값을 매핑시켜줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">n이 5라고 했을경우에 왼쪽 열부터 0 1 2 3 4를 매핑시켜줄 수 있다. 즉 10번의 query라는 말은 1024개의 각각 다른 값을 하나의 열에 매핑시킬 수 있다는 말이다.\n01010\n00110\n00001\n00000\n00000</code></pre></div>\n<p>위 해결방법을 이용하면 1set을 풀수 있고, 2번의 경우에는 query가 5번이므로 32개의 고유한값을 매핑시켜줄 수 있는 반면에 n은 최대가 1024이다.\n하지만 고장난 워커의 갯수는 최대가 15인데, 이 말인 즉, 고장난 워커들이 한곳에 다 뭉쳐있다고 하더라도 32개보다 작으므로 하나의 세트가 통째로 없어지는 일은 없다는 말이다. 즉 (1-32)(1-32)(1-32).. 32개의 고유한값을 반복적으로 이어나갈때 32 이후에 다시 1이 나타난다고 했을경우에 32과 1사이에 하나의 세트가(32개) 통째로 들어갈 수 없으므로 하나의 세트에서 다음 세트로 넘어갔을 경우에는 (N(i) > N(i+1)) 32를 앞의 세트갯수만큼 offset해주면 된다.</p>\n<p>느낀점: 처음으로 interactive한 문제를 풀어봤는데 문제를 위해 제공해준 interactive<em>runner 부터 testing</em>tool까지 정말 신세계였다. 너무 신기하고 좋은 경험이었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        String enc = new java.io.OutputStreamWriter(System.out).getEncoding();\n\n        System.err.println(&quot;default encoding = &quot; + enc);\n        System.err.flush();\n        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int tc = sc.nextInt();\n        System.err.println(&quot;tc &quot; + tc);\n//        System.err.flush();\n        for( int i = 0 ; i &lt; tc ; i++) {\n            int n = sc.nextInt(),\n                b = sc.nextInt(),\n                f = sc.nextInt();\n            System.err.println(&quot;nbf &quot; + n + b+f);\n//            System.err.flush();\n            sc.nextLine();\n            List&lt;String&gt; response = new ArrayList&lt;&gt;();\n\n            for( int j = 0 ; j &lt; f ; j++) {\n                query(n,b,f,response, sc);\n            }\n            System.err.println(&quot;finish query&quot;);\n            solve(n,b,f,response);\n\n            if( sc.nextInt() == -1) {\n                System.exit(1);\n            }\n        }\n\n    }\n\n    private static void solve(int n, int b, int f, List&lt;String&gt; response) {\n        List&lt;Integer&gt; workers = new ArrayList&lt;&gt;();\n        boolean[] workersOrig = new boolean[n];\n        for( int i = 0 ; i &lt; n-b ; i++) {\n            int res = 0;\n            for( int j = f-1 ; j &gt;= 0 ; j--) {\n                if(response.get(j).toCharArray()[i] -&#39;0&#39; == 1)\n                    res++;\n                res = res &lt;&lt; 1;\n            }\n            workers.add(res &gt;&gt; 1);\n        }\n\n//        System.err.println(&quot;expected workers: &quot; + workers);\n        workersOrig[workers.get(0)] = true;\n        int up = 0;\n        for( int i = 1 ; i &lt; workers.size() ; i++) {\n            int id = workers.get(i);\n            if( workers.get(i-1) &gt; id) {\n                up++;\n            }\n            id += (up * 32) ;\n//            System.err.println(&quot;id: &quot; + id);\n            workersOrig[id] = true;\n        }\n        String anwser = &quot;&quot;;\n        for( int i = 0 ; i &lt; n ; i++) {\n            if( !workersOrig[i]) anwser += i + &quot; &quot;;\n        }\n//        System.err.println(&quot;expected solve: &quot; + anwser.substring(0, anwser.length()-1));\n        System.out.println(anwser.substring(0, anwser.length()-1));\n        System.out.flush();\n\n\n    }\n\n    private static void query(int n, int b, int f, List&lt;String&gt; response,Scanner sc) {\n        String res = &quot;&quot;;\n        for( int i = 0 ; i &lt; n ; i++) {\n            res += (((i % 32) &gt;&gt; response.size()) &amp; 1) == 1 ? &quot;1&quot; : &quot;0&quot;;\n        }\n        System.err.println(&quot;query is &quot; + res);\n        System.out.println(res);\n        System.out.flush();\n\n        res = sc.nextLine();\n        System.err.println(&quot;res is &quot; + res);\n\n        if( res.equals(&quot;-1&quot;)) {\n            System.err.println(&quot;error res is &quot; + res);\n            System.err.flush();\n            System.exit(1);\n        }\n\n        response.add(res);\n    }\n\n}</code></pre></div>","frontmatter":{"title":"[gcj2019-qr4]Dat Bae","date":"January 14, 2020","description":"algorithm"}}},"pageContext":{"slug":"/gcj2019-qr4/","previous":{"fields":{"slug":"/gcj2019-qr3/"},"frontmatter":{"title":"[gcj2019-qr3]Cryptopangrams"}},"next":{"fields":{"slug":"/gcj2019-r1a1/"},"frontmatter":{"title":"[gcj2019-r1a1]Pylons"}}}}}