{"componentChunkName":"component---src-templates-blog-post-js","path":"/spring1/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"b4720dd2-22a9-5f56-9e90-663050c3da95","excerpt":"1장 관심사의 분리\n모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다\n문제는 변화에 따른 작업은 한곳에 집중되지 않다는 경우가 많다는 점이다. 예) db…","html":"<h1>1장</h1>\n<p>관심사의 분리\n모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다\n문제는 변화에 따른 작업은 한곳에 집중되지 않다는 경우가 많다는 점이다. 예) db 정보 변경\n즉, 변화가 한 번에 한가지 관심에 집중되서 발생하기 때문에, 관심이 한군데에 집중되게 하여 작업과 영향도를 최소화</p>\n<p>관심사 분리 방법 ( db접속정보에 대한 관심사 분리) </p>\n<ol>\n<li>중복 로직을 메소드로 추출</li>\n</ol>\n<p>-> 문제: 제 3자가 해당 클래스를 사용하려고 할 때, 자신들의 상황에 맞게 수정이 불가능</p>\n<ol start=\"2\">\n<li>\n<p>상속을 통한 확장\n확장 포인트를 protected로 제공하여 상속을 통한 확장이 가능하도록 제공</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">템플릿 메소드 패턴: 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 제공하는 패턴\n팩토리 메소드 패턴: 추상 메소드를 구현할 때, 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴</code></pre></div>\n</li>\n</ol>\n<p>-> 문제: 이미 상속중인 클래스는 해당 패턴 적용 불가능, 상속을 통한 클래스 관계 밀접하기 때문에\n슈퍼 클래스의 변화가 서브클래스의 변화에 영향을 주기 쉬움</p>\n<ol start=\"3\">\n<li>클래스 분리\ndb접속정보를 생성하는 새로운 클래스 생성 후 dao에서 참조</li>\n</ol>\n<p>-> 문제: 제 3자가 사용할 때, db접속정보를 자신에 맞게 변경하려면 dao를 수정해야 함.\ndao가 변경될 수 있는 정보를 담당하는 클래스에 대해 너무 많이 알고있기 때문에 종속적이 됨</p>\n<ol start=\"4\">\n<li>인터페이스 분리\ndao와 접속정보를 생성하는 인터페이스를 만들어 함께 제공</li>\n</ol>\n<p>-> 문제: 인터페이스의 어떤 구현체를 사용할지에 대한 관심사가 아직 생성자에 남아있어서 dao를 수정하기 전에는 자유롭지 못함.</p>\n<ol start=\"5\">\n<li>클라이언트 객체로 관심 분리\ndao에서 직접 구현체를 정하는 대신 클라이언트 객체에서 dao객체와 db접속정보를 생성하는 객체를 생성하여 객체간 관계를 설정해줌으로써\ndao는 데이터 액세스 로직에만 집중할 수 있게됨</li>\n<li>개방 폐쇄 원칙\n확장포인트는 인터페이스를 통해 개방하고, 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 하나의 관심사로 굳게 폐쇄되어 있다.</li>\n<li>높은 응집도 / 낮은 결합도\n하나의 변경 사항에 수정할 부분이 많다면 그만큼 버그의 위험성이 높아진다. 인터페이스를 이용해 기능을 독립적으로 분리 시킨경우에,\n해당 기능의 높은 응집력으로 변화에 대처하기 수월하다.(해당 인터페이스 구현체 교체)</li>\n</ol>\n<p>낮은 결합도는 인터페이스를 통해서 느슨한 연결을 의미한다. 느슨한 연결을 통해서 기능이 변경될 시 인터페이스 구현체를 교체함으로써,\n변화에 대응하기 쉽다.</p>\n<ol start=\"8\">\n<li>전략 패턴\n컨텍스트 - 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 부분을 인터페이스로 확장포인트를 만든다.\n보통 컨텍스트의 사용자(클라이언트)가 사용 전략을 컨텍스트에게 제공해주는 방식이 일반적이다.</li>\n<li>제어의 역전\n제어권 이전을 통한 제어의 역전, 라이브러리와 프레임워크의 차이점을 통해서 제어의 역전을 확인 가능,\n라이브러리를 사용하는 어플리케이션 코드는 흐름을 직접 제어하면서 필요한 기능이 있을 경우 라이브러리를 사용한다.\n반면, 프레임워크의 경우 어플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크에 클래스를 등록해두고,\n프레임워크가 흐름을 주도하는 중에 어플리케이션 코드를 사용하도록 만드는 방식</li>\n<li>\n<p>어플리케이션 컨텍스트 &#x26; 빈팩토리\n어플리케이션 컨텍스트는 앱 전반의 기능을 통틀어 지칭하는 경우가 많고, 빈팩토리는 빈의 생성,조회 등 관리하는 측면을 지칭할 때 쓰인다.\n오브젝트 팩토리를 사용하는 대신 스프링 컨테이너를 사용하면 좋은점은 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</li>\n<li>클라이언트가 구체적인 팩토리 클래스를 알 필요가 없고,</li>\n<li>\n<p>오브젝터 생성 및 관계설정 이외에 많은 부가기능이 있기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</li>\n<li>\n<p>싱글톤 레지스트리\n스프링 컨테이너는 기본적으로 컨테이너와 주기를 함께하는 싱글톤 스코프로 단 하나의 객체만이 생성된다.    </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">객체 비교 동일성, 동등성</code></pre></div>\n</li>\n<li>동일성 == 연산으로 동일한 객체인지 판단</li>\n<li>\n<p>동등성 equals 연산으로 동일한 정보를 담고있는지 판단</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</li>\n<li>\n<p>의존관계 주입(DI)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">의존\na가 b를 의존한다는 것은 b가 변경되었을 때, a도 영향을 받을 수 있지만 반대의 경우는 영향을 받지 않는다. 즉 의존에는 방향이 존재한다.</code></pre></div>\n</li>\n<li>클래스 모델이나 코드에는 런타임 시점의 관계가 드러나지 않아야 하며, 그러기 위해서는 인터페이스를 의존해야한다.</li>\n<li>런타임 시점의 관계는 컨테이너와 같은 제 3의 존재가 구성한다.</li>\n<li>의존관계는외부에서 제공해줌으로써 구성된다.</li>\n<li>의존관계 검색(DL)\n의존관계 주입과 반대로 클래스가 능동적으로 자신이 사용할 클래스를 검색한느 경우를 말한다. 예를 들어 application context의 getBean을 사용한 경우다.\n의존관계 검색은 컴포넌트가 컨네이터와 같은 성격이 다른 오브젝트에 의존성을 갖게되므로 바람직하지 않다.\n다만 main이나 서버환경에서 사용자의 요청을 받았을 경우에 적어도 한번은 의존관계 검색을 통해서 오브젝트를 가져와야 한다. 왜냐하면 DI를 이용해 주입받을 방법이 없기 때문이다.\n또한 의존관게 검색의 경우 클라이언트는 스프링 빈일 필요가 없으나 주입의 경우에는 클라이언트와 의존오브젝트 모두 스프링 빈이어야 한다.</li>\n</ol>","frontmatter":{"title":"Spring Chap. 1","date":"December 26, 2019","description":"Toby Spring"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/spring1/","previous":{"fields":{"slug":"/algo/"},"frontmatter":{"title":"Algo"}},"next":{"fields":{"slug":"/spring2/"},"frontmatter":{"title":"Spring Chap. 2"}}}}}