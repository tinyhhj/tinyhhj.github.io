{"componentChunkName":"component---src-templates-blog-post-js","path":"/boj-6603/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"d366df2b-0531-5f34-bd16-b7266bb36f28","excerpt":"로또 조합 생각보다 조합을 구현하는 법이 어렵다고 느꼈다. 순열의 경우에는 더 간단하게 구현이 되었던거 같은데 조합의 경우에는 \n집합의 전체갯수, 뽑는 갯수, 현재 index(집합을 모두 순회했는데 뽑아야하는 갯수가 남아있다면 조합의 경우가 없는 경우이다.)\nnCr = n-1Cr-…","html":"<h1><a href=\"https://www.acmicpc.net/problem/6603\">로또</a></h1>\n<h2>조합</h2>\n<blockquote>\n<p>생각보다 조합을 구현하는 법이 어렵다고 느꼈다. 순열의 경우에는 더 간단하게 구현이 되었던거 같은데 조합의 경우에는\n집합의 전체갯수, 뽑는 갯수, 현재 index(집합을 모두 순회했는데 뽑아야하는 갯수가 남아있다면 조합의 경우가 없는 경우이다.)\nnCr = n-1Cr-1 + n-1Cr 의 의미를 돌아보면 n번째 원소를 뽑는경우 나머지에서 r-1개의 원소를 뽑는 경우의수와 n을 뽑지 않아서 나머지에서 r개의 원소를 뽑는경우이다. 즉 재귀호출을 구현할 때에도 집합을 순회하면서 현재 위치를 index로 저장해두면서 현재 index의 원소를 뽑는경우와 안뽑는경우로 나누어 재귀호출을 한다.\n기저조건은 뽑아야하는 갯수를 다 뽑았을 경우이다.\n그 외 집합을 모두 순회한경우에도 뽑아야하는 갯수를 다 뽑지 못한경우는 조합을 조립하지 못하는 경우이므로 넘어간다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package boj;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Boj6603 {\n    public static void main(String[] args) throws FileNotFoundException {\n//        7 1 2 3 4 5 6 7\n//        8 1 2 3 5 8 13 21 34\n//        0\n//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(&quot;boj/6603.txt&quot;))));\n        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int n = sc.nextInt();\n        while(n != 0) {\n            int[] arr = new int[n];\n            for( int i =0 ; i &lt; n ; i++) {\n                arr[i]= sc.nextInt();\n            }\n            printLotto(IntStream.of(arr).boxed().collect(Collectors.toList()),6,0,new ArrayList&lt;&gt;());\n           n = sc.nextInt();\n           System.out.println(&quot;&quot;);\n        }\n    }\n\n    // 조합\n    // input: 집합, 뽑아야하는 조합개수, 지금까지 뽑은 숫자들\n    // output: void\n    // 어떻게 조합을 중복제거할 수 있을까\n    public static void printLotto(List&lt;Integer&gt; group, int k, int cur, List&lt;Integer&gt; arr) {\n        if( arr.size() == k) {\n            out(arr);\n        } else if( cur == group.size()) return;\n        else {\n\n            arr.add(group.get(cur));\n            printLotto(group, k, cur + 1, arr);\n            arr.remove(arr.size() - 1);\n            printLotto(group, k, cur + 1, arr);\n        }\n    }\n\n    public static void out(List&lt;Integer&gt; list) {\n        StringBuilder sb = new StringBuilder();\n        for(Integer i : list) {\n            sb.append(&quot; &quot; + i);\n        }\n        System.out.println(sb.substring(1));\n    }\n}</code></pre></div>","frontmatter":{"title":"[boj]6603","date":"January 11, 2020","description":"algorithm"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/boj-6603/","previous":{"fields":{"slug":"/gcj2019-qr1/"},"frontmatter":{"title":"[gcj2019-qr1]Foregone Solution"}},"next":{"fields":{"slug":"/gcj2019-qr2/"},"frontmatter":{"title":"[gcj2019-qr2]Foregone Solution"}}}}}