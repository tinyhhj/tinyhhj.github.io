{"componentChunkName":"component---src-templates-blog-post-js","path":"/deep-learning/blank-review/simple-ann/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"b8bb6ea0-cf83-54ed-9938-05761b59988a","excerpt":"Simple-ann 이 내용은 펭귄브로의 3분 딥러닝, 파이토치맛의 3장 내용을 복습한 예제입니다. 문제 정답이 0과 1인 데이터 구분하기","html":"<h2>Simple-ann</h2>\n<p>이 내용은 <a href=\"http://www.hanbit.co.kr/store/books/look.php?p_code=B7193109877\">펭귄브로의 3분 딥러닝, 파이토치맛</a>의 3장 내용을 복습한 예제입니다.</p>\n<h3>문제</h3>\n<ol>\n<li>정답이 0과 1인 데이터 구분하기</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import torch\nimport numpy as np\nfrom sklearn.datasets import make_blobs\nimport matplotlib.pyplot as plt\nimport torch.nn.functional as F\nimport os\n\n\n# label이 0,1로 된 데이터를 구분하는 ann\n# 1. 데이터 만들기\n# 2. 학습하기\n# 3. 가중치 업데이트\n\n\ndef make_datasets():\n    train_x, train_y = make_blobs(80,centers=[[1,1],[-1,-1],[1,-1],[-1,1]], cluster_std=0.3)\n    test_x , test_y = make_blobs(20, centers=[[1,1],[-1,-1],[1,-1],[-1,1]],cluster_std=0.3)\n    train_y = label_change(train_y, [0, 1], 0)\n    train_y = label_change(train_y, [2, 3], 1)\n    test_y = label_change(test_y, [0, 1], 0)\n    test_y = label_change(test_y, [2, 3], 1)\n    return torch.from_numpy(train_x).type(torch.float32), \\\n           torch.from_numpy(train_y).type(torch.float32),\\\n           torch.from_numpy(test_x).type(torch.float32),\\\n           torch.from_numpy(test_y).type(torch.float32)\n\ndef label_change(labels, f,t):\n    new_labels = labels.copy()\n    for x in f:\n        new_labels[labels == x] = t\n    return new_labels\n\ndef show(x,y):\n    plt.figure()\n    for (xx,yy),label in zip(x,y):\n        plt.plot(xx,yy,&#39;ro&#39; if label == 0 else &#39;r+&#39;)\n    plt.show()\niter = 2000\n\nclass ANN(torch.nn.Module):\n    def __init__(self, input_size, hidden_size):\n        super(ANN,self).__init__()\n        self.linear1 = torch.nn.Linear(input_size,hidden_size)\n        self.relu = torch.nn.ReLU()\n        self.linear2 = torch.nn.Linear(hidden_size,1)\n        self.sigmoid = torch.nn.Sigmoid()\n    def forward(self, x):\n        x = self.linear1(x)\n        x = self.relu(x)\n        x = self.linear2(x)\n        return self.sigmoid(x)\ntrain_x , train_y, test_x, test_y = make_datasets()\nann = ANN(2,5)\niter = 2000\ncriterion = torch.nn.BCELoss()\nlearnin_rate = 0.03\noptimizer = torch.optim.SGD(ann.parameters(), lr= learnin_rate)\n\nif os.path.exists(&#39;ann.pt&#39;):\n    ann.load_state_dict(torch.load(&#39;ann.pt&#39;))\n    ann.eval()\n    loss = criterion(ann(test_x).squeeze(), test_y)\n    print(loss.item())\n    exit()\n\nfor i in range(iter):\n    ann.train()\n    optimizer.zero_grad()\n    pred_y = ann(train_x)\n    loss = criterion(pred_y.squeeze(),train_y)\n    loss.backward()\n    optimizer.step()\n    if i % 100 == 0:\n        print(&#39;{}:{}&#39;.format(i,loss.item()))\n\nann.eval()\nloss = criterion(ann(test_x).squeeze(),test_y)\nprint(loss.item())\n\ntorch.save(ann.state_dict(), &#39;ann.pt&#39;)\nprint(ann.state_dict())</code></pre></div>","frontmatter":{"title":"[deeplearning]simple-ann","date":"February 18, 2020","description":"deep-learning"}}},"pageContext":{"slug":"/deep-learning/blank-review/simple-ann/","previous":{"fields":{"slug":"/deep-learning/blank-review/image-recovery/"},"frontmatter":{"title":"[deeplearning]image-recovery"}},"next":{"fields":{"slug":"/deep-learning/blank-review/simple-classifier/"},"frontmatter":{"title":"[deeplearning]simple-classifier"}}}}}