{"componentChunkName":"component---src-templates-blog-post-js","path":"/gcj2019-qr3/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"75743441-8d98-58f3-8454-a75104f3ba54","excerpt":"Cryptopangrams gcd(최대 공약수) 이 문제를 해결하는데 엄청나게 시간을 낭비했다. 풀이 1: 인접한 두 수의 최대 공약수 구하기(a * b = c, b * d = e 일때 c,e 의 최대 공약수는 b이다.) 접근 1으로 풀었을 때, 이 문제의 함정을 조심해야한다. 접근…","html":"<h1><a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/000000000008830b\">Cryptopangrams</a></h1>\n<h2>gcd(최대 공약수)</h2>\n<p>이 문제를 해결하는데 엄청나게 시간을 낭비했다.</p>\n<p>풀이 1: 인접한 두 수의 최대 공약수 구하기(a * b = c, b * d = e 일때 c,e 의 최대 공약수는 b이다.)</p>\n<p>접근 1으로 풀었을 때, 이 문제의 함정을 조심해야한다.</p>\n<p>접근 2: 풀이 1로만 접근했을 때에는 ABABABB 와 BABABAA 를 판별하지 못한다. 왜냐하면 AB와 BA의 최대 공약수는 자기자신 AB이기 때문이다.\n즉, 최대공약수를 통해서 소수를 유추해내려면 적어도 2쌍의 다른 소수의 곱이 필요하다 (예: AB BC => gcd = B로 유추가능, AB BA => gcd AB 유추 불가능)</p>\n<p>접근 3: 접근 2까지 했으나 visible set은 통과하나 hidden set은 통과를 못함. 결국 유투브에서 원인을 찾아낼 수 있었음\n소수의 크기가 10^100이기때문에 BigInteger를 사용해야만 했는데 시스템 입력에서 읽어올때 <strong>BigInteger.valueOf(sc.nextInt())</strong> 식으로 읽어오고 있던걸 <strong>sc.nextBigInteger()</strong>로 읽어오니까 통과함 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package codejam.qr2019.q3;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int tc = sc.nextInt();\n        sc.nextLine();\n        for( int i = 0 ; i &lt; tc ; i++ ) {\n            SortedSet&lt;BigInteger&gt; primes = new TreeSet&lt;&gt;();\n            BigInteger n = sc.nextBigInteger();\n            int l = sc.nextInt();\n            List&lt;BigInteger&gt; input = new ArrayList&lt;&gt;();\n            List&lt;BigInteger&gt; primesOrder = new ArrayList&lt;&gt;();\n            BigInteger prev = sc.nextBigInteger();\n            int idx = 0;\n            for( int j = 1 ; j &lt; l; j++) {\n                BigInteger number = sc.nextBigInteger();\n                BigInteger prevNumber =prev;\n                if( prevNumber.compareTo(number) != 0 ) {\n                    BigInteger prime = gcd(number, prevNumber);\n                    if( j % 2 != 0) {\n                        //BABAA ABABB\n                        //BAC\n                        // AAAAB\n                        BigInteger other = prevNumber.divide(prime);\n                        for( int k = 0 ; k &lt;= j ; k++) {\n                            primesOrder.add(k %2 == 0 ? other: prime);\n                        }\n                        primesOrder.add(number.divide(prime));\n                    } else {\n                        //ABABAA\n                        BigInteger other = prevNumber.divide(prime);\n                        for( int k = 0 ; k &lt;= j ; k++) {\n                            primesOrder.add(k %2 == 0 ? prime: other);\n                        }\n                        primesOrder.add(number.divide(prime));\n                    }\n                    idx = j;\n                    break;\n                }\n            }\n            for( int j = idx+1; j &lt; l ; j++) {\n                // 12 23 34 ..  end-1 end\n                BigInteger num = sc.nextBigInteger();\n                BigInteger prevNum = primesOrder.get(primesOrder.size()-1);\n                BigInteger number = num.divide(prevNum);\n                primesOrder.add(number);\n            }\n//            primesOrder.add(input.get(input.size()-1).divide(primesOrder.get(primesOrder.size()-1)));\n            primes.addAll(primesOrder);\n\n//            Assert.check(primes.size() == 26);\n//            Assert.check(primes.first().compareTo(primes.last()) &lt; 0);\n\n            Iterator&lt;BigInteger&gt; it = primes.iterator();\n            Map&lt;BigInteger, Integer&gt; mapping = new HashMap&lt;&gt;();\n            int cnt = 0 ;\n            while(it.hasNext()) {\n                mapping.put(it.next(), cnt++);\n            }\n            char[] alphabet = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();\n            System.out.print(String.format(&quot;Case #%d: &quot;,i+1));\n            for( BigInteger p : primesOrder) {\n                System.out.print(alphabet[mapping.get(p)]);\n            }\n            System.out.println(&quot;&quot;);\n\n        }\n\n\n    }\n\n    public static BigInteger gcd(BigInteger a , BigInteger b) {\n        if( a.compareTo(b) &lt; 0) {\n            BigInteger tmp = a;\n            a = b;\n            b = tmp;\n        }\n        while(b.compareTo(BigInteger.ZERO) != 0) {\n            BigInteger r = a.mod(b);\n            a = b;\n            b = r;\n        }\n        return a;\n    }\n}</code></pre></div>","frontmatter":{"title":"[gcj2019-qr3]Cryptopangrams","date":"January 13, 2020","description":"algorithm"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/gcj2019-qr3/","previous":{"fields":{"slug":"/spring7/"},"frontmatter":{"title":"Spring Chap. 7"}},"next":{"fields":{"slug":"/gcj2019-qr4/"},"frontmatter":{"title":"[gcj2019-qr4]Dat Bae"}}}}}