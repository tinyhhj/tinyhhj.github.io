{"componentChunkName":"component---src-templates-blog-post-js","path":"/algospot-clocksync/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"4e43db38-99e9-5df1-98c6-6249980dd7b4","excerpt":"CLOCKSYNC 생각 (알고리즘: 완전탐색) 완전 탐색이므로 한번씩 눌러보면서 12시로 맞는지 체크하자\n4번씩 누르면 초기화가 되기때문에 0번에서 3번까지 눌러보면서 \n모든 경우의 수를 체크한다. 주의할 점은…","html":"<h1><a href=\"https://algospot.com/judge/problem/read/CLOCKSYNC\">CLOCKSYNC</a></h1>\n<h2>생각 (알고리즘: 완전탐색)</h2>\n<blockquote>\n<p>완전 탐색이므로 한번씩 눌러보면서 12시로 맞는지 체크하자\n4번씩 누르면 초기화가 되기때문에 0번에서 3번까지 눌러보면서\n모든 경우의 수를 체크한다. 주의할 점은 3번까지 눌러놓고 상태를 초기화 해줘야한다. </p>\n</blockquote>\n<blockquote>\n<p>보통 인풋과 아웃풋을 정하는 부분이 힘든데\n아웃풋의 경우 알고리즘이 원하는 답안이 될 경우가 크다.\n문제가 원하는 답은 최소 클릭횟수 이기때문에, 재귀함수로 문제를 풀기위해서는 어느 시점의 최소 클릭횟수를 리턴해주면된다.\n인풋의 경우 상태값이 되는경우가 많다. (시계의 시침의 현재 상태), 또한 진행상황을 기록해야하므로 진행중인 순번도 함께 오는경우가 많다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package algospot.clocksync;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static int[][] switches = new int[10][];\n    static int[] clocks = new int[16];\n    public static void main(String[] args) throws FileNotFoundException {\n        switches[0] = new int[]{0,1,2};\n        switches[1] = new int[]{3, 7, 9, 11};\n        switches[2] = new int[]{4, 10, 14, 15};\n        switches[3] = new int[]{0, 4, 5, 6, 7};\n        switches[4] = new int[]{6, 7, 8, 10, 12};\n        switches[5] = new int[]{0, 2, 14, 15};\n        switches[6] = new int[]{3, 14, 15};\n        switches[7] = new int[]{4, 5, 7, 14, 15};\n        switches[8] = new int[]{1, 2, 3, 4, 5};\n        switches[9] = new int[]{3, 4, 5, 9, 13};\n\n//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        Scanner sc = new Scanner(new FileInputStream(&quot;algospot/clocksync/input.txt&quot;));\n\n\n        int tc = sc.nextInt();\n        for( int i =0; i &lt; tc ; i++) {\n            clocks = new int[16];\n            for(int j = 0 ; j &lt; 16; j++) {\n                clocks[j] = sc.nextInt();\n            }\n\n            //버튼을 한개씩 다 눌러본다\n            // 4번누르면 제자리 이므로 3번씩만 눌러본다\n\n            int res;\n            if( (res = click(clocks, 0)) &lt; Integer.MAX_VALUE )  {\n                System.out.println(res);\n            } else {\n                System.out.println(-1);\n            }\n        }\n    }\n\n    //재귀\n    //input: 시계들, 버튼, 누른버튼\n    //output: 현상황에서의 num번부터 누를때 최소횟수\n    static int click(int[] clocks,int num) {\n        if( checkTime(clocks)) {\n            return 0;\n        }\n        if( num == 10) {\n            return Integer.MAX_VALUE;\n        }\n\n        //4번씩 눌러본다. 안누른거 포함\n        int res = Integer.MAX_VALUE;\n        for(int i=0; i &lt; 4; i++) {\n            if( i&gt; 0) push(clocks,num);\n            int min = click(clocks,num+1);\n            if( min != Integer.MAX_VALUE) {\n                res = Math.min(res , min + i);\n            }\n        }\n        //3번까지 눌렀으므로 초기화해줌\n        push(clocks,num);\n        return res;\n    }\n    static void push(int[] clocks,int num) {\n        for (int m : switches[num]) {\n            clocks[m] = clocks[m] == 12 ? 3 : clocks[m]+3;\n        }\n    }\n    static boolean checkTime(int[] clocks) {\n        return Arrays.stream(clocks).allMatch(i-&gt;i==12);\n    }\n    static int total(int[] buttons) {\n        return Arrays.stream(buttons).sum();\n    }\n}</code></pre></div>","frontmatter":{"title":"[algospot]ClockSync","date":"January 09, 2020","description":"algorithm"}}},"pageContext":{"slug":"/algospot-clocksync/","previous":{"fields":{"slug":"/algospot-tsp1/"},"frontmatter":{"title":"[algospot]tsp1"}},"next":{"fields":{"slug":"/gcj2019-qr1/"},"frontmatter":{"title":"[gcj2019-qr1]Foregone Solution"}}}}}