{"componentChunkName":"component---src-templates-blog-post-js","path":"/gcj2019-qr2/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"b72d6595-215e-5749-9c13-5adc2d48067b","excerpt":"qr2019-2 backtracking","html":"<h1><a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da\">qr2019-2</a></h1>\n<h2>backtracking</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package codejam.qr2019.q2;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\n/**\n * https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da\n * 거꾸로 올라가는방식은?\n * 일단 첫번째와 끝은 이미 정해져있음\n * 만날때에는 서로 다른방향으로 가야하기 때문에 방향이 강제됨\n * n칸이라고할때 n을 두가지 방향으로 어떻게 배치할것인가 S n-1번 E n-1번 움직여야함\n * 상대가 s로 n-1번움직였다면 아래에있으면 안됨 즉 s를 다쓰면 안됨\n * 상대가 s를 n-1번쓸때까지 s를 남겨두려면 s를 쓸때 e를 쓰면됨?\n * 반대방향으로 갈경우 겹치지 않는 이유는 반대의 경우를 가정하고 생각한다.\n * (가정)반대방향으로만 갔을경우에 어느순간 상대방과 같은 방향으로 이동한다.\n * 어느지점에서 마주쳤다고 가정했을경우 상대방과 나는 (결과론적으로) 같은 수의 동쪽과 같은수의 남쪽을 사용했을 경우이다.\n * 그 경우에 다음 이동방향은 상대방과 무조건 반대이므로 겹치지 않게된다.\n */\npublic class Solution {\n    public static void main(String[] args) throws FileNotFoundException {\n//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(&quot;codejam/qr2019/q2/input.txt&quot;))));\n        int tc = sc.nextInt();\n        backtracking(sc, tc);\n    }\n\n    private static void inverseDirection(Scanner sc, int tc) {\n        for(int i =0 ; i &lt; tc ; i++) {\n            int n = sc.nextInt();\n            sc.nextLine();\n            String move = sc.nextLine();\n            char[] newMove = new char[move.length()];\n            int j = 0;\n            for( char a : move.toCharArray()) {\n                if( a == &#39;S&#39;) newMove[j++] = &#39;E&#39;;\n                else newMove[j++] = &#39;S&#39;;\n            }\n            System.out.println(String.format(&quot;Case #%d: %s&quot;,i+1, new String(newMove)));\n        }\n    }\n\n    private static void backtracking(Scanner sc, int tc) {\n        for( int i = 0 ; i &lt; tc; i++) {\n            int n = sc.nextInt();\n            sc.nextLine();\n            String move = sc.nextLine();\n            String path = backtrackingInternal(n,new int[]{0,0},new int[]{0,0},move,&quot;SE&quot;);\n            System.out.println(path);\n        }\n    }\n    private static boolean samePosition(int[] e, int[]m) {\n        return e[0] == m[0] &amp;&amp; e[1] == m[1];\n    }\n    private static boolean boundGrid(int y,int x, int n) {\n        return y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; n;\n    }\n    //input : 현재상태 상대방과 나의 위치와 상대방의 이동방향, 나의 가능한 이동방향\n    //output : 중복되지 않는 경로\n    private static String backtrackingInternal(int n, int[] e, int[] m, String ep, String mps) {\n        if( samePosition(e,m) &amp;&amp; ep.length() == 0 ) {\n            return &quot;&quot;;\n        }\n\n        // 이동가능 후보가 없거나 패스가 중복되거나\n        if( (samePosition(e,m) &amp;&amp; ep.substring(0,1).equals(mps))) {\n            return null;\n        } else if(mps.contains(ep.substring(0,1))){\n            mps = mps.replace(ep.substring(0,1),&quot;&quot;);\n        }\n\n\n        for( char d : mps.toCharArray()) {\n\n            if( d == &#39;E&#39; ) {\n                //이동\n                m[1]++;\n                if( ep.charAt(0) == &#39;E&#39;) {\n                    e[1]++;\n                } else {\n                    e[0]++;\n                }\n                //후보군설정\n                String candidates = boundGrid(m[0],m[1]+1,n) ? &quot;E&quot;: &quot;&quot;;\n                candidates += (boundGrid(m[0]+1,m[1],n)) ? &quot;S&quot; : &quot;&quot;;\n                String path = backtrackingInternal(n, e,m,ep.substring(1),candidates);\n                m[1]--;\n                if( ep.charAt(0) == &#39;E&#39;) {\n                    e[1]--;\n                } else {\n                    e[0]--;\n                }\n                if(  path != null) {\n                    return  &quot;E&quot; + path;\n                }\n\n\n            } else {\n                m[0]++;\n                if( ep.charAt(0) == &#39;E&#39;) {\n                    e[1]++;\n                } else {\n                    e[0]++;\n                }\n                String candidates = boundGrid(m[0],m[1]+1,n) ? &quot;E&quot;:&quot;&quot;;\n                candidates += (boundGrid(m[0]+1,m[1],n))?&quot;S&quot;:&quot;&quot;;\n                String path = backtrackingInternal(n,e,m,ep.substring(1),candidates);\n                m[0]--;\n                if( ep.charAt(0) == &#39;E&#39;) {\n                    e[1]--;\n                } else {\n                    e[0]--;\n                }\n                if( path != null) {\n                    return &quot;S&quot; + path;\n                }\n\n\n            }\n        }\n\n\n        return null;\n    }\n\n\n\n}</code></pre></div>","frontmatter":{"title":"[gcj2019-qr2]Foregone Solution","date":"January 12, 2020","description":"algorithm"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/gcj2019-qr2/","previous":{"fields":{"slug":"/boj-6603/"},"frontmatter":{"title":"[boj]6603"}},"next":{"fields":{"slug":"/boj-9663/"},"frontmatter":{"title":"[boj]9663"}}}}}