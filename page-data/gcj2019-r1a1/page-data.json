{"componentChunkName":"component---src-templates-blog-post-js","path":"/gcj2019-r1a1/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"4120b23c-2d9a-5765-b3f7-70805c66f339","excerpt":"Pylons brute force 고려해야할점: test1의 경우에는 dfs로 풀면 크기가 작아서 통과하는것 같으나 test…","html":"<h2><a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051635/0000000000104e03\">Pylons</a></h2>\n<h3>brute force</h3>\n<p>고려해야할점: test1의 경우에는 dfs로 풀면 크기가 작아서 통과하는것 같으나 test2셋의 경우에 너무 크기가 커져서 타임아웃 발생<br>\n계속 고민하다가 안나와서 결국 답안을 봤는데, 신세계였다. 간단하지만 절대 알고리즘을 풀면서 시도하지 못했던 방법을 제공했다.<br>\nbrute force이나 랜덤요소를 추가한 것이다. 워낙 사이즈가 크기 때문에 다양한 경로(정답)이 있을것이고, 문제에서 요구하는 것은 단 하나의 정답의 유무이기 때문에, 많은 경우의 수 중에 한번만 정답을 지나가면 풀 수 있다는 말이다.  </p>\n<p>여태 랜덤적인 요소를 알고리즘에서 절대 사용하면 안된다고 생각했었는데, 내 오산이었다.<br>\n여러모로 내 상식을 넓혀주는 문제였다. </p>\n<h4>java</h4>\n<p>1차만 통과</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package codejam.r1a.q1;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int tc = sc.nextInt();\n        for( int i = 0 ; i &lt; tc ; i++ ) {\n            int r = sc.nextInt(), c = sc.nextInt();\n            int[][] path = new int[r*c][];\n            boolean res = findRoute(path,new boolean[r][c], 0);\n            if(res) {\n                System.out.println(String.format(&quot;Case #%d: POSSIBLE&quot;,i+1));\n                for( int j = 0 ; j &lt; path.length; j++) {\n                    System.out.println(path[j][0]+1 + &quot; &quot; + (path[j][1]+1));\n                }\n            } else {\n                System.out.println(String.format(&quot;Case #%d: IMPOSSIBLE&quot;,i+1));\n            }\n\n        }\n    }\n\n    //backtracking\n    public static boolean findRoute(int[][] path, boolean[][] visited,int leng) {\n        // finish?\n        if( leng == path.length) {\n            return true;\n        }\n        // cant go anywhere\n        if( cantGoAnywhere(path,visited,leng)) {\n            return false;\n        }\n\n        // find other\n        // x 2 x 4 x\n        // x 2 x 9 1\n        for ( Integer[] i: next(path,visited,leng)) {\n            int rr = i[0];\n            int cc = i[1];\n\n            visited[rr][cc] = true;\n            path[leng] = new int[]{rr,cc};\n            if( findRoute(path,visited, leng+1)) {\n                return true;\n            }\n            visited[rr][cc] = false;\n        };\n        return false;\n    }\n\n    private static boolean cantGoAnywhere(int[][] path, boolean[][] visited,int leng) {\n        if (!next(path,visited,leng).isEmpty()) return false;\n        return true;\n    }\n\n    private static List&lt;Integer[]&gt; next(int[][] path, boolean[][] visited,int leng) {\n        List&lt;Integer[]&gt; res = new ArrayList&lt;&gt;();\n        for( int i = 0 ; i &lt; visited.length ; i++) {\n            for( int j = 0 ; j &lt; visited[i].length; j++) {\n                if( leng ==0 ){\n                    res.add(new Integer[]{i,j});\n                } else if( !visited[i][j] ) {\n                    int y = path[leng-1][0];\n                    int x = path[leng-1][1];\n                    if( y == i || x == j || i-j == y-x || i+j == y+x) continue;\n                    res.add(new Integer[]{i,j});\n                }\n            }\n        }\n        return res;\n    }\n}</code></pre></div>\n<h4>python</h4>\n<p>랜덤요소+ </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import queue\nimport random\n# bfs\nt = int(input())\n\ndef isInvalid(r,c,r1,c1):\n    return r == r1 or c == c1 or r+c == r1+c1 or r-c == r1-c1\n\ndef bfs(mat,path, visit):\n    q = queue.Queue()\n    q.put(path[0])\n    path.clear()\n\n    while not q.empty():\n        n = q.get()\n        r,c = n\n        path.append((r,c))\n        visit[r][c] = True\n        for i in mat[r][c]:\n            r1,c1 = i\n            if not visit[r1][c1]:\n                q.put((r1,c1))\n\n\n    return True\ndef dfs(mat, path,visit,r,c):\n    # visit\n    path.append((r, c))\n    visit[r][c] = True\n\n    if len(path) == len(visit)*len(visit[0]):\n        return True\n\n    for i in mat[r][c]:\n        if not visit[i[0]][i[1]]:\n            if dfs(mat,path,visit,i[0],i[1]):\n                return True\n\n    path.pop()\n    visit[r][c]= False\n\n\nfor __ in range(t):\n    a = input()\n    [r,c] = a.split(&#39; &#39;)\n    r= int(r)\n    c = int(c)\n\n    # 2 for loop\n    # r&lt;=20 , c &lt;=20 400 * 400 = 160000\n    Matrix = [[[] for x in range(c)] for y in range(r)]\n    for i in range(r):\n        for j in range(c):\n            for k in range(r):\n                for l in range(c):\n                    # valid point added\n                    if not isInvalid(i,j,k,l):\n                        Matrix[i][j].append((k,l))\n            random.shuffle(Matrix[i][j])\n\n\n\n    # memory for visit\n    # print(Matrix)\n    rr = [x for x in range(r)]\n    cc = [x for x in range(c)]\n    random.shuffle(rr)\n    random.shuffle(cc)\n    for i in rr:\n        for j in cc:\n            finish = False\n            visit = [[False for x in range(c)] for y in range(r)]\n            path = []\n            if dfs(Matrix,path,visit,i,j):\n                finish = True\n                break\n        if finish:\n            break\n    if finish:\n        print(&quot;Case #%d: %s&quot;%(__+1, &quot;POSSIBLE&quot;))\n        for i in path:\n            print(&quot;%d %d&quot;%(i[0]+1,i[1]+1))\n    else:\n        print(&quot;Case #%d: %s&quot;%(__+1,&quot;IMPOSSIBLE&quot;))</code></pre></div>","frontmatter":{"title":"[gcj2019-r1a1]Pylons","date":"January 17, 2020","description":"algorithm"}}},"pageContext":{"slug":"/gcj2019-r1a1/","previous":{"fields":{"slug":"/gcj2019-qr4/"},"frontmatter":{"title":"[gcj2019-qr4]Dat Bae"}},"next":{"fields":{"slug":"/ml-imageprocessing1/"},"frontmatter":{"title":"[ml-imageprocessing]준비"}}}}}