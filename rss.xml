<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsby-starter-blog-demo.netlify.com</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 18 Feb 2020 16:52:13 GMT</lastBuildDate><item><title><![CDATA[No title]]></title><link>https://gatsby-starter-blog-demo.netlify.com/deep-learning-from-scratch/index4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/deep-learning-from-scratch/index4/</guid><content:encoded></content:encoded></item><item><title><![CDATA[[deeplearning]simple-ann]]></title><description><![CDATA[Simple-ann 이 내용은 펭귄브로의 3분 딥러닝, 파이토치맛의 3장 내용을 복습한 예제입니다. 문제 정답이 0과 1인 데이터 구분하기]]></description><link>https://gatsby-starter-blog-demo.netlify.com/deep-learning/blank-review/simple-ann/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/deep-learning/blank-review/simple-ann/</guid><pubDate>Tue, 18 Feb 2020 16:49:26 GMT</pubDate><content:encoded>&lt;h2&gt;Simple-ann&lt;/h2&gt;
&lt;p&gt;이 내용은 &lt;a href=&quot;http://www.hanbit.co.kr/store/books/look.php?p_code=B7193109877&quot;&gt;펭귄브로의 3분 딥러닝, 파이토치맛&lt;/a&gt;의 3장 내용을 복습한 예제입니다.&lt;/p&gt;
&lt;h3&gt;문제&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;정답이 0과 1인 데이터 구분하기&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import torch
import numpy as np
from sklearn.datasets import make_blobs
import matplotlib.pyplot as plt
import torch.nn.functional as F
import os


# label이 0,1로 된 데이터를 구분하는 ann
# 1. 데이터 만들기
# 2. 학습하기
# 3. 가중치 업데이트


def make_datasets():
    train_x, train_y = make_blobs(80,centers=[[1,1],[-1,-1],[1,-1],[-1,1]], cluster_std=0.3)
    test_x , test_y = make_blobs(20, centers=[[1,1],[-1,-1],[1,-1],[-1,1]],cluster_std=0.3)
    train_y = label_change(train_y, [0, 1], 0)
    train_y = label_change(train_y, [2, 3], 1)
    test_y = label_change(test_y, [0, 1], 0)
    test_y = label_change(test_y, [2, 3], 1)
    return torch.from_numpy(train_x).type(torch.float32), \
           torch.from_numpy(train_y).type(torch.float32),\
           torch.from_numpy(test_x).type(torch.float32),\
           torch.from_numpy(test_y).type(torch.float32)

def label_change(labels, f,t):
    new_labels = labels.copy()
    for x in f:
        new_labels[labels == x] = t
    return new_labels

def show(x,y):
    plt.figure()
    for (xx,yy),label in zip(x,y):
        plt.plot(xx,yy,&amp;#39;ro&amp;#39; if label == 0 else &amp;#39;r+&amp;#39;)
    plt.show()
iter = 2000

class ANN(torch.nn.Module):
    def __init__(self, input_size, hidden_size):
        super(ANN,self).__init__()
        self.linear1 = torch.nn.Linear(input_size,hidden_size)
        self.relu = torch.nn.ReLU()
        self.linear2 = torch.nn.Linear(hidden_size,1)
        self.sigmoid = torch.nn.Sigmoid()
    def forward(self, x):
        x = self.linear1(x)
        x = self.relu(x)
        x = self.linear2(x)
        return self.sigmoid(x)
train_x , train_y, test_x, test_y = make_datasets()
ann = ANN(2,5)
iter = 2000
criterion = torch.nn.BCELoss()
learnin_rate = 0.03
optimizer = torch.optim.SGD(ann.parameters(), lr= learnin_rate)

if os.path.exists(&amp;#39;ann.pt&amp;#39;):
    ann.load_state_dict(torch.load(&amp;#39;ann.pt&amp;#39;))
    ann.eval()
    loss = criterion(ann(test_x).squeeze(), test_y)
    print(loss.item())
    exit()

for i in range(iter):
    ann.train()
    optimizer.zero_grad()
    pred_y = ann(train_x)
    loss = criterion(pred_y.squeeze(),train_y)
    loss.backward()
    optimizer.step()
    if i % 100 == 0:
        print(&amp;#39;{}:{}&amp;#39;.format(i,loss.item()))

ann.eval()
loss = criterion(ann(test_x).squeeze(),test_y)
print(loss.item())

torch.save(ann.state_dict(), &amp;#39;ann.pt&amp;#39;)
print(ann.state_dict())&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[deeplearning]image-recovery]]></title><description><![CDATA[Image-recovery 이 내용은 펭귄브로의 3분 딥러닝, 파이토치맛의 3장 내용을 복습한 예제입니다. 문제 weired_function을 통해 나온 손상된 이미지를 원래대로 복구할 수 있는 방법? 일반적 접근 weired_function…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/deep-learning/blank-review/image-recovery/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/deep-learning/blank-review/image-recovery/</guid><pubDate>Sun, 16 Feb 2020 15:29:48 GMT</pubDate><content:encoded>&lt;h2&gt;Image-recovery&lt;/h2&gt;
&lt;p&gt;이 내용은 &lt;a href=&quot;http://www.hanbit.co.kr/store/books/look.php?p_code=B7193109877&quot;&gt;펭귄브로의 3분 딥러닝, 파이토치맛&lt;/a&gt;의 3장 내용을 복습한 예제입니다.&lt;/p&gt;
&lt;h3&gt;문제&lt;/h3&gt;
&lt;p&gt;weired_function을 통해 나온 손상된 이미지를 원래대로 복구할 수 있는 방법?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;일반적 접근&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;weired_function 원리 이해&lt;/li&gt;
&lt;li&gt;weired_function를 복구할 수 있는 함수 작성&lt;/li&gt;
&lt;li&gt;이미지 복구&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;머신러닝 접근&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;손상된 이미지와 같은 사이즈의 랜덤 이미지를 weired_function에 입력&lt;/li&gt;
&lt;li&gt;1.의 출력된 결과와 손상된 이미지 차이 비교 &lt;/li&gt;
&lt;li&gt;손상된 이미지와 같게끔 랜덤 이미지 입력값 조정 &lt;/li&gt;
&lt;li&gt;최종적으로 손상된 이미지가 나온 랜덤 이미지를 찾았다면 이미지 복구&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import torch
import pickle
import matplotlib.pyplot as plt

def weird_function(x, n_iter=5):
    h = x
    filt = torch.tensor([-1./3, 1./3, -1./3])
    for ii in range(n_iter):
        zero_tensor = torch.tensor([1.0*0])
        h_l = torch.cat( (zero_tensor, h[:-1]), 0)
        h_r = torch.cat((h[1:], zero_tensor), 0 )
        h = filt[0] * h + filt[2] * h_l + filt[1] * h_r
        if ii % 2 == 0:
            h = torch.cat( (h[h.shape[0]//2:],h[:h.shape[0]//2]), 0  )
    return h

# image load
broken_image = torch.FloatTensor(pickle.load(open(&amp;#39;./broken_image_t.p&amp;#39;,&amp;#39;rb&amp;#39;),encoding=&amp;#39;latin1&amp;#39;))
# image show
plt.imshow(broken_image.view(100,-1))
plt.show()

random_image = torch.randn(10000,requires_grad=True)
learning_rate = 0.8
print(&amp;#39;learning rate: {}&amp;#39;.format(learning_rate))
for i in range(20000):
    # auto grad를 아직 잘 이해못한듯..

    random_image.requires_grad_(True)
    # process weired
    result_image = weird_function(random_image)
    # calc loss
    loss = torch.dist(result_image,broken_image,2)
    loss.backward()
    # rearrange random image
    with torch.no_grad():
        random_image = random_image - learning_rate * random_image.grad

    if(i % 1000 == 0):
        print(&amp;#39;loss: {}&amp;#39;.format(loss))
plt.imshow(random_image.view(100,-1))
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[python]star argument]]></title><description><![CDATA[star argument 간혹 함수 형식을 보면 덜렁 (*)만 있는 경우를 볼 수 있는데, 무슨 뜻인지 궁금해서 찾아보았습니다. keyword-only 변수를 편하게 사용하기 위해서 고안된 듯 싶습니다. 기존에도 **kwargs와 *args…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/python/star-args/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/python/star-args/</guid><pubDate>Sun, 16 Feb 2020 15:29:48 GMT</pubDate><content:encoded>&lt;h2&gt;star argument&lt;/h2&gt;
&lt;p&gt;간혹 함수 형식을 보면 덜렁 (*)만 있는 경우를 볼 수 있는데, 무슨 뜻인지 궁금해서 찾아보았습니다.&lt;br&gt;
keyword-only 변수를 편하게 사용하기 위해서 고안된 듯 싶습니다. 기존에도 **kwargs와 *args를 함께사용하여 가변변수와 키워드 변수를 함께 사용할 수 있었지만, 키워드 변수를 함수 내부에서 해체해야하는 번거로움이 존재했습니다.(&lt;code class=&quot;language-text&quot;&gt;이전에는 가변 변수 이후에 단독으로 키워드 변수가 존재할 수 없었다는 듯이 써있습니다.&lt;/code&gt;)  &lt;/p&gt;
&lt;h3&gt;변경&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;가변 변수 이후에 단독으로 키워드 변수가 존재할 수 있습니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반 변수와 키워드 변수를 구분하기 위해 경계선(*)를 사용할 수 있습니다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;def func(a,b,*,key=&amp;#39;key&amp;#39;):
pass
#ok
func(&amp;#39;aa&amp;#39;,&amp;#39;bb&amp;#39;)
#ok
func(&amp;#39;aa&amp;#39;,&amp;#39;aa&amp;#39;,key=&amp;#39;dd&amp;#39;)
#error positional argument only 2
func(&amp;#39;aa&amp;#39;,&amp;#39;bb&amp;#39;,&amp;#39;cc&amp;#39;,key=&amp;#39;ddd&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53797057/star-as-an-argument-in-python-function&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;PEP 3102&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[deeplearning]derivatives]]></title><description><![CDATA[미분 미분을 할때 어렵게 느껴지는 이유는 많은 것을, 한번에 해결하려고 하기 때문입니다. 또한 많은 실수를 야기합니다.
그래서 다차원 미분을 할때에, 단순한 수식부터 확장해 나가는것이 좋습니다. 벡터미분 $\overrightharpoon{y} = W…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/deep-learning/derivatives/derivatives/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/deep-learning/derivatives/derivatives/</guid><pubDate>Thu, 06 Feb 2020 14:49:11 GMT</pubDate><content:encoded>&lt;h2&gt;미분&lt;/h2&gt;
&lt;p&gt;미분을 할때 어렵게 느껴지는 이유는 많은 것을, 한번에 해결하려고 하기 때문입니다. 또한 많은 실수를 야기합니다.
그래서 다차원 미분을 할때에, 단순한 수식부터 확장해 나가는것이 좋습니다.&lt;/p&gt;
&lt;h3&gt;벡터미분&lt;/h3&gt;
&lt;p&gt;$\overrightharpoon{y} = W\overrightharpoon{x}$의 벡터 미분일고 각 벡터의 크기는 y(A,1),W(A,B),x(B,1) 일때,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;스칼라 결과값을 갖는 수식을 작성해봅니다.&lt;br&gt;
$\frac{\partial \overrightharpoon{y&lt;em&gt;3}}{\partial \overrightharpoon{x&lt;/em&gt;7}}$&lt;br&gt;
$\sum\limits&lt;em&gt;{j=1}^D W&lt;/em&gt;{\3&lt;em&gt;j}\overrightharpoon{x&lt;/em&gt;j}$&lt;br&gt;
벡터 수식에서 훨씬 단순한 스칼라 결과값을 갖는 수식으로 변경했습니다.&lt;/li&gt;
&lt;li&gt;요약 기호들을 삭제합니다.($\sum$, $\prod$)
미분을 할 때, 수식을 줄여주는 기호들로 인해 실수를 하는 경우가 많습니다. 만약 미분에 익숙하지 않은 경우에 수식을 풀어서 표시하는게 좋습니다.&lt;br&gt;
$\overrightharpoon{y} = {W&lt;em&gt;31}\overrightharpoon{x&lt;/em&gt;1} + {W&lt;em&gt;32}\overrightharpoon{x&lt;/em&gt;2} + … + {W&lt;em&gt;37}\overrightharpoon{x&lt;/em&gt;7} + … + {W&lt;em&gt;3D}\overrightharpoon{x&lt;/em&gt;D}$&lt;/li&gt;
&lt;li&gt;미분을 합니다.
위 수식을 $\overrightharpoon{x&lt;em&gt;7}$으로 미분할 경우, \frac{\partial \overrightharpoon{y&lt;/em&gt;3}}{\partial \overrightharpoon{x&lt;em&gt;7}} = ${W&lt;/em&gt;37}$&lt;/li&gt;
&lt;li&gt;즉 미분결과는 W가 됨을 알 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;벡터를 행렬로 미분&lt;/h3&gt;
&lt;p&gt;벡터의 각 차원을 행렬을 순회하면서 미분값을 구해야 하므로 3중 for문을 도는것과 같이 자연스럽게 결과는 3차원 벡터라고 생각할 수 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;스칼라 결과값을 갖는 수식을 작성합니다.
y3 = x&lt;em&gt;W78 = x1&lt;/em&gt;W13 + x2&lt;em&gt;W23 + … + xD&lt;/em&gt;WD3&lt;br&gt;
즉, W78은 y3에 관여를 안하므로 0이 됩니다. 행렬 곱셈을 생각해봤을 때, y의 index와 W의 열 index가 같을경우에만 미분값이 존재한다는 것을 알 수 있습니다.
그럼 y3을 Wi3으로 미분값을 구하면 y3 = x1&lt;em&gt;W13 + x2&lt;/em&gt;W23 + .. + xD*WD3이 되므로 xi가 됩니다.&lt;br&gt;
즉 Fijk = dyi/dWjk = dyi/dWji = xj가 됨을 확인 할 수 있습니다. 즉 y차원별 하나의 열벡터만이 미분 값을 가지므로, 2차원으로 압축해서
Gij = Fiji로 표현할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;행렬을 행렬로 미분&lt;/h3&gt;
&lt;p&gt;입력이 배치인경우에&lt;br&gt;
Y = X*W로 표현이 가능합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;스칼라 결과값을 갖는 수식을 작성합니다.
Y13에 영향을 줄 수 있는 입력값은 X1k*Wk3입니다.&lt;/li&gt;
&lt;li&gt;수식을 풀어서 적습니다.
Y13 = X1k&lt;em&gt;Wk3 = X11&lt;/em&gt;W13 + X12&lt;em&gt;W23 + .. X1M&lt;/em&gt;WM3&lt;/li&gt;
&lt;li&gt;Y의 row index는 X의 row index와 같고 column index는 W의 column index와 같으므로, dYij/dXik = Wkj 와 같습니다.&lt;/li&gt;
&lt;li&gt;3번 식을 general하게 풀어보면 Yi:를 i행이라고할 때, dYi:/dXi: = W라는 식을 얻을 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;합성함수의 미분&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;합성함수의 경우 각 연산의 미분의 곱과 같습니다.&lt;/li&gt;
&lt;li&gt;y = VWx라고 할 경우 VW = U를 이용하여 dy/dx = U를 쉽게 구할 수 있습니다.&lt;/li&gt;
&lt;li&gt;합성함수의 연쇄법칙으로 구해보면 Wx = m, y = Vm 처럼 중간 값 m을 이용하여 dy/dm * dm/dx로 dy/dx를 구할 수 있습니다.&lt;/li&gt;
&lt;li&gt;dy/dx를 스칼라값으로 수식을 단순하게 작성해보면 dyi/dm * dm/dxj = dyi/dxj, 여기서 dxj(어떤 j라도)가 변할경우 m벡터 전체에 영향을 전파합니다.&lt;br&gt;
mi = Wix1 + Wix2 + .. Wi+xn 이므로&lt;/li&gt;
&lt;li&gt;즉 모든 m의 차원에 대해서 미분 값을 더해야하기때문에 k=1~M dyi/dmk * dmk/dxj 를 구해야합니다.&lt;/li&gt;
&lt;li&gt;dyi/dmk = Vik이고 dmk/dxj = Wkj이기 때문에 k=1~M Vik * Wkj 즉 VW=U가 미분값이 됩니다. &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://cs231n.stanford.edu/vecDerivs.pdf&quot;&gt;Derivatives&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[[python]deep-learning-1]]></title><description><![CDATA[deep-learning-from-scratch chap 1]]></description><link>https://gatsby-starter-blog-demo.netlify.com/deep-learning-from-scratch/index1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/deep-learning-from-scratch/index1/</guid><pubDate>Tue, 28 Jan 2020 15:32:32 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;a href=&quot;https://github.com/WegraLee/deep-learning-from-scratch&quot;&gt;deep-learning-from-scratch&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;chap 1&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# numpy
import numpy as np

x = np.array([1,2,3,4])
y = np.array([1.,2.,3.,4.])

# element wise
print(x+y)
print(x-y)
print(x/y)
print(x*y)

# broadcast
print([1.0,2.0,3.0])
print(x / 2.0)

# 2d array
A = np.array([[1,2],[3,4]])
print(A)

print(A.shape)

print(A.dtype)

B = np.array([[1,2],[3,4]])
print(A+B)
print(A*B)
print(A-B)
print(A/B)

# broadcast
print(A*10)
print(A*np.array([10,20]))
print(A[0],A[0][0],A[0][1],A[1],A[1][0],A[1][1])

# flatten
A = np.array([[[1,2],[3,4]],[[1,2],[3,4]]])
Y = A.flatten()
print(Y)

# index array access
print(Y[np.array([0,2,4])])

# return bool array
print(type(A&amp;gt;2))
print(A &amp;gt; 2)

print(A[A&amp;gt;2])


# matplotlib

import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0,6,0.1)
y1 = np.sin(x)
y2 = np.cos(x)

plt.plot(x,y1,label=&amp;quot;sin&amp;quot;)
plt.plot(x,y2,linestyle=&amp;quot;--&amp;quot;, label=&amp;quot;cos&amp;quot;)
plt.xlabel(&amp;quot;x&amp;quot;)
plt.ylabel(&amp;#39;y&amp;#39;)
plt.title(&amp;quot;sin &amp;amp; cos&amp;quot;)
plt.legend()
plt.show()


# image
from matplotlib.image import imread

img = imread(&amp;#39;lena.jpeg&amp;#39;)

plt.imshow(img)
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[python]deep-learning-2]]></title><description><![CDATA[deep-learning-from-scratch chap 2]]></description><link>https://gatsby-starter-blog-demo.netlify.com/deep-learning-from-scratch/index2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/deep-learning-from-scratch/index2/</guid><pubDate>Tue, 28 Jan 2020 15:32:32 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;a href=&quot;https://github.com/WegraLee/deep-learning-from-scratch&quot;&gt;deep-learning-from-scratch&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;chap 2&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;&amp;#39;
# perceptron
# input : 여러 신호( 전류나 강물처럼 흐름이 있는..)
# output: 1 or 0 (1: 신호가 흐른다, 0 : 흐르지 않는다)
# 임계값(theta): 입력신호마다(x1,x2,..xn) 가중치(w1,w2,..wn)을 곱해 임계치를 넘을경우 출력신호(1)을 내보낸다.
# 가중치는 각 신호가 결과에 주는 영향력을 나타내는 요소( 즉 가중치가 클수록 중요한 신호임을 뜻합니다.)

x1*w1 + x2*w2 + .. xn*wn &amp;lt;= theta (return 0)
x1*w1 + x2*w2 + .. xn*wn &amp;gt; theta (return 1)


논리회로 and 게이트
x1 x2 y
0  0  0
0  1  0
1  0  0
1  1  1

퍼셉트론을 이용해 논리 and게이트를 만들 때 w1,w2(각 입력의 가중치)와 임계값(theta)를 정해야 합니다.
  w1  w2  theta
(0.5,0.5,0.7)
(0.5,0.5,0.8)
...
and 게이트의 조건을 만족하는 매개변수 조합은 무수히 많습니다.

nand 게이트
x1 x2 y
0  0  1
0  1  1
1  0  1
1  1  0
and 게이트 조건을 만족하는 매개변수들의 부호를 변경하면 모두 만족합니다.

위와 같은 문제일 경우 문제를 해결하는 방식을 생각해보면
and 게이트의 진리표라는 &amp;#39;학습데이터&amp;#39;를 보면서 알맞은 매개변수의 값을 찾습니다.
기계학습 문제는 이 매개변수의 값을 컴퓨터가 자동으로 찾도록 하는것을 말합니다.
학습이란 적절한 매개변수 값을 정하는 행위이며, 사람은 퍼셉트론의 구조(모델)을 고민하고
컴퓨터에 학습할 데이터를 주는 역할을 합니다.

and , nand ,or 게이트 모두 같은 구조의 퍼셉트론이 역할을 수행할 수 있고, 각 게이트마다 다른점은 매개변수(가중치와 임계값)일 뿐입니다.
즉 매개변수에 따라서 다양하게 역할을 수행하도록 퍼셉트론을 변경할 수 있습니다.
&amp;#39;&amp;#39;&amp;#39;

# and gate

def AND(x1,x2):
    w1,w2,theta = 0.5,0.5,0.7
    if x1*w1+x2*w2 &amp;lt;= theta:
        return 0
    else:
        return 1
print(AND(0,0))
print(AND(0,1))
print(AND(1,0))
print(AND(1,1))

&amp;#39;&amp;#39;&amp;#39;
theta = -b
b를 편향이라고 부르며
x1*w1 + x2*w2 + .. xn*wn &amp;lt;= -b (return 0)
x1*w1 + x2*w2 + .. xn*wn &amp;gt; -b (return 1)
위 수식을
b +  x1*w1 + x2*w2 + .. xn*wn &amp;lt;= 0 (return 0)
b +  x1*w1 + x2*w2 + .. xn*wn &amp;gt; 0 (return 1)
로 변경이 가능합니다.

편향과 가중치와 차이점에 주의합니다
가중치: 각 입력신호가 결과에 주는 영향력(중요도)를 조절하는 매개변수
편향: 뉴런이 얼마나 쉽게 활성화 하느냐 조절하는 매개변수
&amp;#39;&amp;#39;&amp;#39;
import numpy as np
x = np.array([0,1])
w = np.array([0.5,0.5])
b = -0.7

print(np.sum(w*x)+ b)

def And(x1,x2):
    w = np.array([0.5,0.5])
    b = -0.7
    x = np.array([x1,x2])
    tmp = np.sum(w*x)+b
    if tmp &amp;lt;= 0:
        return 0
    else:
        return 1

def Or(x1,x2):
    w = np.array([0.5,0.5])
    b = -0.1
    x = np.array([x1,x2])
    tmp = np.sum(w*x)+ b
    if tmp &amp;lt;= 0:
        return 0
    else:
        return 1
def Nand(x1,x2):
    if And(x1,x2) &amp;lt;= 0:
        return 1
    else:
        return 0



&amp;#39;&amp;#39;&amp;#39;
퍼셉트론의 한계 
직선으로만 출력이 표현가능하기 때문에 xor같은 비선형 데이터를 표현할 수 없습니다.
퍼셉트론을 여러 층으로 쌓으면 xor와 같은 비선형 데이터를 표현할 수 있습니다.

&amp;#39;&amp;#39;&amp;#39;
def Xor(x1,x2):
    s1 = Nand(x1,x2)
    s2 = Or(x1,x2)
    return And(s1,s2)

print(Xor(0,0))
print(Xor(0,1))
print(Xor(1,0))
print(Xor(1,1))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[python]deep-learning-3]]></title><description><![CDATA[deep-learning-from-scratch chap 3]]></description><link>https://gatsby-starter-blog-demo.netlify.com/deep-learning-from-scratch/index3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/deep-learning-from-scratch/index3/</guid><pubDate>Tue, 28 Jan 2020 15:32:32 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;a href=&quot;https://github.com/WegraLee/deep-learning-from-scratch&quot;&gt;deep-learning-from-scratch&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;chap 3&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;&amp;#39;
신경망
데이터로부터 가중치 매개변수의 적절한 값을 자동으로 학습하는 능력이 신경망의 중요한 성질입니다.
신경망의 구조
0.입력층
1.은닉층
2.출력층

퍼셉트론의 편향은 입력이 1이고 가중치가 b일 경우의 가중치로 변경이 가능합니다.
a = b(=w0)*x0 +w1*x1 + .. + wn*xn 으로 표현이 가능합니다.
y = h(a)
여기서 h(a)는 활성화 함수라고 하는데 입력의 총합(a)이 활성화(y)를 일으키는지 정하는 역할을 합니다.

퍼셉트론의 경우에 활성화 함수로 계단 함수를 사용하고 있으나 신경망으로 세계에서는 활성화 함수로 다른 함수를 사용하고 있습니다.

시그모이드 함수

&amp;#39;&amp;#39;&amp;#39;

# 계단 함수
import numpy as np
import matplotlib.pylab as plt

def step_func(x1):
    return np.array( x1 &amp;gt;0, dtype=np.int)

x = np.arange(-5., 5.,0.1)
y = step_func(x)
plt.plot(x,y)
plt.ylim(-0.1, 1.1) # 범위
plt.show()

# sigmoid

def sigmoid(x):
    # broadcast 이용
    # scalar 와 np.array 연산 시 해당 크기만큼 scalar값이 확장되어 연산을 수행합니다.
    return 1 / (1 + np.exp(-x))

xx = np.arange(-5.,5.,0.1)
yy = sigmoid(xx)

plt.plot(xx,yy)
plt.ylim(-0.1,1.1)
plt.show()

# ReLU(Rectified Linear Unit)

def relu(x):
    return np.maximum(0,x)

# 다차원 배열
A = np.array([[1,2],[3,4]])
print(A)
print(np.ndim(A)) # 차원
print(A.shape) # 차원의 크기

B = np.array([[4,5],[7,8]])
print(np.dot(A,B)) # 행렬의 곱 np.dot

C = np.array([[[1],[3]],[[1],[3]],[[1],[3]]])
print(C.shape)

# 신경망 행렬 곱
# x * w = y

X = [1,2]
W = [[1,2,3],[4,5,6]]
Y = np.dot(X,W)
print(Y)

# 핵심은 신경망에서의 계산을 행렬 계산으로 정리할 수 있다는 것입니다.
# 0층 입력층
# 1층 은닉층
# 2층 은닉층
# 3층 출력층
X = np.array([0.5,1])
W1 = np.array([[0.1,0.3,0.5],[0.2,0.4,0.6]])
B1 = np.array([0.1,0.2,0.3])
print(W1.shape)
print(X.shape)
print(B1.shape)

# 0-&amp;gt;1층
A1 = np.dot(X,W1)+B1
Z1 = sigmoid(A1)
print(A1)
print(Z1)

W2 = np.array([[0.1,0.4],[0.2,0.5],[0.3,0.6]])
B2 = np.array([0.1,0.2])

print(Z1.shape)
print(W2.shape)
print(B2.shape)

# 1-&amp;gt;2층
A2 = np.dot(Z1,W2) + B2
Z2 = sigmoid(A2)
print(A2)
print(Z2)

# 2-&amp;gt;3층
# 나머지 구현은 같으나, 활성화 함수만 다릅니다.
def identify_func(x):
    return x

W3 = np.array([[0.1,0.3],[0.2,0.4]])
B3 = np.array([0.1,0.2])
A3 = np.dot(Z2,W3)+B3
Z3 = identify_func(A3)
print(A3)
print(Z3)

# 중요: 출력층의 활성화 함수는 문제의 성질에 다르게 정합니다
# 회귀: 항등함수
# 분류: 시그모이드
# 다중분류: 소프트 맥스

# 소프트 맥스

a = np.array([0.3, 0.5, 0.7])
exp_a = np.exp(a)
sum_exp_a = np.sum(exp_a)
y = exp_a / sum_exp_a
print(y)

# softmax의 결과값의 경우 항상 출력 총합이 1 이므로 출력값을 &amp;#39;확률&amp;#39;로 해석할 수 있습니다.
def softmax(x):
    # exp는 오버플로우가 발생할 수 있으므로 max값을 빼줍니다.
    max = np.max(x)
    exp_x = np.exp(x-max)
    sum = np.sum(exp_x)
    # print(max, exp_x, sum)
    return exp_x / sum

# 기계학습을 학습과 추론 2단계로 나뉩니다
# 학습: 데이터를 사용해서 &amp;#39;가중치 매개변수&amp;#39;를 학습합니다.
# 추론: 앞에서 학습한 &amp;#39;가중치 매개변수&amp;#39;를 사용해서 입력데이터를 분류합니다.
import sys, os
sys.path.append(os.pardir)
from download_mnist import load_mnist

(x_train, t_train), (x_test,t_test) = load_mnist(flatten=True, normalize=True)

print(x_train.shape)
print(t_train.shape)
print(x_test.shape)
print(t_test.shape)

# 출력층 뉴런 10개 -&amp;gt; 다중 분류 0-9(10개
# 은닉 1층 50개 뉴런 / 2층 100 개 뉴런
# 50 과 100 은 임의의 값
import pickle

def get_data():
    (x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=True)
    return x_test,t_test

def init_network():
    with open(&amp;quot;sample_weight.pkl&amp;quot;,&amp;#39;rb&amp;#39;) as f:
        network = pickle.load(f)

    return network

def predict(network, x):
    W1,W2,W3 = network[&amp;#39;W1&amp;#39;], network[&amp;#39;W2&amp;#39;],network[&amp;#39;W3&amp;#39;]
    b1,b2,b3 = network[&amp;#39;b1&amp;#39;],network[&amp;#39;b2&amp;#39;],network[&amp;#39;b3&amp;#39;]

    a1 = np.dot(x,W1)+b1
    z1 = sigmoid(a1)
    a2 = np.dot(z1,W2)+b2
    z2 = sigmoid(a2)
    a3 = np.dot(z2,W3)+b3
    y = softmax(a3)

    print(&amp;#39;a1.shape&amp;#39;, a1.shape)
    print(&amp;#39;z1.shape&amp;#39;, z1.shape)
    print(&amp;#39;a2.shape&amp;#39;, a2.shape)
    print(&amp;#39;z2.shape&amp;#39;, z2.shape)
    print(&amp;#39;a3.shape&amp;#39;, a3.shape)
    print(&amp;#39;y.shape&amp;#39;, y.shape)
    return y

x, t = get_data()
network = init_network()

batch_size = 100
accuracy_cnt = 0
for i in range(0,len(x), batch_size):
    x_batch = x[i:i+batch_size]
    y_batch = predict(network, x_batch)
    #y = predict(network, x[i])
    p = np.argmax(y_batch, axis=1)
    accuracy_cnt+= np.sum(p == t[i:i+batch_size])

print(&amp;quot;Accuracy: &amp;quot; + str(float(accuracy_cnt) / len(x)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]quadtree]]></title><description><![CDATA[QUADTREE 분할정복 분할정복 문제이므로 분할정복 문제를 푸는 solution 함수 input / output 정의 input: 압축 string output: 거꾸로 압축된 string 분할정복을 푸는 solution…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-quadtree/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-quadtree/</guid><pubDate>Mon, 20 Jan 2020 12:31:33 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/QUADTREE&quot;&gt;QUADTREE&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;분할정복&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;분할정복 문제이므로 분할정복 문제를 푸는 solution 함수 input / output 정의&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;input: 압축 string&lt;/li&gt;
&lt;li&gt;output: 거꾸로 압축된 string&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분할정복을 푸는 solution 함수를 적용할 수 있게끔 문제를 분할한다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;크기가 작은 4개의 작은 문제로 쪼개기 가능 (분할)&lt;/li&gt;
&lt;li&gt;작은 문제가 모두 같은 색일경우 더 이상 쪼갤 수 없다. (기저조건)&lt;/li&gt;
&lt;li&gt;기존의 문제를 뒤집는 문제이기 때문에 3412순으로 다시 재배열한다. (병합)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;회고&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;작은 문제로 쪼갤 수 있다면 일단 문제 함수 정의를 잘 정한뒤, 분할 정복을 이용한다.&lt;/li&gt;
&lt;li&gt;분할, 병합, 기저조건을 잊지말자&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# solution
# input : 압축된 string
# output: 거꾸로 뒤집은 압축된 string

def solution(string):
    # 기저조건
    # 하나의 색인경우
    # w,b인경우
    if(string[0] != &amp;#39;x&amp;#39;):
        return string[0]

    # x로 시작하는 경우에는 어떻게 나눌것인가?
    first = solution(string[1:])
    second = solution(string[1+len(first):])
    third = solution(string[1+len(first)+ len(second):])
    fourth = solution(string[1+len(first)+len(second) + len(third):])
    return &amp;#39;x&amp;#39;+third + fourth + first + second


if __name__ == &amp;#39;__main__&amp;#39;:
    tc = input()
    for i in range(int(tc)):
        string = input()
        print(solution(string))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[python]patchmatch]]></title><description><![CDATA[patchmatch 위 논문을 대략적으로 훑어봤지만, 무슨 내용인지…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/python-2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/python-2/</guid><pubDate>Sun, 19 Jan 2020 16:21:36 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;a href=&quot;https://gfx.cs.princeton.edu/pubs/Barnes_2009_PAR/&quot;&gt;patchmatch&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;위 논문을 대략적으로 훑어봤지만, 무슨 내용인지 1도 이해가 안됐다. 아무래도 논문에 아직 익숙하지 않고, 영어 독해능력이 미숙하고, 이미지 처리 분야에 낯설기 때문이라 생각된다. 이 논문에서는 소스코드를 공개하였는데, 간단한 코어 함수의 소스코드를 보니까, 논문을 읽었을 때보다 훨씬 쉽게 이해가 됐다.&lt;br&gt;
속도 향상을 위해서 랜덤적 요소를 도입한 부분도 인상적이었다. &lt;/p&gt;
&lt;h3&gt;흐름&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;각 소스 패치와 타겟 패치의 매핑을 랜덤으로 정한다.&lt;/li&gt;
&lt;li&gt;소스패치 주변을 탐색하면서 더 나은 타겟 매핑이 있다면 이동한다.&lt;/li&gt;
&lt;li&gt;지금까지 찾은 최선점에서 다시 한번 랜덤으로 해당 구역내에서 더 나은 매핑을 찾는다.&lt;/li&gt;
&lt;li&gt;2와3을 여러번 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;구현 문제점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;깔끔하고 이해하기 쉬운 알고리즘임에도 불구하고, 구현 중 디버깅의 어려움.&lt;/li&gt;
&lt;li&gt;동작에 대한 확신이 없음(동작을 제대로 하는듯 싶으나 이게 맞는지 모름)&lt;/li&gt;
&lt;li&gt;속도가 너무 느림&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from PIL import Image
import random
import sys

size=7
iter=5

class Node:
    def __init__(self):
        self.x = 0
        self.y = 0
        self.dist = 0
    def setDist(self,pos,dist):
        self.x = pos[1]
        self.y = pos[0]
        self.dist = dist

def getL2Norm(p1,p2):
    return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2
def dist(img1,img2,p1,p2,sat = sys.maxsize):
    ans = 0
    for i in range(size):
        for j in range(size):
            ans += getL2Norm(img1.getpixel((p1[1]+j,p1[0]+i)), img2.getpixel((p2[1]+j, p2[0]+i)))
        if ans &amp;gt;= sat:
            return sat
    return ans

def unsigned(i):
    return i &amp;amp; 0xffffffffffffffff

def patchmatch(img1,img2):
    _width, _height = img1.size
    __width, __height = img2.size
    target = [[Node() for _ in range(_width)] for _ in range(_height)]
    for i in range(_height-size+1):
        for j in range(_width-size+1):
            x = random.randrange(0,__width-size+1)
            y = random.randrange(0,__height-size+1)
            target[i][j].setDist((y,x), dist(img1,img2,(i,j),(y,x)))
    print(&amp;quot;random initialization finish&amp;quot;)
    # iter만큼 반복한다.
    for it in range(iter):
        # 방향을 왼&amp;gt;오,위&amp;gt;아래 or 반대
        xst,xend,xd = 0,_width-size+1,1
        yst,yend,yd = 0,_height-size+1,1
        if it %2 == 1:
            xst, xend,xd = _width-size, -1,-1
            yst, yend,yd = _height-size,-1,-1
        for i in range(yst,yend,yd):
            for j in range(xst,xend,xd):
                # 최선의 매핑지점 in img2
                bestY = target[i][j].y
                bestX = target[i][j].x
                bestDist = target[i][j].dist

                # x축 이전단계와 비교하여 더 비슷한 매핑을 따른다
                # j-xd = j == 0 일때 -1이 되야함
                # j == _width-size+1+x 이 -1 x = -_width+size-2
                # j-xd = _width-size + 1 = -1
                if  unsigned(j-xd) &amp;lt; unsigned(_width-size+1):
                    compareY = target[i][j-xd].y
                    compareX = target[i][j - xd].x + xd
                    if unsigned(compareX) &amp;lt; unsigned(__width-size+1):
                        compareDist = dist(img1, img2, (i, j), (compareY, compareX), bestDist)
                        if bestDist &amp;gt; compareDist:
                            bestY = compareY
                            bestX = compareX
                            bestDist = compareDist

                # y축 이전단계와 비교
                if unsigned(i-yd) &amp;lt; unsigned(_height-size+1):
                    compareY = target[i-yd][j].y+yd
                    compareX = target[i-yd][j].x
                    if unsigned(compareY) &amp;lt; unsigned(__height-size+1):
                        compareDist = dist(img1,img2,(i,j),(compareY,compareX),bestDist)
                        if bestDist &amp;gt; compareDist:
                            bestY = compareY
                            bestX = compareX
                            bestDist = compareDist

                # best guess 주변에서 탐색
                r = max(__width,__height)
                while r &amp;gt;= 1:
                    #print(&amp;quot;r is %d&amp;quot;%r)
                    xmin = max(0,bestX - r)
                    xmax = min(bestX+r+1, __width-size+1)
                    ymin = max(0, bestY - r)
                    ymax = min(bestY+r+1, __height-size+1)
                    xp = random.randrange(xmin,xmax)
                    yp = random.randrange(ymin,ymax)
                    compareDist = dist(img1,img2,(i,j),(yp,xp),bestDist)
                    if bestDist &amp;gt; compareDist:
                        bestY = yp
                        bestX = xp
                        bestDist = compareDist
                    r = r//2
                target[i][j].setDist((bestY, bestX),bestDist)
        #print(&amp;quot;iter: %d&amp;quot;%it)

    return target;
if __name__ == &amp;#39;__main__&amp;#39;:
    img1 = Image.open(&amp;#39;a.png&amp;#39;)
    img2 = Image.open(&amp;#39;b.png&amp;#39;)

    # img1.show()
    # img2.show()
    img3 = patchmatch(img2,img1)
    img4 = Image.new(&amp;#39;RGB&amp;#39;,img2.size)
    # (200,0,380,200)
    for i in range(img2.size[1]):
        for j in range(img2.size[0]):
            print(&amp;quot;%d %d mapping %d %d&amp;quot;%(i,j,img3[i][j].y,img3[i][j].x))
            img4.putpixel((j,i),img1.getpixel((img3[i][j].x, img3[i][j].y)))
    img4.save(&amp;#39;c.png&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[python]연습]]></title><link>https://gatsby-starter-blog-demo.netlify.com/python-1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/python-1/</guid><pubDate>Sun, 19 Jan 2020 16:21:36 GMT</pubDate><content:encoded>&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# type&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# scalar type int, float , None , bool&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;showType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;t&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;t&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;t&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;123.123&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;str&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;str&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;str&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;str&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;k&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;v&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# input&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# all input is string&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
_ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# immutable&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# int , float, string, tuple&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a
b &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;123.123&lt;/span&gt;
b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a
b &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;321.321&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;str&apos;&lt;/span&gt;
b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a
b &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;str&apos;&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a
b &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# mutable&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# list, dict, set&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a
b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;append&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a
b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;setdefault&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a
b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;add&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# dict&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;123.123&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# set&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# list&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;append&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
showType&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[ml-imageprocessing]준비]]></title><description><![CDATA[시나리오 논문읽으면서 용어 찾기 (l1,l2 norm …) python 공부 numpy, pandas, opencv 등 lib 공부 구현 적용]]></description><link>https://gatsby-starter-blog-demo.netlify.com/ml-imageprocessing1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/ml-imageprocessing1/</guid><pubDate>Fri, 17 Jan 2020 11:50:12 GMT</pubDate><content:encoded>&lt;h2&gt;시나리오&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;논문읽으면서 용어 찾기 (l1,l2 norm …)&lt;/li&gt;
&lt;li&gt;python 공부&lt;/li&gt;
&lt;li&gt;numpy, pandas, opencv 등 lib 공부&lt;/li&gt;
&lt;li&gt;구현&lt;/li&gt;
&lt;li&gt;적용&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[[gcj2019-r1a1]Pylons]]></title><description><![CDATA[Pylons brute force 고려해야할점: test1의 경우에는 dfs로 풀면 크기가 작아서 통과하는것 같으나 test…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/gcj2019-r1a1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/gcj2019-r1a1/</guid><pubDate>Fri, 17 Jan 2020 11:50:12 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/codejam/round/0000000000051635/0000000000104e03&quot;&gt;Pylons&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;brute force&lt;/h3&gt;
&lt;p&gt;고려해야할점: test1의 경우에는 dfs로 풀면 크기가 작아서 통과하는것 같으나 test2셋의 경우에 너무 크기가 커져서 타임아웃 발생&lt;br&gt;
계속 고민하다가 안나와서 결국 답안을 봤는데, 신세계였다. 간단하지만 절대 알고리즘을 풀면서 시도하지 못했던 방법을 제공했다.&lt;br&gt;
brute force이나 랜덤요소를 추가한 것이다. 워낙 사이즈가 크기 때문에 다양한 경로(정답)이 있을것이고, 문제에서 요구하는 것은 단 하나의 정답의 유무이기 때문에, 많은 경우의 수 중에 한번만 정답을 지나가면 풀 수 있다는 말이다.  &lt;/p&gt;
&lt;p&gt;여태 랜덤적인 요소를 알고리즘에서 절대 사용하면 안된다고 생각했었는데, 내 오산이었다.&lt;br&gt;
여러모로 내 상식을 넓혀주는 문제였다. &lt;/p&gt;
&lt;h4&gt;java&lt;/h4&gt;
&lt;p&gt;1차만 통과&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package codejam.r1a.q1;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.stream.IntStream;

public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int tc = sc.nextInt();
        for( int i = 0 ; i &amp;lt; tc ; i++ ) {
            int r = sc.nextInt(), c = sc.nextInt();
            int[][] path = new int[r*c][];
            boolean res = findRoute(path,new boolean[r][c], 0);
            if(res) {
                System.out.println(String.format(&amp;quot;Case #%d: POSSIBLE&amp;quot;,i+1));
                for( int j = 0 ; j &amp;lt; path.length; j++) {
                    System.out.println(path[j][0]+1 + &amp;quot; &amp;quot; + (path[j][1]+1));
                }
            } else {
                System.out.println(String.format(&amp;quot;Case #%d: IMPOSSIBLE&amp;quot;,i+1));
            }

        }
    }

    //backtracking
    public static boolean findRoute(int[][] path, boolean[][] visited,int leng) {
        // finish?
        if( leng == path.length) {
            return true;
        }
        // cant go anywhere
        if( cantGoAnywhere(path,visited,leng)) {
            return false;
        }

        // find other
        // x 2 x 4 x
        // x 2 x 9 1
        for ( Integer[] i: next(path,visited,leng)) {
            int rr = i[0];
            int cc = i[1];

            visited[rr][cc] = true;
            path[leng] = new int[]{rr,cc};
            if( findRoute(path,visited, leng+1)) {
                return true;
            }
            visited[rr][cc] = false;
        };
        return false;
    }

    private static boolean cantGoAnywhere(int[][] path, boolean[][] visited,int leng) {
        if (!next(path,visited,leng).isEmpty()) return false;
        return true;
    }

    private static List&amp;lt;Integer[]&amp;gt; next(int[][] path, boolean[][] visited,int leng) {
        List&amp;lt;Integer[]&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for( int i = 0 ; i &amp;lt; visited.length ; i++) {
            for( int j = 0 ; j &amp;lt; visited[i].length; j++) {
                if( leng ==0 ){
                    res.add(new Integer[]{i,j});
                } else if( !visited[i][j] ) {
                    int y = path[leng-1][0];
                    int x = path[leng-1][1];
                    if( y == i || x == j || i-j == y-x || i+j == y+x) continue;
                    res.add(new Integer[]{i,j});
                }
            }
        }
        return res;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;python&lt;/h4&gt;
&lt;p&gt;랜덤요소+ &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import queue
import random
# bfs
t = int(input())

def isInvalid(r,c,r1,c1):
    return r == r1 or c == c1 or r+c == r1+c1 or r-c == r1-c1

def bfs(mat,path, visit):
    q = queue.Queue()
    q.put(path[0])
    path.clear()

    while not q.empty():
        n = q.get()
        r,c = n
        path.append((r,c))
        visit[r][c] = True
        for i in mat[r][c]:
            r1,c1 = i
            if not visit[r1][c1]:
                q.put((r1,c1))


    return True
def dfs(mat, path,visit,r,c):
    # visit
    path.append((r, c))
    visit[r][c] = True

    if len(path) == len(visit)*len(visit[0]):
        return True

    for i in mat[r][c]:
        if not visit[i[0]][i[1]]:
            if dfs(mat,path,visit,i[0],i[1]):
                return True

    path.pop()
    visit[r][c]= False


for __ in range(t):
    a = input()
    [r,c] = a.split(&amp;#39; &amp;#39;)
    r= int(r)
    c = int(c)

    # 2 for loop
    # r&amp;lt;=20 , c &amp;lt;=20 400 * 400 = 160000
    Matrix = [[[] for x in range(c)] for y in range(r)]
    for i in range(r):
        for j in range(c):
            for k in range(r):
                for l in range(c):
                    # valid point added
                    if not isInvalid(i,j,k,l):
                        Matrix[i][j].append((k,l))
            random.shuffle(Matrix[i][j])



    # memory for visit
    # print(Matrix)
    rr = [x for x in range(r)]
    cc = [x for x in range(c)]
    random.shuffle(rr)
    random.shuffle(cc)
    for i in rr:
        for j in cc:
            finish = False
            visit = [[False for x in range(c)] for y in range(r)]
            path = []
            if dfs(Matrix,path,visit,i,j):
                finish = True
                break
        if finish:
            break
    if finish:
        print(&amp;quot;Case #%d: %s&amp;quot;%(__+1, &amp;quot;POSSIBLE&amp;quot;))
        for i in path:
            print(&amp;quot;%d %d&amp;quot;%(i[0]+1,i[1]+1))
    else:
        print(&amp;quot;Case #%d: %s&amp;quot;%(__+1,&amp;quot;IMPOSSIBLE&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[gcj2019-qr4]Dat Bae]]></title><description><![CDATA[Dat Bae 비트 연산자?? 입력: n개의 비트
출력: 부서진 워커 id n개의 비트가 주어졌을 때, 부서진 워커를 제외하고 응답이 옴. 워커의 index가 곧 id…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr4/</guid><pubDate>Tue, 14 Jan 2020 11:02:43 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de&quot;&gt;Dat Bae&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;비트 연산자??&lt;/h2&gt;
&lt;p&gt;입력: n개의 비트
출력: 부서진 워커 id&lt;/p&gt;
&lt;p&gt;n개의 비트가 주어졌을 때, 부서진 워커를 제외하고 응답이 옴. 워커의 index가 곧 id이기때문에 몇번째 워커가 죽었는지 판단하면 됨.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;무식하게 풀 수 있을까?
처음 문제를 보고 드는 생각은 재귀형식이었다. 비트가 n/2로 나눠도 크기가 작지만 같은 문제이기 때문에?
n개의 비트중에 응답이 없는게 있으므로 순서 자체가 바뀌지 않았지만, 출력에 대응되는 index가 바뀌었다.
n개를 입력으로 줬을경우에 n-b가 출력된다고 가정&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;N = 5 and the 0th and 3rd workers are broken (so B = 2).
TEST&lt;em&gt;STORE 01101 returns 111.
TEST&lt;/em&gt;STORE 00110 returns 010.
TEST&lt;em&gt;STORE 01010 returns 100.
TEST&lt;/em&gt;STORE 11010 also returns 100.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;1차 set에는 10번까지 query할 수 있고, 2차 set에서는 5번까지 query할 수 있지만, 기본적인 흐름도 구현을 못한채, 난 오로지 더 효율적인 알고리즘(방법)만을 생각했다.(주어진 기회를 모두 활용할 생각조차 애초에 안했다.) 문득 문제를 풀때마다, 자주 발견되는 실수인데 최대의 효율만을 목표로 삼아 정작 문제는 하나도 건들이지 못한 경우가 많다. 이 문제에서도 바로 그런 실수를 했던것 같다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해결: 결국 혼자 너무 많은 시간을 낭비하기보다 주어진 답안을 어느정도 참고하는게 좋다고 생각이 들어서 1차 set의 솔루션을 참고했다.
즉 10번의 query를 던질 수 있으며 최대 비트수는 1024이다. 즉 2^10은 1024이기때문에 어느정도 문제 출제자가 힌트를 준셈이나 마찬가지였다.
n개의 비트를 10번 던져서 몇번 비트가 고장났는지 찾기 힘든이유는 0과 1만 사용할 수 있기 때문이다. 0과 1 밖에 없기때문에 01010이 나왔을 때, 순서를
기억하지 못하기 때문이다. 즉 0-9까지 사용할 수 있다고 생각한다면 10자리 비트의 경우에 1번의 query로 몇번 비트가 고장났는지 알 수 있다.
0123456789 -&gt; 01234589 일경우 (67이 빠짐을 바로 알 수 있다.), 즉 각 비트마다 고유의 값으로 구분할 수 있다면 어느 비트가 고장났는지 알 수 있다. 따라서 query를 10번 던질수 있다는 말은 10번의 쿼리를 던져서 각 순서마다 고유한 값을 매핑시켜줄 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;n이 5라고 했을경우에 왼쪽 열부터 0 1 2 3 4를 매핑시켜줄 수 있다. 즉 10번의 query라는 말은 1024개의 각각 다른 값을 하나의 열에 매핑시킬 수 있다는 말이다.
01010
00110
00001
00000
00000&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 해결방법을 이용하면 1set을 풀수 있고, 2번의 경우에는 query가 5번이므로 32개의 고유한값을 매핑시켜줄 수 있는 반면에 n은 최대가 1024이다.
하지만 고장난 워커의 갯수는 최대가 15인데, 이 말인 즉, 고장난 워커들이 한곳에 다 뭉쳐있다고 하더라도 32개보다 작으므로 하나의 세트가 통째로 없어지는 일은 없다는 말이다. 즉 (1-32)(1-32)(1-32).. 32개의 고유한값을 반복적으로 이어나갈때 32 이후에 다시 1이 나타난다고 했을경우에 32과 1사이에 하나의 세트가(32개) 통째로 들어갈 수 없으므로 하나의 세트에서 다음 세트로 넘어갔을 경우에는 (N(i) &gt; N(i+1)) 32를 앞의 세트갯수만큼 offset해주면 된다.&lt;/p&gt;
&lt;p&gt;느낀점: 처음으로 interactive한 문제를 풀어봤는데 문제를 위해 제공해준 interactive&lt;em&gt;runner 부터 testing&lt;/em&gt;tool까지 정말 신세계였다. 너무 신기하고 좋은 경험이었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        String enc = new java.io.OutputStreamWriter(System.out).getEncoding();

        System.err.println(&amp;quot;default encoding = &amp;quot; + enc);
        System.err.flush();
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int tc = sc.nextInt();
        System.err.println(&amp;quot;tc &amp;quot; + tc);
//        System.err.flush();
        for( int i = 0 ; i &amp;lt; tc ; i++) {
            int n = sc.nextInt(),
                b = sc.nextInt(),
                f = sc.nextInt();
            System.err.println(&amp;quot;nbf &amp;quot; + n + b+f);
//            System.err.flush();
            sc.nextLine();
            List&amp;lt;String&amp;gt; response = new ArrayList&amp;lt;&amp;gt;();

            for( int j = 0 ; j &amp;lt; f ; j++) {
                query(n,b,f,response, sc);
            }
            System.err.println(&amp;quot;finish query&amp;quot;);
            solve(n,b,f,response);

            if( sc.nextInt() == -1) {
                System.exit(1);
            }
        }

    }

    private static void solve(int n, int b, int f, List&amp;lt;String&amp;gt; response) {
        List&amp;lt;Integer&amp;gt; workers = new ArrayList&amp;lt;&amp;gt;();
        boolean[] workersOrig = new boolean[n];
        for( int i = 0 ; i &amp;lt; n-b ; i++) {
            int res = 0;
            for( int j = f-1 ; j &amp;gt;= 0 ; j--) {
                if(response.get(j).toCharArray()[i] -&amp;#39;0&amp;#39; == 1)
                    res++;
                res = res &amp;lt;&amp;lt; 1;
            }
            workers.add(res &amp;gt;&amp;gt; 1);
        }

//        System.err.println(&amp;quot;expected workers: &amp;quot; + workers);
        workersOrig[workers.get(0)] = true;
        int up = 0;
        for( int i = 1 ; i &amp;lt; workers.size() ; i++) {
            int id = workers.get(i);
            if( workers.get(i-1) &amp;gt; id) {
                up++;
            }
            id += (up * 32) ;
//            System.err.println(&amp;quot;id: &amp;quot; + id);
            workersOrig[id] = true;
        }
        String anwser = &amp;quot;&amp;quot;;
        for( int i = 0 ; i &amp;lt; n ; i++) {
            if( !workersOrig[i]) anwser += i + &amp;quot; &amp;quot;;
        }
//        System.err.println(&amp;quot;expected solve: &amp;quot; + anwser.substring(0, anwser.length()-1));
        System.out.println(anwser.substring(0, anwser.length()-1));
        System.out.flush();


    }

    private static void query(int n, int b, int f, List&amp;lt;String&amp;gt; response,Scanner sc) {
        String res = &amp;quot;&amp;quot;;
        for( int i = 0 ; i &amp;lt; n ; i++) {
            res += (((i % 32) &amp;gt;&amp;gt; response.size()) &amp;amp; 1) == 1 ? &amp;quot;1&amp;quot; : &amp;quot;0&amp;quot;;
        }
        System.err.println(&amp;quot;query is &amp;quot; + res);
        System.out.println(res);
        System.out.flush();

        res = sc.nextLine();
        System.err.println(&amp;quot;res is &amp;quot; + res);

        if( res.equals(&amp;quot;-1&amp;quot;)) {
            System.err.println(&amp;quot;error res is &amp;quot; + res);
            System.err.flush();
            System.exit(1);
        }

        response.add(res);
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[gcj2019-qr3]Cryptopangrams]]></title><description><![CDATA[Cryptopangrams gcd(최대 공약수) 이 문제를 해결하는데 엄청나게 시간을 낭비했다. 풀이 1: 인접한 두 수의 최대 공약수 구하기(a * b = c, b * d = e 일때 c,e 의 최대 공약수는 b이다.) 접근…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr3/</guid><pubDate>Mon, 13 Jan 2020 17:32:51 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/000000000008830b&quot;&gt;Cryptopangrams&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;gcd(최대 공약수)&lt;/h2&gt;
&lt;p&gt;이 문제를 해결하는데 엄청나게 시간을 낭비했다.&lt;/p&gt;
&lt;p&gt;풀이 1: 인접한 두 수의 최대 공약수 구하기(a * b = c, b * d = e 일때 c,e 의 최대 공약수는 b이다.)&lt;/p&gt;
&lt;p&gt;접근 1으로 풀었을 때, 이 문제의 함정을 조심해야한다.&lt;/p&gt;
&lt;p&gt;접근 2: 풀이 1로만 접근했을 때에는 ABABABB 와 BABABAA 를 판별하지 못한다. 왜냐하면 AB와 BA의 최대 공약수는 자기자신 AB이기 때문이다.
즉, 최대공약수를 통해서 소수를 유추해내려면 적어도 2쌍의 다른 소수의 곱이 필요하다 (예: AB BC =&gt; gcd = B로 유추가능, AB BA =&gt; gcd AB 유추 불가능)&lt;/p&gt;
&lt;p&gt;접근 3: 접근 2까지 했으나 visible set은 통과하나 hidden set은 통과를 못함. 결국 유투브에서 원인을 찾아낼 수 있었음
소수의 크기가 10^100이기때문에 BigInteger를 사용해야만 했는데 시스템 입력에서 읽어올때 &lt;strong&gt;BigInteger.valueOf(sc.nextInt())&lt;/strong&gt; 식으로 읽어오고 있던걸 &lt;strong&gt;sc.nextBigInteger()&lt;/strong&gt;로 읽어오니까 통과함 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package codejam.qr2019.q3;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.*;

public class Solution {

    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int tc = sc.nextInt();
        sc.nextLine();
        for( int i = 0 ; i &amp;lt; tc ; i++ ) {
            SortedSet&amp;lt;BigInteger&amp;gt; primes = new TreeSet&amp;lt;&amp;gt;();
            BigInteger n = sc.nextBigInteger();
            int l = sc.nextInt();
            List&amp;lt;BigInteger&amp;gt; input = new ArrayList&amp;lt;&amp;gt;();
            List&amp;lt;BigInteger&amp;gt; primesOrder = new ArrayList&amp;lt;&amp;gt;();
            BigInteger prev = sc.nextBigInteger();
            int idx = 0;
            for( int j = 1 ; j &amp;lt; l; j++) {
                BigInteger number = sc.nextBigInteger();
                BigInteger prevNumber =prev;
                if( prevNumber.compareTo(number) != 0 ) {
                    BigInteger prime = gcd(number, prevNumber);
                    if( j % 2 != 0) {
                        //BABAA ABABB
                        //BAC
                        // AAAAB
                        BigInteger other = prevNumber.divide(prime);
                        for( int k = 0 ; k &amp;lt;= j ; k++) {
                            primesOrder.add(k %2 == 0 ? other: prime);
                        }
                        primesOrder.add(number.divide(prime));
                    } else {
                        //ABABAA
                        BigInteger other = prevNumber.divide(prime);
                        for( int k = 0 ; k &amp;lt;= j ; k++) {
                            primesOrder.add(k %2 == 0 ? prime: other);
                        }
                        primesOrder.add(number.divide(prime));
                    }
                    idx = j;
                    break;
                }
            }
            for( int j = idx+1; j &amp;lt; l ; j++) {
                // 12 23 34 ..  end-1 end
                BigInteger num = sc.nextBigInteger();
                BigInteger prevNum = primesOrder.get(primesOrder.size()-1);
                BigInteger number = num.divide(prevNum);
                primesOrder.add(number);
            }
//            primesOrder.add(input.get(input.size()-1).divide(primesOrder.get(primesOrder.size()-1)));
            primes.addAll(primesOrder);

//            Assert.check(primes.size() == 26);
//            Assert.check(primes.first().compareTo(primes.last()) &amp;lt; 0);

            Iterator&amp;lt;BigInteger&amp;gt; it = primes.iterator();
            Map&amp;lt;BigInteger, Integer&amp;gt; mapping = new HashMap&amp;lt;&amp;gt;();
            int cnt = 0 ;
            while(it.hasNext()) {
                mapping.put(it.next(), cnt++);
            }
            char[] alphabet = &amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot;.toCharArray();
            System.out.print(String.format(&amp;quot;Case #%d: &amp;quot;,i+1));
            for( BigInteger p : primesOrder) {
                System.out.print(alphabet[mapping.get(p)]);
            }
            System.out.println(&amp;quot;&amp;quot;);

        }


    }

    public static BigInteger gcd(BigInteger a , BigInteger b) {
        if( a.compareTo(b) &amp;lt; 0) {
            BigInteger tmp = a;
            a = b;
            b = tmp;
        }
        while(b.compareTo(BigInteger.ZERO) != 0) {
            BigInteger r = a.mod(b);
            a = b;
            b = r;
        }
        return a;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 7]]></title><description><![CDATA[스프링 기술 응용 SQL 분리 기존의 Dao를 인터페이스로 구현하여 데이터 액세스 기술에 독립적으로 변경할 수 있게 되었다. 그러나 테이블의 정보를 담고있는 sql이 변경된다면,
dao의 변경은 sql에 독립적인 dao를 만들기 위해서 sql…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring7/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring7/</guid><pubDate>Sun, 12 Jan 2020 17:18:17 GMT</pubDate><content:encoded>&lt;h1&gt;스프링 기술 응용&lt;/h1&gt;
&lt;h2&gt;SQL 분리&lt;/h2&gt;
&lt;p&gt;기존의 Dao를 인터페이스로 구현하여 데이터 액세스 기술에 독립적으로 변경할 수 있게 되었다. 그러나 테이블의 정보를 담고있는 sql이 변경된다면,
dao의 변경은 sql에 독립적인 dao를 만들기 위해서 sql을 분리시켜보자. sql을 분리시키기 위해서는 변하는 작업과 변하지 않는 작업을 구분한다.
변하는 작업은 기존 dao의 데이터 액세스 로직이고, 변하는 로직은 sql이다. 즉 변하는 부분을 스프링 컨테이너를 통해서 DI받도록 수정해본다. &lt;/p&gt;
&lt;p&gt;문제점: dao가 sql에 의존적이기 때문에 sql이 변경될 시(생각보다 잦음), dao를 함께 수정해줘야 함
해결: sql을 DI받는다. &lt;/p&gt;
&lt;p&gt;문제점: sql이 새로 추가될때마다, 새로운 프로퍼티 추가 및 수정메소드를 만드는 변경이 뒤 따른다.
해결: sql을 콜렉션 형태로 DI받는다.&lt;/p&gt;
&lt;p&gt;문제점: sql과 DI 설정정보가 섞여있으면 관리하기에 좋지 않을뿐더러, sql을 꼭 빈 설정정보에(xml)뿐 아니라, 별도의 파일이나, db, 원격서버에서 sql을 읽어올 수 있도록 확장이 불가능하다. 또한 스프링 설정파일로부터 주입받는 정보들은 어플리케이션을 다시 시작하기 전까지는 변경이 어렵다.
해결: sql을 제공받을 수 있는 기능을 확장이 용이하도록, dao에 sql을 제공해주는 기능을 독립 시킨다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sql 제공 인터페이스 input: sql key / output: sql
ß&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[gcj2019-qr2]Foregone Solution]]></title><description><![CDATA[qr2019-2 backtracking]]></description><link>https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr2/</guid><pubDate>Sun, 12 Jan 2020 08:53:22 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da&quot;&gt;qr2019-2&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;backtracking&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package codejam.qr2019.q2;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.util.Scanner;

/**
 * https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da
 * 거꾸로 올라가는방식은?
 * 일단 첫번째와 끝은 이미 정해져있음
 * 만날때에는 서로 다른방향으로 가야하기 때문에 방향이 강제됨
 * n칸이라고할때 n을 두가지 방향으로 어떻게 배치할것인가 S n-1번 E n-1번 움직여야함
 * 상대가 s로 n-1번움직였다면 아래에있으면 안됨 즉 s를 다쓰면 안됨
 * 상대가 s를 n-1번쓸때까지 s를 남겨두려면 s를 쓸때 e를 쓰면됨?
 * 반대방향으로 갈경우 겹치지 않는 이유는 반대의 경우를 가정하고 생각한다.
 * (가정)반대방향으로만 갔을경우에 어느순간 상대방과 같은 방향으로 이동한다.
 * 어느지점에서 마주쳤다고 가정했을경우 상대방과 나는 (결과론적으로) 같은 수의 동쪽과 같은수의 남쪽을 사용했을 경우이다.
 * 그 경우에 다음 이동방향은 상대방과 무조건 반대이므로 겹치지 않게된다.
 */
public class Solution {
    public static void main(String[] args) throws FileNotFoundException {
//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(&amp;quot;codejam/qr2019/q2/input.txt&amp;quot;))));
        int tc = sc.nextInt();
        backtracking(sc, tc);
    }

    private static void inverseDirection(Scanner sc, int tc) {
        for(int i =0 ; i &amp;lt; tc ; i++) {
            int n = sc.nextInt();
            sc.nextLine();
            String move = sc.nextLine();
            char[] newMove = new char[move.length()];
            int j = 0;
            for( char a : move.toCharArray()) {
                if( a == &amp;#39;S&amp;#39;) newMove[j++] = &amp;#39;E&amp;#39;;
                else newMove[j++] = &amp;#39;S&amp;#39;;
            }
            System.out.println(String.format(&amp;quot;Case #%d: %s&amp;quot;,i+1, new String(newMove)));
        }
    }

    private static void backtracking(Scanner sc, int tc) {
        for( int i = 0 ; i &amp;lt; tc; i++) {
            int n = sc.nextInt();
            sc.nextLine();
            String move = sc.nextLine();
            String path = backtrackingInternal(n,new int[]{0,0},new int[]{0,0},move,&amp;quot;SE&amp;quot;);
            System.out.println(path);
        }
    }
    private static boolean samePosition(int[] e, int[]m) {
        return e[0] == m[0] &amp;amp;&amp;amp; e[1] == m[1];
    }
    private static boolean boundGrid(int y,int x, int n) {
        return y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; n &amp;amp;&amp;amp; x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n;
    }
    //input : 현재상태 상대방과 나의 위치와 상대방의 이동방향, 나의 가능한 이동방향
    //output : 중복되지 않는 경로
    private static String backtrackingInternal(int n, int[] e, int[] m, String ep, String mps) {
        if( samePosition(e,m) &amp;amp;&amp;amp; ep.length() == 0 ) {
            return &amp;quot;&amp;quot;;
        }

        // 이동가능 후보가 없거나 패스가 중복되거나
        if( (samePosition(e,m) &amp;amp;&amp;amp; ep.substring(0,1).equals(mps))) {
            return null;
        } else if(mps.contains(ep.substring(0,1))){
            mps = mps.replace(ep.substring(0,1),&amp;quot;&amp;quot;);
        }


        for( char d : mps.toCharArray()) {

            if( d == &amp;#39;E&amp;#39; ) {
                //이동
                m[1]++;
                if( ep.charAt(0) == &amp;#39;E&amp;#39;) {
                    e[1]++;
                } else {
                    e[0]++;
                }
                //후보군설정
                String candidates = boundGrid(m[0],m[1]+1,n) ? &amp;quot;E&amp;quot;: &amp;quot;&amp;quot;;
                candidates += (boundGrid(m[0]+1,m[1],n)) ? &amp;quot;S&amp;quot; : &amp;quot;&amp;quot;;
                String path = backtrackingInternal(n, e,m,ep.substring(1),candidates);
                m[1]--;
                if( ep.charAt(0) == &amp;#39;E&amp;#39;) {
                    e[1]--;
                } else {
                    e[0]--;
                }
                if(  path != null) {
                    return  &amp;quot;E&amp;quot; + path;
                }


            } else {
                m[0]++;
                if( ep.charAt(0) == &amp;#39;E&amp;#39;) {
                    e[1]++;
                } else {
                    e[0]++;
                }
                String candidates = boundGrid(m[0],m[1]+1,n) ? &amp;quot;E&amp;quot;:&amp;quot;&amp;quot;;
                candidates += (boundGrid(m[0]+1,m[1],n))?&amp;quot;S&amp;quot;:&amp;quot;&amp;quot;;
                String path = backtrackingInternal(n,e,m,ep.substring(1),candidates);
                m[0]--;
                if( ep.charAt(0) == &amp;#39;E&amp;#39;) {
                    e[1]--;
                } else {
                    e[0]--;
                }
                if( path != null) {
                    return &amp;quot;S&amp;quot; + path;
                }


            }
        }


        return null;
    }



}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[boj]9663]]></title><description><![CDATA[boj9663 backtracking]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-9663/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-9663/</guid><pubDate>Sun, 12 Jan 2020 08:53:22 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/6603&quot;&gt;boj9663&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;backtracking&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package boj;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.stream.IntStream;

import static java.lang.Math.abs;

public class Boj9663 {
    boolean[][] board;
    static boolean[] x;
    static boolean[] ru;
    static boolean[] rd;
    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int n = sc.nextInt();
        x = new boolean[14];
        ru = new boolean[27];
        rd = new boolean[27];
        System.out.println(putQueen(n,0,n, new boolean[n][n], new ArrayList&amp;lt;&amp;gt;()));
    }

    //backtracking
    //input: n, st-index, board
    //output: int
    public static int putQueen(int n, int cur, int remain, boolean[][] board, List&amp;lt;Integer&amp;gt; queens) {
        if( cur &amp;gt;= n &amp;amp;&amp;amp; remain &amp;gt; 0) {
            return 0;
        } else if( cur &amp;gt;= n ) {
            return 1;
        }
       // can put?
        int res = 0;
        for( int i = 0; i &amp;lt; n ; i++) {
            if( canPut(cur , i , board, queens)) {
                x[i] = ru[cur+i] = rd[cur-i+board.length-1] = true;
                res += putQueen(n,cur+1, remain-1, board, queens);
                x[i] = ru[cur+i] = rd[cur-i+board.length-1] = false;
            }
        }
        return res;

    }

    private static boolean canPut(int y, int xx, boolean[][] board, List&amp;lt;Integer&amp;gt; queens) {
        return !x[xx] &amp;amp;&amp;amp; !ru[y+xx] &amp;amp;&amp;amp; !rd[y-xx+board.length-1];
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[boj]6603]]></title><description><![CDATA[로또 조합 생각보다 조합을 구현하는 법이 어렵다고 느꼈다. 순열의 경우에는 더 간단하게 구현이 되었던거 같은데 조합의 경우에는 
집합의 전체갯수, 뽑는 갯수, 현재 index…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-6603/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-6603/</guid><pubDate>Sat, 11 Jan 2020 08:51:53 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/6603&quot;&gt;로또&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;조합&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;생각보다 조합을 구현하는 법이 어렵다고 느꼈다. 순열의 경우에는 더 간단하게 구현이 되었던거 같은데 조합의 경우에는
집합의 전체갯수, 뽑는 갯수, 현재 index(집합을 모두 순회했는데 뽑아야하는 갯수가 남아있다면 조합의 경우가 없는 경우이다.)
nCr = n-1Cr-1 + n-1Cr 의 의미를 돌아보면 n번째 원소를 뽑는경우 나머지에서 r-1개의 원소를 뽑는 경우의수와 n을 뽑지 않아서 나머지에서 r개의 원소를 뽑는경우이다. 즉 재귀호출을 구현할 때에도 집합을 순회하면서 현재 위치를 index로 저장해두면서 현재 index의 원소를 뽑는경우와 안뽑는경우로 나누어 재귀호출을 한다.
기저조건은 뽑아야하는 갯수를 다 뽑았을 경우이다.
그 외 집합을 모두 순회한경우에도 뽑아야하는 갯수를 다 뽑지 못한경우는 조합을 조립하지 못하는 경우이므로 넘어간다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package boj;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Boj6603 {
    public static void main(String[] args) throws FileNotFoundException {
//        7 1 2 3 4 5 6 7
//        8 1 2 3 5 8 13 21 34
//        0
//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(&amp;quot;boj/6603.txt&amp;quot;))));
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int n = sc.nextInt();
        while(n != 0) {
            int[] arr = new int[n];
            for( int i =0 ; i &amp;lt; n ; i++) {
                arr[i]= sc.nextInt();
            }
            printLotto(IntStream.of(arr).boxed().collect(Collectors.toList()),6,0,new ArrayList&amp;lt;&amp;gt;());
           n = sc.nextInt();
           System.out.println(&amp;quot;&amp;quot;);
        }
    }

    // 조합
    // input: 집합, 뽑아야하는 조합개수, 지금까지 뽑은 숫자들
    // output: void
    // 어떻게 조합을 중복제거할 수 있을까
    public static void printLotto(List&amp;lt;Integer&amp;gt; group, int k, int cur, List&amp;lt;Integer&amp;gt; arr) {
        if( arr.size() == k) {
            out(arr);
        } else if( cur == group.size()) return;
        else {

            arr.add(group.get(cur));
            printLotto(group, k, cur + 1, arr);
            arr.remove(arr.size() - 1);
            printLotto(group, k, cur + 1, arr);
        }
    }

    public static void out(List&amp;lt;Integer&amp;gt; list) {
        StringBuilder sb = new StringBuilder();
        for(Integer i : list) {
            sb.append(&amp;quot; &amp;quot; + i);
        }
        System.out.println(sb.substring(1));
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[gcj2019-qr1]Foregone Solution]]></title><description><![CDATA[Foregone Solution 생각 4는 2 2 로 나뉘기 때문에 4를 2로 변경해주면 된다.
숫자가 크기때문에 스트링으로 출력
숫자형태로 만들기 위해서 앞의 0은 제거]]></description><link>https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr1/</guid><pubDate>Thu, 09 Jan 2020 16:44:23 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/0000000000088231&quot;&gt;Foregone Solution&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;생각&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;4는 2 2 로 나뉘기 때문에 4를 2로 변경해주면 된다.
숫자가 크기때문에 스트링으로 출력
숫자형태로 만들기 위해서 앞의 0은 제거&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package codejam.qr2019.q1;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int tc = in.nextInt();
        in.nextLine();
        for(int i = 0; i &amp;lt; tc ; i++) {
            String num = in.nextLine();
            String num1 = num.replaceAll(&amp;quot;4&amp;quot;,&amp;quot;2&amp;quot;);
            String num2 = num.replaceAll(&amp;quot;[^4]&amp;quot;,&amp;quot;0&amp;quot;)
                    .replaceAll(&amp;quot;4&amp;quot;,&amp;quot;2&amp;quot;)
                    .replaceAll(&amp;quot;^0*2&amp;quot;,&amp;quot;2&amp;quot;)
                    ;
            System.out.println(String.format(&amp;quot;Case #%d: %s %s&amp;quot;,i+1,num1,num2));
        }

    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]ClockSync]]></title><description><![CDATA[CLOCKSYNC 생각 (알고리즘: 완전탐색) 완전 탐색이므로 한번씩 눌러보면서 12시로 맞는지 체크하자
4번씩 누르면 초기화가 되기때문에 0번에서 3번까지 눌러보면서 
모든 경우의 수를 체크한다. 주의할 점은…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-clocksync/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-clocksync/</guid><pubDate>Thu, 09 Jan 2020 16:44:23 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/CLOCKSYNC&quot;&gt;CLOCKSYNC&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;생각 (알고리즘: 완전탐색)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;완전 탐색이므로 한번씩 눌러보면서 12시로 맞는지 체크하자
4번씩 누르면 초기화가 되기때문에 0번에서 3번까지 눌러보면서
모든 경우의 수를 체크한다. 주의할 점은 3번까지 눌러놓고 상태를 초기화 해줘야한다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;보통 인풋과 아웃풋을 정하는 부분이 힘든데
아웃풋의 경우 알고리즘이 원하는 답안이 될 경우가 크다.
문제가 원하는 답은 최소 클릭횟수 이기때문에, 재귀함수로 문제를 풀기위해서는 어느 시점의 최소 클릭횟수를 리턴해주면된다.
인풋의 경우 상태값이 되는경우가 많다. (시계의 시침의 현재 상태), 또한 진행상황을 기록해야하므로 진행중인 순번도 함께 오는경우가 많다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.clocksync;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    static int[][] switches = new int[10][];
    static int[] clocks = new int[16];
    public static void main(String[] args) throws FileNotFoundException {
        switches[0] = new int[]{0,1,2};
        switches[1] = new int[]{3, 7, 9, 11};
        switches[2] = new int[]{4, 10, 14, 15};
        switches[3] = new int[]{0, 4, 5, 6, 7};
        switches[4] = new int[]{6, 7, 8, 10, 12};
        switches[5] = new int[]{0, 2, 14, 15};
        switches[6] = new int[]{3, 14, 15};
        switches[7] = new int[]{4, 5, 7, 14, 15};
        switches[8] = new int[]{1, 2, 3, 4, 5};
        switches[9] = new int[]{3, 4, 5, 9, 13};

//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        Scanner sc = new Scanner(new FileInputStream(&amp;quot;algospot/clocksync/input.txt&amp;quot;));


        int tc = sc.nextInt();
        for( int i =0; i &amp;lt; tc ; i++) {
            clocks = new int[16];
            for(int j = 0 ; j &amp;lt; 16; j++) {
                clocks[j] = sc.nextInt();
            }

            //버튼을 한개씩 다 눌러본다
            // 4번누르면 제자리 이므로 3번씩만 눌러본다

            int res;
            if( (res = click(clocks, 0)) &amp;lt; Integer.MAX_VALUE )  {
                System.out.println(res);
            } else {
                System.out.println(-1);
            }
        }
    }

    //재귀
    //input: 시계들, 버튼, 누른버튼
    //output: 현상황에서의 num번부터 누를때 최소횟수
    static int click(int[] clocks,int num) {
        if( checkTime(clocks)) {
            return 0;
        }
        if( num == 10) {
            return Integer.MAX_VALUE;
        }

        //4번씩 눌러본다. 안누른거 포함
        int res = Integer.MAX_VALUE;
        for(int i=0; i &amp;lt; 4; i++) {
            if( i&amp;gt; 0) push(clocks,num);
            int min = click(clocks,num+1);
            if( min != Integer.MAX_VALUE) {
                res = Math.min(res , min + i);
            }
        }
        //3번까지 눌렀으므로 초기화해줌
        push(clocks,num);
        return res;
    }
    static void push(int[] clocks,int num) {
        for (int m : switches[num]) {
            clocks[m] = clocks[m] == 12 ? 3 : clocks[m]+3;
        }
    }
    static boolean checkTime(int[] clocks) {
        return Arrays.stream(clocks).allMatch(i-&amp;gt;i==12);
    }
    static int total(int[] buttons) {
        return Arrays.stream(buttons).sum();
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]tsp1]]></title><description><![CDATA[TSP1 재귀 호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-tsp1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-tsp1/</guid><pubDate>Mon, 06 Jan 2020 16:15:24 GMT</pubDate><content:encoded>&lt;h1&gt;TSP1&lt;/h1&gt;
&lt;h2&gt;재귀 호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.tsp1;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc = new Scanner(new FileInputStream(&amp;quot;algospot/tsp1/input.txt&amp;quot;));
        int tc = sc.nextInt();
        for( int i = 0; i &amp;lt; tc; i++) {
            int cities = sc.nextInt();
            double[][] map = new double[cities][cities];

            for( int j = 0 ; j &amp;lt; cities*cities;j++) {
                int y = j / cities;
                int x = j % cities;
                map[y][x] = sc.nextDouble();
            }
            double res = Double.MAX_VALUE;
            for( int k = 0 ; k &amp;lt; cities; k++) {
                boolean[] visits = new boolean[cities];
                visits[k] = true;
                res = Math.min(res,traverse(map, visits, k));
            }
            System.out.println(res);

        }

    }

    // input: 도시간 거리 정보 double[][], 방문여부 boolean[], 시작점 int
    // output: 최소 여행 길이
    public static double traverse(double[][] map, boolean[] visits, int st) {

        int next = -1;
        for( int i = 0;  i &amp;lt; visits.length ; i++) {
            if( !visits[i]) {
                next = i;
                break;
            }
        }
        // 모두 방문했다면
        if( next == -1) {
            return 0;
        }
        double minDist = Double.MAX_VALUE;
        for(int i = 0 ; i &amp;lt; visits.length; i++) {
            if(!visits[i]) {
                visits[i]= true;
                double dist = map[st][i] + traverse(map,visits,i);
                visits[i]= false;
                if( dist &amp;lt; minDist) {
                    minDist = dist;
                }
            }
        }
        return minDist;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]boardcover]]></title><description><![CDATA[BOARDCOVER 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-boardcover/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-boardcover/</guid><pubDate>Sat, 04 Jan 2020 17:40:56 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/BOARDCOVER&quot;&gt;BOARDCOVER&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public class Main {

    private static char[][][] block = new char[][][] {
            {{&amp;#39;#&amp;#39;,&amp;#39;#&amp;#39;},
                    {&amp;#39;#&amp;#39;,&amp;#39;.&amp;#39;}},
            {{&amp;#39;#&amp;#39;,&amp;#39;#&amp;#39;},
                    {&amp;#39;.&amp;#39;,&amp;#39;#&amp;#39;}},
            {{&amp;#39;.&amp;#39;,&amp;#39;#&amp;#39;},
                    {&amp;#39;#&amp;#39;,&amp;#39;#&amp;#39;}},
            {{&amp;#39;#&amp;#39;,&amp;#39;.&amp;#39;},
                    {&amp;#39;#&amp;#39;,&amp;#39;#&amp;#39;}},
    };

    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc = new Scanner(new FileInputStream(&amp;quot;algospot/boardcover/input.txt&amp;quot;));
        int tc = sc.nextInt();
        IntStream.range(0,tc)
                .forEach(i-&amp;gt; {
                    //tc
                    int row = sc.nextInt();
                    int col = sc.nextInt();
                    sc.nextLine();

                    char[][] map = new char[row][];

                    // map reading
                    final int[] sum = {0};
                    IntStream.range(0,row)
                            .forEach(ii-&amp;gt;{
                                map[ii] = sc.nextLine().toCharArray();
                                sum[0] += IntStream.range(0,map[ii].length)
                                        .mapToObj(index-&amp;gt;map[ii][index])
                                        .filter(c-&amp;gt;c==&amp;#39;.&amp;#39;)
                                        .count();
                            });
                    System.out.println(getBlockNum(map,sum[0]));

                });
    }

    // input: map, 남은 칸수
    // output: block을 놓을 수 있는 가능한 수
    public static int getBlockNum(final char[][] map, int remain) {
        if( remain % 3 != 0)
            return 0;
        if( remain == 0 )
            return 1;

        // 맨 왼쪽 위쪽부터 블록을 채워감
        int first = IntStream.range(0,map.length * map[0].length)
                .filter(i-&amp;gt;map[i/map[0].length][i%map[0].length] == &amp;#39;.&amp;#39;)
                .findFirst().getAsInt();
        int r = first / map[0].length;
        int c = first % map[0].length;
        int res= 0 ;

        for( int i = 0; i &amp;lt; 4 ; i++) {
            char[][] b = block[i];
            if( isBlockFit(map, b, r, c)) {
                addBlock(map,b,r,c);
                res += getBlockNum(map, remain-3);
                removeBlock(map,b,r,c);
            }
        }
        return res;
    }

    private static void removeBlock(char[][] map, char[][] b, int r, int c) {
        if(b[0][0] == &amp;#39;.&amp;#39;) c--;
        for( int i = 0; i &amp;lt; 2 ; i++) {
            for( int j = 0 ; j &amp;lt; 2 ; j++) {
                if( b[i][j] == &amp;#39;#&amp;#39;) {
                    map[r+i][c+j] = &amp;#39;.&amp;#39;;
                }
            }
        }
    }

    private static void addBlock(char[][] map, char[][] b, int r, int c) {
        if(b[0][0] == &amp;#39;.&amp;#39;) c--;
        for( int i = 0; i &amp;lt; 2 ; i++) {
            for( int j = 0 ; j &amp;lt; 2 ; j++) {
                if( b[i][j] == &amp;#39;#&amp;#39;) {
                    map[r+i][c+j] = &amp;#39;#&amp;#39;;
                }
            }
        }
    }

    private static boolean isBlockFit(char[][] map, char[][] b, int r, int c) {
        if(b[0][0] == &amp;#39;.&amp;#39;) c--;
        if(!(r &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; map.length &amp;amp;&amp;amp; c &amp;gt;=0 &amp;amp;&amp;amp; c &amp;lt; map[0].length
        &amp;amp;&amp;amp; r+1 &amp;gt;= 0 &amp;amp;&amp;amp; r+1 &amp;lt; map.length &amp;amp;&amp;amp; c+1&amp;gt;=0 &amp;amp;&amp;amp; c+1 &amp;lt; map[0].length)) return false;
        for( int i = 0; i &amp;lt; 2 ; i++) {
            for( int j = 0 ; j &amp;lt; 2 ; j++) {
                if( map[r+i][c+j] == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; b[i][j] == &amp;#39;#&amp;#39;) {
                    return false;
                }
            }
        }
        return true;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 6]]></title><description><![CDATA[AOP…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring6/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring6/</guid><pubDate>Sat, 04 Jan 2020 16:00:39 GMT</pubDate><content:encoded>&lt;h1&gt;AOP&lt;/h1&gt;
&lt;h2&gt;프록시&lt;/h2&gt;
&lt;p&gt;서비스 추상화를 통해서, 트랜잭션을 적용하는 내용을 데이터 액세스 기술에 관계없이 적용할 수 있게끔 &lt;code class=&quot;language-text&quot;&gt;전략패턴&lt;/code&gt;으로 분리 시켰지만,
비지니스 로직자체에 트랜잭션을 적용시키는(부가기능) 코드는 그대로 남아있다. 트랜잭션을 적용시키는 부분까지도 비지니스 로직에서 제거하기 위해서
인터페이스를 통해 구현부분을 분리시켜 &lt;code class=&quot;language-text&quot;&gt;부기가능&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;핵심기능&lt;/code&gt;을 사용하도록 구조를 만든다.&lt;/p&gt;
&lt;p&gt;여기서 주의할 점은 클라이언트가 직접 &lt;code class=&quot;language-text&quot;&gt;핵심기능&lt;/code&gt;을 사용하지 못하도록 &lt;code class=&quot;language-text&quot;&gt;부가기능&lt;/code&gt;이 마치 &lt;code class=&quot;language-text&quot;&gt;핵심기능&lt;/code&gt;인것처럼 꾸며 클라이언트의 요청을 가로채야 한다는 사실이다. 여기서 &lt;code class=&quot;language-text&quot;&gt;부가기능&lt;/code&gt;은 프록시, &lt;code class=&quot;language-text&quot;&gt;핵심기능&lt;/code&gt;은 타겟이라고 부른다.&lt;/p&gt;
&lt;p&gt;프록시는 두가지로 구분할 수 있는데&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트가 타겟에 접근하는 방법을 제어하기 위해서&lt;/li&gt;
&lt;li&gt;타겟에 부가적은 기능을 부여해주기 위해서&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;각각을 목적에 따라 디자인 패턴에서는 다른 패턴으로 구분한다.&lt;/p&gt;
&lt;h2&gt;데코레이터 패턴&lt;/h2&gt;
&lt;p&gt;부가기능을 부여하기 위해서 프록시를 사용하는 패턴이다. 프록시를 여러개를 사용해 각각 다른 부가기능을 타겟 기능에 부여할 수 있다. &lt;/p&gt;
&lt;p&gt;예) 선물포장하기&lt;/p&gt;
&lt;p&gt;선물포장요청-&gt; 리본묶기 -&gt; 포장지 감싸기 -&gt; 선물&lt;/p&gt;
&lt;h2&gt;프록시 패턴&lt;/h2&gt;
&lt;p&gt;타겟에 접근하는 방법을 제어하기 위해서 사용하는 패턴이다. &lt;strong&gt;프록시 패턴의 프록시는 타겟의 기능을 확장하거나 추가하지 않는다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;예) lazy init&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;타겟이 당장 쓰이지 않지만, 참조값이 필요할 때 프록시를 미리 생성해두고 클라이언트가 프록시를 통해 메소드를 호출할 때, 타겟을 생성해서 요청을 위임한다. 즉, 타겟을 직접 사용할 때까지 최대한 생성을 늦춘다. &lt;/li&gt;
&lt;li&gt;원격 오브젝트에 대한 접근방법을 제공해줄 때 사용할 수 있다. 원격 오브젝트에 대한 프록시를 만들어두고 클라이언트는 마치 로컬 오브젝트에게 요청하듯이 작업을 요청하고, 프록시는 내부에서 원격오브젝트를 실행하여 결과를 돌려주는 식이다.&lt;/li&gt;
&lt;li&gt;타겟에 대한 접근권한을 제어하기 위해서도 사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;예) Collections.unmodifiableCollection&lt;/p&gt;
&lt;p&gt;데코레이터와 프록시는 유사해보이지만, 생성을 지연하는 프록시의 경우 구체적인 생성 방법을 알아야하므로 타겟에 대한 구체적인 정보를 알고 있는 경우가 많다.&lt;/p&gt;
&lt;h2&gt;프록시 작성의 문제점&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;타겟의 인터페이스를 구현하는게 번거롭다. 단순 위임형식이어도 일일이 코드를 작성해야하고, 타겟의 메소드가 추가되거나 변경될 경우 함께 수정해야한다.&lt;/li&gt;
&lt;li&gt;부가기능 코드가 중복될 가능성이 많다. 각 메소드마다 부가기능이 들어간다면 부가기능은 각각 메소드마다 항상 중복되어 나타나게 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;다이나믹 프록시&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;프록시 팩토리&lt;/code&gt;에 의해서 런타임 시 다이나믹하게 만들어지는 객체이다. 타겟의 메소드 수가 몇개이던 상관없이 타겟 인터페이스의 정보와 프록시 메소드 호출 시 실행되는 &lt;code class=&quot;language-text&quot;&gt;InvocationHandler&lt;/code&gt;만 구현하면 프록시 적용이 가능하다. 또한 타겟의 적용 대상이 제한되있지 않으므로 재사용성이 높다.&lt;/p&gt;
&lt;p&gt;예) 리턴 타입이 string인 것만 uppercase적용, 메소드 이름이 say로 시작하는 경우에만 uppercase 적용&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;주의&lt;/strong&gt;
InvocationHandler를 구현할 때, 타겟의 Exception은 InvocationTargetException으로 감싸져 던져지므로 InvocationTargetException으로 캐치를 한뒤 , getTargetException으로 해당 예외처리를 해야한다.&lt;/p&gt;
&lt;h2&gt;다이나믹 프록시 문제점&lt;/h2&gt;
&lt;p&gt;다이나믹 프록시와 InvocationHandler를 통해서 프록시를 적용할 수 있으므로, 프록시를 스프링 DI를 통해 주입시킬 수 있어야한다. 하지만 &lt;strong&gt;DI의 대상이 되는 다이나믹 프록시 객체는 클래스 명이 없으므로 일반적으로 DI될 수 있는 방법이 없다&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;스프링의 빈을 만드는 방법은 클래스의 디폴터 생성자를 이용하는 방법 이외에도 여러가지 방법을 제공하는데 그 중 하나가 &lt;code class=&quot;language-text&quot;&gt;팩토리 빈&lt;/code&gt;을 이용하는 방법이다.
&lt;code class=&quot;language-text&quot;&gt;팩토리 빈&lt;/code&gt;을 만드는 방법에는 여러가지가 있는데 가장 간단한 방법은 FactoryBean 인터페이스를 구현하는것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;팩토리 빈&lt;/h3&gt;
&lt;p&gt;팩토리 빈의 등록방법은 여타 빈의 등록방법과 다르지 않다. 아래 예제에서 등록되는 aaa의 빈의 경우 FactoryBean의 객체가 등록되는것이 아닌
FactoryBean의 getObject 메소드가 생성해주는 객체가 aaa빈으로 등록이되며, 타입은 팩토리 빈의 getObjectType이 리턴하는 타입으로 결정된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;bean id =&amp;quot;aaa&amp;quot; class=&amp;quot;factoryBeanclass&amp;quot;&amp;gt; 
    &amp;lt;property name=&amp;quot;bbb&amp;quot; value=&amp;quot;testString&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;팩토리 빈은 빈 이름앞에 &lt;code class=&quot;language-text&quot;&gt;&amp;amp;&lt;/code&gt;를 붙여주면 얻을 수 있다.&lt;/li&gt;
&lt;li&gt;팩토리 빈은 빈을 생성할 때 필요한 정보들을 프로퍼티로 가지고 있다가, 빈을 생성할 때 해당 프로퍼티를 전달하면서 객체를 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;즉 프록시를 생성하는 팩토리 빈과 타겟을 빈으로 등록하여 프록시를 빈으로 등록하여 사용할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;팩토리 빈의 장점과 한계&lt;/h2&gt;
&lt;h3&gt;장점&lt;/h3&gt;
&lt;p&gt;프록시 팩토리 빈의 장점은 타겟에 제한없이 재사용이 가능하다는 점이다. 또한 다이나믹 프록시의 문제점 2가지 일일이 메소드를 구현해야한다는 점과,
부가기능의 코드가 메소드마다 중복되어 나타나는 문제점을 &lt;code class=&quot;language-text&quot;&gt;프록시 팩토리 빈&lt;/code&gt;으로 해결할 수 있다.&lt;/p&gt;
&lt;h3&gt;한계&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;한번에 여러 클래스에 공통적인 부가기능을 제공하는 것은 불가능하다. (하나의 클래스는 가능, 즉 여러개의 팩토리 빈 설정이 중복) - 200개의 클래스에 여러 부가기능을 적용시키려면 200 * 부가기능갯수 만큼의 팩토리 빈 설정이 필요 &lt;/li&gt;
&lt;li&gt;InvocationHandler는 타겟 객체를 프로퍼티로 지니고 있으므로, 프록시 팩토리 빈 갯수만큼 만들어진다. &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;프록시 팩토리 빈&lt;/h2&gt;
&lt;p&gt;jdk에서는 다이나믹 프록시 외에도 프록시를 만들 수 있도록 다양한 기술을 지원한다. 따라서 스프링은 일관된 방법으로 프록시를 만들 수 있게끔 추상화 된 레이어를 제공한다.&lt;/p&gt;
&lt;h3&gt;MethodInterceptor vs InvocationHandler&lt;/h3&gt;
&lt;p&gt;invocationHandler.invoke는 타겟에 대한 정보를 제공하지 않기 때문에 직접 invocationHandler가 타겟을 알고 있어야 하지만, MethodInterceptor의 invoke는 proxyFactoryBean으로부터 타겟 정보도 제공받으므로, MethodInterceptor의 경우 타겟과 독립적으로 만들어지고,사용될 수 있다.&lt;/p&gt;
&lt;p&gt;타겟으로부터 독립될 수 있다면 MethodInterceptor는 타겟에 독립적으로 빈으로 등록되어 여러 타겟이 공유할 수 있다(싱글톤 패턴)
포인트컷 역시 타겟에 독립될 수 있다면 빈으로 등록되어 여러 타겟이 공유할 수 있다(싱글톤 패턴)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;중복 문제의 접근 방법
1. jdbc api를 사용하는 dao 코드에서 메소드 마다 try/catch/finally 블록 중복 발생
    - 바뀌는 부분과 바뀌지 않는 부분으로 분리, 템플릿/콜백 패턴으로 해결
2. 반복적인 위임 코드가 필요한 프록시
    - 다이나믹 프록시라는 런타임 코드 자동생성 기법 사용하여 해결&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;팩토리 빈의 한계를 스프링 프록시 팩토리 빈으로 개선&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;팩토리 빈의 문제상황 인지&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;한번에 여러 클래스에 부가기능 제공 불가능&lt;/li&gt;
&lt;li&gt;InvocationHandler는 타겟을 의존하고 있으므로, 타겟 적용 갯수만큼 늘어남&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제상황을 어떻게 해결할지 고민&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;한번에 여러 클래스에 부가기능 제공 불가능에서 변하는 부분과 변하지 않는 부분을 설정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변하는 부분: 부가기능을 적용할 실제 타겟&lt;/li&gt;
&lt;li&gt;변하지 않는부분: 타겟의 타입에 맞는 프록시 생성 작업&lt;/li&gt;
&lt;li&gt;고려 방향: 부가기능을 적용할 실제 타겟의 리스트를 주입받아 프록시 생성 작업을 자동으로 할 수 있다면?? =&gt; 빈 후처리기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InvocationHandler는 타겟을 의존하고 있으므로, 중복해서 발생하는 문제&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변하는 부분: 실제 부가기능을 적용할 타겟&lt;/li&gt;
&lt;li&gt;변하지 않는 부분: 적용할 부가기능&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고려 방향: 타겟을 주입받아서 부가기능을 적용시킬 수 있다면?? =&gt; 어드바이스, 포인트 컷&lt;/p&gt;
&lt;h2&gt;빈 후처리기&lt;/h2&gt;
&lt;p&gt;빈 후처리기는 빈 설정파일을 통해 생성된 빈 객체들을 조건에 맞게 수정하거나, 대체할 수 있다. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;DefaultAdvisorAutoProxyCreator 동작 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;등록된 빈중에서 Advisor를 구현한 객체들을 모두 찾는다.&lt;/li&gt;
&lt;li&gt;생성되는 모든 빈에 대해서 어드바이저 포인트컷의 적용대상일 경우 프록시를 만들어서 원래 빈을 대체한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;AspectJ 포인트컷 표현식&lt;/h3&gt;
&lt;p&gt;AspectJ 표현식의 대상을 표현하는데 다양한 방법이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;execution - 메소드의 시그니처를 비교하는 방식 (ex: Object.class.getMethod(“getClass”))&lt;/li&gt;
&lt;li&gt;bean - 빈이름으로 대상을 설정 (클래스와 메소드기준을 넘어섬)&lt;/li&gt;
&lt;li&gt;@annotation - 특정 어노테이션으로 대상을 설정(ex: @anootation(org.springframework.transaction.Transactional))&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;주의점: AspectJ 포현식의 타입패턴의 경우 객체의 클래스만을 비교하는것이 아닌 객체의 모든 타입을 비교하여 대상을 결정한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ex: A-&gt;B(C) [A: 자식 클래스 , B: 부모 클래스, (C): 부모 인터페이스] 라고할때 클래스 명으로 대상을 정할때 A 객체는 A타입이기도하면서 B 타입이기도 하며, C타입이기도 하다. 따라서 클래스 명 조건이 A,B,C중에 하나라도 적용된다면 대상에 포함된다.(AspectJ 타입패턴에 한해)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;리마인드&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;서비스 추상화
비지니스 로직에 트랜잭션 경계설정 -&gt; 트랜잭션 기술에 종속적인 코드 발생 -&gt; 서비스 추상으로 일관된 경계설정(트랜잭션 구현기술 DI)
추상화란: 인터페이스와 DI를 통해 &lt;code class=&quot;language-text&quot;&gt;무엇을 하는지는(추상흐름)&lt;/code&gt; 남기고 &lt;code class=&quot;language-text&quot;&gt;어떻게 하는지(구체적 구현)&lt;/code&gt;를 분리한것&lt;/li&gt;
&lt;li&gt;데코레이션 패턴
비지니스 로직에 트랜잭션 경계설정 코드 혼재 -&gt; 데코레이션 패턴으로 분리&lt;/li&gt;
&lt;li&gt;다이나믹 프록시 &amp;#x26; 프록시 팩토리 빈
데코레이션 패턴을 적용하기 위해서 모든 메소드 구현 및 트랜잭션(부가기능) 중복발생 -&gt; 다이나믹 프록시 적용 -&gt; 여러 클래스에 적용할 때 중복 발생 -&gt; 프록시 팩토리 빈(프록시 기술 추상화) 적용 -&gt; 어드바이스, 포인트컷을 타겟에 독립적으로 사용 가능&lt;/li&gt;
&lt;li&gt;자동 프록시 생성
트랜잭션 적용 대상마다 프록시 팩토리 빈 적용하여 중복 발생 -&gt; 빈 후처리기 적용 -&gt; AspectJ를 통한 포인트컷 표현식 적용&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;AOP 용어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;타겟 - 부가기능을 적용할 대상&lt;/li&gt;
&lt;li&gt;어드바이스 - 부가기능&lt;/li&gt;
&lt;li&gt;조인포인트 - 어드바이스가 적용될 수 있는 위치(프록시의 경우 메소드 실행단계)&lt;/li&gt;
&lt;li&gt;포인트컷 - 조인포인트를 선별하는 작업 혹은 모듈&lt;/li&gt;
&lt;li&gt;프록시 - 클라이언트와 타겟 사이에서 요청을 대신 받아 타겟에 위임하면서 부가기능을 부여하는 객체&lt;/li&gt;
&lt;li&gt;어드바이저 - 포인트컷 + 어드바이스(스프링 aop 용어, 단순한 애스팩트)&lt;/li&gt;
&lt;li&gt;애스팩트 - aop의 기본모듈 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;프록시 AOP 준비작업&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;자동 프록시 생성기 - DefaultAdvisorAutoProxyCreator&lt;/li&gt;
&lt;li&gt;어드바이스&lt;/li&gt;
&lt;li&gt;포인트컷&lt;/li&gt;
&lt;li&gt;어드바이저&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;트랜잭션&lt;/h2&gt;
&lt;h3&gt;전파&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PROPAGATION_REQUIRED: 진행중인 트랜잭션이 있으면 참여하고 없으면 새로 시작한다. &lt;/li&gt;
&lt;li&gt;PROPAGATION&lt;em&gt;REQUIRES&lt;/em&gt;NEW: 항상 새로운 트랜잭션 시작&lt;/li&gt;
&lt;li&gt;PROPAGATION&lt;em&gt;NOT&lt;/em&gt;SUPPORTED: 진행중인 트랜잭션에 관계없이 트랜잭션 없이 동작(aop 포인트컷 대상을 추출해내기 힘들때 모두 트랜잭션 적용 후, 따로 처리하는 방식)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;격리수준&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ISOLATION_DEFAULT: Datasource의 설정되어 있는 격리수준을 그대로 따른다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;제한시간&lt;/h3&gt;
&lt;h3&gt;읽기전용&lt;/h3&gt;
&lt;h3&gt;transactionInterceptor&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;예외처리: 스프링의 기본적인 예외처리 원칙은 비지니스적인 의미가 있는 경우에 체크예외를 사용하고, 그 외의 복구 불가능한 순수한 예외의 경우는 런타임 예외로 포장해서 전달한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;트랜잭션의 속성들을 메소드 패턴에 따라 다르게 지정할 수 있다.
스프링의 기본적인 예외처리를 따르지 않을경우에 &lt;code class=&quot;language-text&quot;&gt;transactionAttribute의 rollbackOn&lt;/code&gt;을 이용할 수 있다.&lt;/p&gt;
&lt;h3&gt;적용순서&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;포인트컷에 의해서 트랜잭션 적용 대상들을 결정한다(타입패턴이나 빈이름을 이용)&lt;/li&gt;
&lt;li&gt;상세 메소드는 transactionInterceptor의 transactionAttribute를 이용해서 트랜잭션 속성을 메소드 패턴에 맞게 결정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;@Transactional&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;@Transactional 어노테이션을 속성정보로 사용하도록 지정하면 @Transactional이 부여된 모든 오브젝트를 자동으로 타겟으로 인식한다.
이때 사용되는 포인트컷은 &lt;code class=&quot;language-text&quot;&gt;TransactionAttributeSourcePointcut&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;대체정책: 클래스 메소드 -&gt; 클래스 -&gt; 인터페이스 메소드 -&gt; 인터페이스 순으로 트랜잭션 속성을 참조한다.&lt;/li&gt;
&lt;li&gt;@Transactional의 위치는 인터페이스를 사용하는 프록시 방식의 aop가 아닌경우에, 무시될 수 있으므로 &lt;code class=&quot;language-text&quot;&gt;타겟 클래스에 적용&lt;/code&gt;할 것을 권장한다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[[boj]1914]]></title><description><![CDATA[하노이 탑 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-1914/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-1914/</guid><pubDate>Fri, 03 Jan 2020 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1914&quot;&gt;하노이 탑&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public class Boj1914 {
    int res;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        BigInteger res = BigInteger.valueOf(2).pow(n).subtract(BigInteger.ONE);
        System.out.println(res);
        if( n &amp;lt;= 20) hanoi(n,1,3);
    }

    // 문제의 조각 n개의 조각을 1-&amp;gt;3으로 옮기는 문제
    // 처음 시작하는 판의 갯수 n의 크기에 따라 재귀함수의 크기가 달라진다.
    // n = 1 1-&amp;gt;3 단순히 옮기면 됨
    // n = 2 1-&amp;gt;2, 1-&amp;gt;3 , 2-&amp;gt;3
    // n = 3 1-&amp;gt;3, 1-&amp;gt;2, 3-&amp;gt;2, 1-&amp;gt;3, 2-&amp;gt;1, 2-&amp;gt;3, 1-&amp;gt;3
    // n = 4 1-&amp;gt;2, 1-&amp;gt;3, 2-&amp;gt;3, 1-&amp;gt;2, 3-&amp;gt;1, 3-&amp;gt;2, 1-&amp;gt;2, 1-&amp;gt;3, 2-&amp;gt;3, 2-&amp;gt;1, 3-&amp;gt;1, 2-&amp;gt;3, 1-&amp;gt;2, 1-&amp;gt;3, 2-&amp;gt;3
    // n = k 일때 추상적 흐름
    // k-1개의 원반을 목적지 이외의 기둥에 옮겨놓는다.(구체적으로는 모름)
    // k 번째 원반을 목적지에 옮겨놓음
    // k-1개의 원반을 다시 목적지로 옮긴다.( 구체적으로는 모름)
    // 문제의 조각: n(원판의 갯수), st(시작점), end(목표), 순서기록여부 리턴: 횟수
    // 기저조건: n = 1 인경우 그냥 옮기면 됨
    // 문제의 조각 내에 순서를 리턴하게 되면 안됨. 20 이하일때만 리턴하도록 되있기 때문에
    // 시간 초과가 나므로 캐시를 사용해야하는데 n, st,end에 대해서 순서도를 캐시할거임
    // 1. 맥스값 오류 - long을 벗어남
    // 2. 메모리 오버 - 여러 풀이들을 보니 그냥 2^n-1 최소횟수를 리턴하도록 되있음


    public static long hanoi(int n , int st, int end ) {
        if( n == 1) {
            System.out.println(&amp;quot;&amp;quot;+st +&amp;quot; &amp;quot; + end);
//            wrapper.add(new int[]{st,end});
            return 1;
        }

        long cnt1 = hanoi(n-1, st, 6-st-end);
        long cnt2 = hanoi(1,st,end);
        long cnt3 = hanoi(n-1,6-st-end,end);

        return cnt1+cnt2+cnt3;
    }


}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]picnic]]></title><description><![CDATA[PICNIC 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-picnic/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-picnic/</guid><pubDate>Fri, 03 Jan 2020 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/PICNIC&quot;&gt;PICNIC&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.picnic;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.*;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) throws FileNotFoundException {

//        Scanner sc = new Scanner(new FileInputStream(&amp;quot;algospot/picnic/test.txt&amp;quot;));
        Scanner sc=  new Scanner(System.in);
        int tc = sc.nextInt();
        for( int i = 0; i &amp;lt; tc ; i++ ) {
            int total = sc.nextInt();
            int friend = sc.nextInt();
            int[][] friends = new int[10][10];
            for(int j = 0 ; j &amp;lt; friend ; j++) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                friends[a][b] = 1;
                friends[b][a] = 1;
            }
            System.out.println(getFriendNumber(new int[total], friends, total));

        }
    }

    // 친구 목록이 주어졌을 때의 친구들끼리 짝을 맺을 수 있는 경우의 수
    static int getFriendNumber(int[] children, int[][] friends, int remain) {
        // 짝이 다 맞으면 경우의 수 1 추가
        if( remain == 0 ) {
            return 1;
        }
        final int[] res = {0};
        // 가장 첫번째부터 짝을 맺어준다
        int first=IntStream.range(0,children.length)
                .filter(i-&amp;gt;children[i] == 0)
                .findFirst().getAsInt();
        IntStream.range(first,children.length)
                .filter(j-&amp;gt;friends[first][j] == 1 &amp;amp;&amp;amp; children[j] == 0)
                .forEach(j-&amp;gt;{
                    children[first]=1;
                    children[j]=1;

                    res[0] +=getFriendNumber(children,friends,remain-2);
                    children[first]=0;
                    children[j]=0;


                });

        return res[0];
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[boj]1074]]></title><description><![CDATA[Z 재귀호출 문제: z로 탐색할 때, n,r,c가 주어졌을 때 순서를 리턴
문제의 조각: nrc가 주어졌을때 순서를 리턴
기저조건 : n이 0인경우는 무조건 순서가 1
그 외 : 1 2 3 4 구역 나누기
1구역이라면 1구역 내에서 순서 리턴…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-1074/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-1074/</guid><pubDate>Tue, 31 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1074&quot;&gt;Z&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;문제: z로 탐색할 때, n,r,c가 주어졌을 때 순서를 리턴
문제의 조각: nrc가 주어졌을때 순서를 리턴
기저조건 : n이 0인경우는 무조건 순서가 1
그 외 : 1 2 3 4 구역 나누기
1구역이라면 1구역 내에서 순서 리턴
2구역이라면 1구역 갯수 + 2구역 내에서 순서 리턴
3구역이라면 2구역 까지 갯수 + 3구역 내에서 순서
4구역이라면 3구역 까지 갯수 + 4구역 내에서 순서&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;static int getZOrder(int n , int r , int c) {
        if( n == 0) {
            return 1;
        }
        int num = 1 &amp;lt;&amp;lt; n-1;
        //1
        if( num &amp;gt; r &amp;amp;&amp;amp; num &amp;gt; c) {
           return getZOrder(n-1, r,c);
        }
        //2
        else if( num &amp;gt; r &amp;amp;&amp;amp; num &amp;lt;= c) {
            return (num *num) + getZOrder(n-1, r, c- num);
        }
        //3
        else if( num &amp;lt;= r &amp;amp;&amp;amp; num &amp;gt; c) {
            return (num *num * 2) + getZOrder(n-1,r-num , c);
        }
        //4
        else {
            return (num *num * 3) + getZOrder(n-1, r-num, c-num);
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]boggle]]></title><description><![CDATA[BOGGLE 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-boggle/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-boggle/</guid><pubDate>Tue, 31 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/BOGGLE&quot;&gt;BOGGLE&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.boggle;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {
    static char[][] arr;
    static int[][] directions = {
            {-1,-1},
            {-1,0},
            {-1,1},
            {0,-1},
            {0,1},
            {1,-1},
            {1,0},
            {1,1}
    };
    static int[][][] cache ;
    public static void main(String[] args) throws IOException {

//        BufferedReader br = new BufferedReader((new InputStreamReader(new FileInputStream(&amp;quot;algospot/boggle/test.txt&amp;quot;))));
        BufferedReader br = new BufferedReader((new InputStreamReader(System.in)));
        int tc = Integer.valueOf(br.readLine());
        for( int i = 0 ; i &amp;lt; tc ; i++) {
            arr = new char[5][5];
            arr[0] = br.readLine().toCharArray();
            arr[1] = br.readLine().toCharArray();
            arr[2] = br.readLine().toCharArray();
            arr[3] = br.readLine().toCharArray();
            arr[4] = br.readLine().toCharArray();


            int wordNum = Integer.valueOf(br.readLine());

            for( int j = 0 ; j &amp;lt; wordNum ; j++) {
                cache = new int[5][5][10];
                String word = br.readLine();
                if( findWord(word)) {
                    System.out.println(String.format(&amp;quot;%s %s&amp;quot;,word,&amp;quot;YES&amp;quot;));
                } else {
                    System.out.println(String.format(&amp;quot;%s %s&amp;quot;,word,&amp;quot;NO&amp;quot;));
                }
            }
        }

    }

    public static boolean findWord(String word) {
        return IntStream
                .range(0,25)
                .anyMatch(i-&amp;gt;{
                    int y = i / 5;
                    int x = i % 5;
                    return findWord(y,x,word.toCharArray());
                });
    }

    public static boolean findWord(int y, int x , char[] word) {
        if( cache[y][x][word.length-1] == 1) {
            return true;
        } else if( cache[y][x][word.length-1] == -1) {
            return false;
        }
        if(word.length == 1 ) {
            return word[0] == arr[y][x];
        }

        if( word[0] == arr[y][x]) {
            boolean res = Stream.of(directions)
                    .anyMatch(i-&amp;gt;{
                        int yy = y + i[0];
                        int xx = x + i[1];
                        if( yy &amp;gt;= 0 &amp;amp;&amp;amp; yy &amp;lt; 5 &amp;amp;&amp;amp; xx &amp;gt;=0 &amp;amp;&amp;amp; xx &amp;lt; 5) return findWord(yy,xx,new String(word).substring(1).toCharArray());
                        return false;
                    });
            if(res) cache[y][x][word.length-1]= 1;
            else cache[y][x][word.length-1] = -1;
            return res;
        }

        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 2]]></title><description><![CDATA[…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring2/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;2장&lt;/h1&gt;
&lt;p&gt;테스트&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;단위 테스트를 이용해서 기존의 코드가 정상 동작하는것을 확신할 수 있고, 테스트하고자 하는 기능에 집중해 테스트 할 수 있으므로, 장애 대응이 용이하다.
단위 테스트를 이용하면 많은 수의 테스트 케이스를 일일이 수행하는 작업과 결과값을 검증하는 작업을 자동화할 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트 코드 작성&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;junit은 프레임워크이기 때문에 ioc을 이용하여 테스트를 진행한다. 그렇기 때문에 main의 테스트 함수를 junit 테스트 코드로 변경해야한다.
main 함수의 경우에는 제어권을 갖는다는 의미이기 때문이다.

테스트 메소드는 &amp;quot;pulic&amp;quot;이어야하고, &amp;quot;@Test&amp;quot; 어노테이션을 붙여야 한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트가 이끄는 개발&lt;/h2&gt;
&lt;p&gt;   테스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 실제 비지니스 로직을 수정하여 완성한다.
테스트 코드를 먼저 작성할 때에는 추가하고 싶은 기능을 코드로 표현해야 하는데,
테스트 코드의 표현은 조건, 행위, 결과로 표현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;조건: 어떤 조건을 가지고 ( 사용자 정보가 없을때)
행위: 무엇을 할 때 (존재하지 않는 id로 조회를 하면)
결과: 어떤 결과가 나온다.(exception이 발생한다.)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트 컨텍스트 관리&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;테스트 시에 공통적인 로직은 @Before 나 @After를 이용해서 각 테스트 전과 후에 수행할 수 있다.
또한 테스트는 각 메소드마다 독립성을 유지하기 위해서 새롭게 테스트객체가 생성되는데, 매번 테스트 컨텍스트를 인스턴스 변수에 두고 새로 생성하는것은 비효율적이다.
따라서, 각 테스트 메소드마다 컨텍스트를 공유하기 위해서 클래스마다 딱 한번 실행되는 @BeforeClass를 사용해 스테틱 변수에 저장하여 사용하거나, 스프링이 직접 제공하는
어플리케이션 컨텍스트 테스트 지원 기능을 사용하면 된다.

어플리케이션 컨텍스트는 @ContextConfiguration을 사용한 뒤, ApplicationContext를 주입받는 식으로 작성하면 된다.
테스트 컨텍스트는 메소드간의 공유뿐 아니라 테스트 클래스간 컨텍스트 설정이 같다면 공유도 가능하다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;DI와 테스트&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;컴포넌트 간, 인스턴스간 관계가 절대 변하지 않는 경우에는 DI를 사용하지 않아도 될까? 그렇지 않다.
DI는 구현체를 동적으로 변경할 수 있다는 장점(프록시 패턴) 외에도 직접 DI를 통해서 작은 부분만을 테스트할 수 있는 유용한 기술이다.
```
DataSource를 운영계와 테스트계를 따로 분리할 경우에,
1. @DirtiesContext를 사용하여 @Before시마다 dao의 DataSource를 직접 SingleConnectionDataSource로 DI할 수 있다.
2. 별도의 DI 설정파일을 만들어(ex: test-applicationContext.xml) @ContextConfiguration의 설정파일로 사용하여 운영계와 별도의 설정을 가지고 테스트를 실행할 수 있다.
3. 스프링의 컨테이너 없이 @Before를 이용해서 직접 dao객체를 생성하고 SingleConnectionDataSource를 생성하여 DI시켜줄 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   3가지 방법 중 우선적으로 스프링 컨테이너 없이 테스트할 수 있는 방법을 고려하고, 여러 오브젝트와 복잡한 의존관계를 갖고있는 오브젝트라면
스프링 설정을 이용한 DI방식을 고려하자
`&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;학습 테스트&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;자신이 작성하지 않은 프레임워크나, 다른 개발팀에서 만든 라이브러리 등에 대해서 테스트를 작성하여, 깊은 이해를 이끌어 내는 테스트 작성 방식이다.

 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 1]]></title><description><![CDATA[1장 관심사의 분리
모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다
문제는 변화에 따른 작업은 한곳에 집중되지 않다는 경우가 많다는 점이다. 예) db…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring1/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;1장&lt;/h1&gt;
&lt;p&gt;관심사의 분리
모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다
문제는 변화에 따른 작업은 한곳에 집중되지 않다는 경우가 많다는 점이다. 예) db 정보 변경
즉, 변화가 한 번에 한가지 관심에 집중되서 발생하기 때문에, 관심이 한군데에 집중되게 하여 작업과 영향도를 최소화&lt;/p&gt;
&lt;p&gt;관심사 분리 방법 ( db접속정보에 대한 관심사 분리) &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;중복 로직을 메소드로 추출&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 제 3자가 해당 클래스를 사용하려고 할 때, 자신들의 상황에 맞게 수정이 불가능&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;상속을 통한 확장
확장 포인트를 protected로 제공하여 상속을 통한 확장이 가능하도록 제공&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;템플릿 메소드 패턴: 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 제공하는 패턴
팩토리 메소드 패턴: 추상 메소드를 구현할 때, 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 이미 상속중인 클래스는 해당 패턴 적용 불가능, 상속을 통한 클래스 관계 밀접하기 때문에
슈퍼 클래스의 변화가 서브클래스의 변화에 영향을 주기 쉬움&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;클래스 분리
db접속정보를 생성하는 새로운 클래스 생성 후 dao에서 참조&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 제 3자가 사용할 때, db접속정보를 자신에 맞게 변경하려면 dao를 수정해야 함.
dao가 변경될 수 있는 정보를 담당하는 클래스에 대해 너무 많이 알고있기 때문에 종속적이 됨&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;인터페이스 분리
dao와 접속정보를 생성하는 인터페이스를 만들어 함께 제공&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 인터페이스의 어떤 구현체를 사용할지에 대한 관심사가 아직 생성자에 남아있어서 dao를 수정하기 전에는 자유롭지 못함.&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;클라이언트 객체로 관심 분리
dao에서 직접 구현체를 정하는 대신 클라이언트 객체에서 dao객체와 db접속정보를 생성하는 객체를 생성하여 객체간 관계를 설정해줌으로써
dao는 데이터 액세스 로직에만 집중할 수 있게됨&lt;/li&gt;
&lt;li&gt;개방 폐쇄 원칙
확장포인트는 인터페이스를 통해 개방하고, 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 하나의 관심사로 굳게 폐쇄되어 있다.&lt;/li&gt;
&lt;li&gt;높은 응집도 / 낮은 결합도
하나의 변경 사항에 수정할 부분이 많다면 그만큼 버그의 위험성이 높아진다. 인터페이스를 이용해 기능을 독립적으로 분리 시킨경우에,
해당 기능의 높은 응집력으로 변화에 대처하기 수월하다.(해당 인터페이스 구현체 교체)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;낮은 결합도는 인터페이스를 통해서 느슨한 연결을 의미한다. 느슨한 연결을 통해서 기능이 변경될 시 인터페이스 구현체를 교체함으로써,
변화에 대응하기 쉽다.&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;전략 패턴
컨텍스트 - 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 부분을 인터페이스로 확장포인트를 만든다.
보통 컨텍스트의 사용자(클라이언트)가 사용 전략을 컨텍스트에게 제공해주는 방식이 일반적이다.&lt;/li&gt;
&lt;li&gt;제어의 역전
제어권 이전을 통한 제어의 역전, 라이브러리와 프레임워크의 차이점을 통해서 제어의 역전을 확인 가능,
라이브러리를 사용하는 어플리케이션 코드는 흐름을 직접 제어하면서 필요한 기능이 있을 경우 라이브러리를 사용한다.
반면, 프레임워크의 경우 어플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크에 클래스를 등록해두고,
프레임워크가 흐름을 주도하는 중에 어플리케이션 코드를 사용하도록 만드는 방식&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어플리케이션 컨텍스트 &amp;#x26; 빈팩토리
어플리케이션 컨텍스트는 앱 전반의 기능을 통틀어 지칭하는 경우가 많고, 빈팩토리는 빈의 생성,조회 등 관리하는 측면을 지칭할 때 쓰인다.
오브젝트 팩토리를 사용하는 대신 스프링 컨테이너를 사용하면 좋은점은 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;클라이언트가 구체적인 팩토리 클래스를 알 필요가 없고,&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오브젝터 생성 및 관계설정 이외에 많은 부가기능이 있기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;싱글톤 레지스트리
스프링 컨테이너는 기본적으로 컨테이너와 주기를 함께하는 싱글톤 스코프로 단 하나의 객체만이 생성된다.    &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;객체 비교 동일성, 동등성&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;동일성 == 연산으로 동일한 객체인지 판단&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동등성 equals 연산으로 동일한 정보를 담고있는지 판단&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;의존관계 주입(DI)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;의존
a가 b를 의존한다는 것은 b가 변경되었을 때, a도 영향을 받을 수 있지만 반대의 경우는 영향을 받지 않는다. 즉 의존에는 방향이 존재한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;클래스 모델이나 코드에는 런타임 시점의 관계가 드러나지 않아야 하며, 그러기 위해서는 인터페이스를 의존해야한다.&lt;/li&gt;
&lt;li&gt;런타임 시점의 관계는 컨테이너와 같은 제 3의 존재가 구성한다.&lt;/li&gt;
&lt;li&gt;의존관계는외부에서 제공해줌으로써 구성된다.&lt;/li&gt;
&lt;li&gt;의존관계 검색(DL)
의존관계 주입과 반대로 클래스가 능동적으로 자신이 사용할 클래스를 검색한느 경우를 말한다. 예를 들어 application context의 getBean을 사용한 경우다.
의존관계 검색은 컴포넌트가 컨네이터와 같은 성격이 다른 오브젝트에 의존성을 갖게되므로 바람직하지 않다.
다만 main이나 서버환경에서 사용자의 요청을 받았을 경우에 적어도 한번은 의존관계 검색을 통해서 오브젝트를 가져와야 한다. 왜냐하면 DI를 이용해 주입받을 방법이 없기 때문이다.
또한 의존관게 검색의 경우 클라이언트는 스프링 빈일 필요가 없으나 주입의 경우에는 클라이언트와 의존오브젝트 모두 스프링 빈이어야 한다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Algo]]></title><description><![CDATA[완전탐색 재귀호출 1~n의 합을 구할때 작은 조각으로 나눠 문제해결 n만 따로 빼냄: 1~n-1 조각(재귀)와 n 조각을 연산 1만 따로 빼냄: 2~n 조각은 애초에 1~n까지의 합을 구한다는 원래의 문제와 다른 형태이므로 재귀로 사용 x…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algo/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algo/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;완전탐색&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;p&gt;1~n의 합을 구할때 작은 조각으로 나눠 문제해결&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n만 따로 빼냄: 1~n-1 조각(재귀)와 n 조각을 연산&lt;/li&gt;
&lt;li&gt;1만 따로 빼냄: 2~n 조각은 애초에 1~n까지의 합을 구한다는 원래의 문제와 다른 형태이므로 재귀로 사용 x
&lt;strong&gt;기저사례&lt;/strong&gt;: 더이상 쪼개지지 않는 최소한의 작업 (존재하는 모든 입력이 항상 &lt;strong&gt;기저사례&lt;/strong&gt;의 답을 이용할 수 있어야한다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;접근방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;최대 입력의 크기를 가늠하여 시간안에 도출할 수 있는지 예상&lt;/li&gt;
&lt;li&gt;가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈 뒤, 각 선택은 답의 후보를 만드는 과정의 한조각이 된다.&lt;/li&gt;
&lt;li&gt;한 조각을 택해 답의 일부를 만들고, 나머지는 답을 재귀호출을 통해 완성&lt;/li&gt;
&lt;li&gt;조각이 하나 이하로 남은 경우에 답을 생성했으므로, 이것을 기저사례로 선택해 처리&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;이론적 배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문제와 부분문제의 정의&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;문제: 주어진 자연수 정렬&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;문제: {4,2,50,2} 정렬&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;둘은 다른문제임. 전자는 입력을 정의하지 않은 반면, 후자는 특정한 입력을 지정하였기 때문&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;문제란 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 뜻한다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 5]]></title><description><![CDATA[서비스 추상화 조건 유저에 등급을 추가하고, 등급 업 조건을 설정 등급은 금, 은, 동 등금 동->은 로그인 50회 등급 은->금 추천 3…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring5/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring5/</guid><pubDate>Thu, 26 Dec 2019 16:00:39 GMT</pubDate><content:encoded>&lt;h1&gt;서비스 추상화&lt;/h1&gt;
&lt;h2&gt;조건&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;유저에 등급을 추가하고, 등급 업 조건을 설정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;등급은 금, 은, 동&lt;/li&gt;
&lt;li&gt;등금 동-&gt;은 로그인 50회&lt;/li&gt;
&lt;li&gt;등급 은-&gt;금 추천 30회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고려해야할 점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중복된 부분 유무&lt;/li&gt;
&lt;li&gt;코드를 이해하기 쉬운지&lt;/li&gt;
&lt;li&gt;코드의 위치가 적합한지&lt;/li&gt;
&lt;li&gt;앞으로 변경이 일어난다면 어떤것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있는지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if/else if/else 블록: 레벨의 변화단계, 업그레이드 조건, 조건이 충족되었을 때 작업이 섞여있어서 이해하기 쉽지않음&lt;/li&gt;
&lt;li&gt;레벨이 늘어난다면?: if 블록 갯수 증가, level enum 수정,&lt;/li&gt;
&lt;li&gt;레벨 업 작업이 복잡해진다면?: 등급 업하는 service 메소드가 길어지고 복잡해짐(이해하기 힘들어짐)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if 조건문이 현재 레벨과 레벨 업 조건을 동시에 비교하는 부분?: 레벨이 동이면서 로그인이 49인 유저와 새로운 레벨의 유저가 else블록에서 함께 처리됨&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;즉 상당히 변화에 취약하고 다루기 힘든 코드, 문제점이 무엇인지 파악하는것조차 힘듦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리팩토링&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;추상적인 흐름에서부터 로직 작성: 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 썩여있음.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function upgrade() {
list users;
foreach users 
    canlevelup? upgrade : nothing
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;canlevelup? &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function canlevelup(user) {
level = userlevel
level is basic login &amp;gt;= 50
level is silver recommend &amp;gt;= 30
other false
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;upgrade&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function upgrad(user) {
level = userlevel
user.level = level.nextLevel
update user
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기능의 분리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;레벨을 업그레이드하는 정책을 유연하게 변경할 수 있도록 개선(전략패턴)&lt;/li&gt;
&lt;li&gt;userService에서 레벨 업그레이드 정책을 분리한다. (interface를 통해 분리 후 di로 주입)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;객체지향적 코드&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;다른 오브젝트의 데이터를 가져와서 작업하는 대신, 데이터를 갖고있는 오브젝트에게 작업을 해달라고 요청한다.&lt;/strong&gt;
기존: userService가 user의 레벨을 가져와 조건을 판단하여 level수정
변경: userService가 user에게 레벨 수정요청, user가 level에게 다음level 요청&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션
jdbc의 트랜잭션은 하나의 connection을 사용하다가 닫는 사이에 일어난다. jdbc의 기본 설정은 db작업을 수행한 직후에 자동으로 커밋이 되도록 되어있으므로(따라서 작업마다 커밋해서 트랜잭션을 끝내버린다), 이 설정을 끔으로써 시작을 설정하고 commit이나 rollback으로 끝을 설정한다.(트랜잭션 경계설정)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;중요한 점은 트랜잭션은 하나의 connection으로부터 사용하는것이므로 트랜잭션의 경계는 하나의 connection이 만들어지고 닫히는 범위 내에 존재해야한다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;.&quot;&gt;&lt;pre class=&quot;language-.&quot;&gt;&lt;code class=&quot;language-.&quot;&gt;connection = datasource.getConnection() // connection 생성 
connection.setAutoCommit(false) // 트랜잭션 시작 설정
connection.commit() or rollback() // 트랜잭션 끝 설정
connection.close()                // connection close &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 서비스에서 트랜잭션 경계를 위의 방법으로 설정하기 위해서는 다음과 같은 문제점이 따른다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdbc api를 사용해 순수 비지니스로직만을 담아내지 못하고&lt;/li&gt;
&lt;li&gt;dao메소드와 service메소드에 connection 파라미터가 추가된다.(경계설정한 connection을 공유하기 위해서)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dao interface에 connection 파라미터가 들어간다는것은 데이터 액세스 기술에 종속적이라는 의미이다(jpa나 하이버네이트 구현방식 변경하려면 interface부터 모두 변경해야한다.)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;트랜잭션의 종류&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;로컬 트랜잭션: jdbc의 connection을 이용한 트랜잭션 방식 (하나의 connection에 종속적이다)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글로벌 트랜잭션: 여러 db에 대한 작업을 하나의 트랜잭션으로 묶을때 사용하는 방식(트랜잭션매니저 이용)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;트랜잭션 동기화 방식을(jdbc connection을 이용한) 통해 트랜잭션 경계를 구성할 수 있지만 다음과 같은 문제점이 따른다. &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;jdbc api connection을 이용한 방식이기 때문에 글로벌 트랜잭션 적용이 불가능하다( 적용하려면 service 로직 수정)&lt;/li&gt;
&lt;li&gt;jPA나 hibernate의 경우에 독자적인 트랜잭션 관리 api를 사용하므로 적용이 불가능하다( 적용하려면 service 로직 수정)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;즉 기술환경에 종속적인 코드가 된다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스 추상화&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 서비스 추상화란 트랜잭션과 같이 기능은 유사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 인터페이스와 일관성 있는 접근 방법을 제공해주는 것이나 JavaMail 처럼 테스트를 어렵게 만드는 api를 사용할 때도 적용이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Session]]></title><description><![CDATA[Session 최근 세션 관련한 이슈를 해결하면서 관련된 내용을 정리한다. 클라이언트에서 서비스를 이용하는데 간헐적으로 session is already invalidated…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/session/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/session/</guid><pubDate>Thu, 26 Dec 2019 12:59:42 GMT</pubDate><content:encoded>&lt;h1&gt;Session&lt;/h1&gt;
&lt;p&gt;최근 세션 관련한 이슈를 해결하면서 관련된 내용을 정리한다.&lt;/p&gt;
&lt;p&gt;클라이언트에서 서비스를 이용하는데 간헐적으로 session is already invalidated 라는 에러 메세지를 뱉는것이다.
해당 로그를 찾아보니 클라이언트에서 무슨 이유인지는 모르나 동시다발적으로 한번에 4개의 동일한 요청을 날리는 것을 볼 수 있었다.&lt;/p&gt;
&lt;p&gt;기존 리소스서버 공통 인증로직에서는 세션의 유무를 체크한 뒤, 유효한 세션이 아니라면 session.invalidate() 이후 새로운 세션을 새로 생성하는 방식으로 작동하고 있었지만, 동시에 4개의 동일한 요청이 들어왔을 경우 동시성의 문제로 request.getSession(false)가 2개의 요청에 대해서 세션을 리턴해준 뒤, 순차적으로 해당 세션을 invalidate()를 시켰고, 당연히 첫번째 스레드에 의해 invalidate된 세션은 두번째 스레드에 의한 invalidate 호출에 의해서 에러가 발생했던 것이다.&lt;/p&gt;
&lt;p&gt;해당 부분은 SecurityContext를 위해서 세션을 체크하는것이므로, 세션 invalidate 대신, SecurityContextHolder.clearContext()로 수정하였다.&lt;/p&gt;
&lt;h2&gt;구조&lt;/h2&gt;
&lt;p&gt;SecurityContextPersistenceFilter: SecurityContextRepository를 이용해서 SecurityContext를 요청시에 load하거나 save한다.
SecurityContextRepository: Security를 저장하는 역할을 담당한다. sessionCreationPolicy에 따라 해당 전략을 변경한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sessionCreationPolicy 가 stateless일 경우 - NullSecurityContextRepository&lt;/li&gt;
&lt;li&gt;그외 HttpSessionSecurityContextRepository를 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;추상적 흐름(Security context)&lt;/h2&gt;
&lt;p&gt;SecurityContextPersistenceFilter -&gt; SecurityContext 작업 -&gt; SessionManagementFilter&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;요청에 대한 Seucrity Context를 로드한다.&lt;/li&gt;
&lt;li&gt;인증을 통해서 Context를 작업한다.&lt;/li&gt;
&lt;li&gt;해당 요청에 Security Context가 존재하지 않는다면 세션인증전략을 진행하고 Security를 저장한다.&lt;/li&gt;
&lt;li&gt;3.에서 요청에 context가 존재하여 진행되지 않았다면 해당 context를 다음 요청을 위해 저장한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;참조&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/spring-security-session&quot;&gt;baeldung&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Links]]></title><description><![CDATA[links markdown markdown markdown2 github action github action & typescript intellij working directory opencv 딥러닝과 OpenCV…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/links/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/links/</guid><pubDate>Thu, 26 Dec 2019 12:59:42 GMT</pubDate><content:encoded>&lt;h1&gt;links&lt;/h1&gt;
&lt;h2&gt;markdown&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://guides.github.com/features/mastering-markdown/&quot;&gt;markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wikidocs.net/1678&quot;&gt;markdown2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;github action&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ahnheejong.name/articles/receive-new-room-notification-mails-using-github-action/&quot;&gt;github action &amp;#x26; typescript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;intellij&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/19838334/what-is-a-working-directory-in-intellij-idea&quot;&gt;working directory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;opencv&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/8344782?refer=%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%8A%A4%EB%9F%BD%EB%8B%A4&quot;&gt;딥러닝과 OpenCV를 활용해 사진 속 글자 검출하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tensorflow.blog/tag/fast-r-cnn/&quot;&gt;텐서플로우 블로그&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@nikolasmoya/simple-algorithm-to-remove-moving-objects-from-pictures-cdd3396c68e0&quot;&gt;객체 지우기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/cf84/81b766802ac98f0ce5396af3daac52c03b56.pdf&quot;&gt;Removing Unwanted Objects from an Image using Image in-painting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stanford.edu/class/ee367/Winter2018/li_li_ee367_win18_report.pdf&quot;&gt;Removal of Background People Using Object Detection and Inpainting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ijariie.com/AdminUploadPdf/REMOVING_UNWANTED_OBJECTS_FROM_AN_IMAGE_USING_IMAGE_INPAINTING_ijariie1330_volume_1_14_page_443_447.pdf&quot;&gt;REMOVING UNWANTED OBJECTS FROM AN IMAGE USING IMAGE INPAINTING&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S1047320315000541&quot;&gt;An efficient forgery detection algorithm for object removal by exemplar-based image inpainting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.bmva.org/bmvc/2017/papers/paper080/paper080.pdf&quot;&gt;General Deep Image Completion with Lightweight Conditional Generative Adversarial Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gfx.cs.princeton.edu/pubs/Barnes_2009_PAR/&quot;&gt;PatchMatch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.wisdom.weizmann.ac.il/~vision/VideoCompletion/SpaceTimeCompletion.pdf&quot;&gt;space-time-completion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.purdue.edu/homes/aliaga/cs535-14/lec-image-resizing.pdf&quot;&gt;image-resizing-retargeting&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;python&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wikidocs.net/book/1553&quot;&gt;wikidocs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;tip&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1859072/python-continuing-to-next-iteration-in-outer-loop&quot;&gt;continueLabel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 4]]></title><description><![CDATA[예외 예외의 핵심원칙 모든 예외는 적절하게 복구되던지, 작업을 중단하고 운영자 혹은 개발자에게 통보되야 한다. 예외 종류 체크예외: RuntimeException을 상속받지 않는 Exception 언체크예외: RuntimeException…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring4/</guid><pubDate>Fri, 20 Dec 2019 18:19:01 GMT</pubDate><content:encoded>&lt;h2&gt;예외&lt;/h2&gt;
&lt;h3&gt;예외의 핵심원칙&lt;/h3&gt;
&lt;p&gt;모든 예외는 적절하게 복구되던지, 작업을 중단하고 운영자 혹은 개발자에게 통보되야 한다.&lt;/p&gt;
&lt;h3&gt;예외 종류&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;체크예외: RuntimeException을 상속받지 않는 Exception&lt;/li&gt;
&lt;li&gt;언체크예외: RuntimeException을 상속받은 Exception&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;예외 처리방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;복구 - 예외상황을 알맞게 처리한다.&lt;/li&gt;
&lt;li&gt;회피 - 예외를 처리하지 않고 호출한 메소드로 예외를 던진다.&lt;/li&gt;
&lt;li&gt;전환 - 예외 상황을 명확하게 표현할 수 있는 예외형식으로 전환하거나, 체크 예외를 언체크 예외로 변경하는(의미없는 try catch구문 남발 방지) 경우 전환하여 예외를 던진다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;예외처리 전략&lt;/h3&gt;
&lt;p&gt;일반적으로 체크예외는 일반적인 예외, 언체크 예외는 시스템 장애나 프로그램상 오류이다.
초기의 자바가 독립형 앱을 구성할 때에는 작업이 중단되지 않게 상황을 복구 시켜줘야만 했다. (예: 파일 열기 시 파일을 찾을 수 없는경우)
그러나 서버환경에서는 각 요청이 독립적인 작업으로 취급되므로, 예외 발생 시 작업을 중지하고 사용자와 소통하여 복구할 수 있는 방법이 없다.&lt;/p&gt;
&lt;p&gt;스프링은 DataAccessException을 통해서 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다. Dao를 데이터 액세스 기술에서 독립 시키려면 인터페이스 도입과 런타임 예외 전환(jdbcTemplate), 기술에 독립적인 추상화된 예외로 전환이 필요하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 3]]></title><description><![CDATA[템플릿 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙은(OCP…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring3/</guid><pubDate>Mon, 16 Dec 2019 17:30:23 GMT</pubDate><content:encoded>&lt;h2&gt;템플릿&lt;/h2&gt;
&lt;p&gt;객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙은(OCP) 변하는 시점이 다른 부분을 독립적으로 변경될 수 있도록 분리하여 효율적인 구조를 만든다.
템플릿은 이러한 원칙을 활용한 예로써, 변경이 거의 일어나지 않는 부분을 변경이 잦은 부분과 독립시켜 효과적으로 활용하는 방법이다.&lt;/p&gt;
&lt;h3&gt;jdbc&lt;/h3&gt;
&lt;p&gt;jdbc는 보통 Connection과 PreparedStatement라는 공유 리소스를 사용하는데, 요청이 많은 서버환경에서 매번 리소스를 생성하는 대신,
풀 방식으로 미리 일정 갯수의 리소스를 만들어두고 필요할 때마다 할당 및 반환하는 구조이다.&lt;/p&gt;
&lt;p&gt;따라서 jdbc 이용시에는 항상 예외처리를 포함하여야 로직을 수행하면서 에러 발생 시, 공유 리소스를 반환할 수 있다. 반환되지 못한 공유리소스가 쌓이게 되면 리소스 부족으로 서버가 중단될 수 있는 위험이 있기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Connection&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; datasource&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;PreparedStatement&lt;/span&gt; ps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;prepareStatement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sql&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        c&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jdbc를 이용하는 dao의 경우에 위와 같은 예외처리는 항상 중복되어 발생한다. 따라서 아래와 같이 코드의 관심사를 분리시킬 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;변하지 않지만 많은 곳에서 중복되는 코드 - 예외처리 및 Connection&lt;/li&gt;
&lt;li&gt;로직에 따라서 자주 변하는 코드 - preparedStatement (로직마다 쿼리가 달라지므로..)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;코드 분리방법&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;메소드 추출 - 변하는 부분을 메소드로 추출 ( 위의 경우에 변하지 않는 부분이 변하는 부분을 감싸서 추출하기 어려우므로 반대로 추출)&lt;/li&gt;
&lt;li&gt;그러나 변하는 부분은 dao 로직마다 새롭게 만들어야 하는 부분이므로 효과가 없어보인다.&lt;/li&gt;
&lt;li&gt;템플릿 메소드 패턴 - 상속을 통해서 기능확장을 시도한다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분을 추상 메소드로 확장포인트를 제공한다.&lt;/li&gt;
&lt;li&gt;관심사는 분리가 되었지만, dao의 로직 갯수만큼 서브클래스를 만들어서 사용해야 한다. (delete, add, update 등..)&lt;/li&gt;
&lt;li&gt;전략 패턴 - 개방 폐쇄 원칙을 잘 지키면서도, 템플릿 메소드 패턴보다 확장성이 뛰어난 패턴&lt;/li&gt;
&lt;li&gt;확장에 해당하는 부분을 별도의 클래스로 만들어서 인터페이스를 통해 위임하는 방식&lt;/li&gt;
&lt;li&gt;일정한 구조(예외처리)로 동작하다가 특정 확장기능(서비스로직 쿼리)을 수행할 때, 인터페이스를 통해 외부 전략 클래스에 위임&lt;/li&gt;
&lt;li&gt;DI를 이용한 클라이언트 / 컨텍스트 분리&lt;/li&gt;
&lt;li&gt;단순히 전략패턴만을 사용해서는 컨텍스트에서 직접 구현 클래스를 의존하게되어 좋지 않다&lt;/li&gt;
&lt;li&gt;클라이언트가 관계설정의 책임을 가지고 전략을 선택 및 생성하여 컨텍스트에 전달하는 역할을 맡는다.(object Factory)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또 나타난 문제점: 클라이언트(전략패턴 선택)와 컨텍스트(전략패턴 이용)를 분리하였지만 문제는&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;4.1 각 메소드마다 전략패턴 구현체를 각각 만들어줘야해서 클래스 파일의 갯수가 늘어난다. 예) add, update ,delete -&amp;gt; addStatement, updateStatement, deleteStatment (statement 생성전략 구현체)
4.2 전략 객체에 전달할 부가정보를 위한 생성자 및 인스턴스 변수를 번거롭게 만들어야 한다. &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 해결법: 각 메소드 안에 사용하는 전략 클래스를 로컬클래스로 정의한 뒤 사용하기. (클래스 파일 갯수도 줄고, 자신의 선언된 곳의 컨텍스트에 접근 가능)
익명 내부 함수를 사용하면 더 간결한 코드 가능&lt;/p&gt;
&lt;p&gt; 중첩클래스: 스태틱 클래스, 내부 클래스 (멤버클래스, 로컬클래스(메소드 레벨 정의, 로컬변수와 비슷한 개념), 익명 클래스)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;5. 클래스 분리
- 보통의 경우에는 인터페이스를 사이에 두고 분리를 하지만, userDao와 jdbcContext와 같은 긴밀한 관계를 갖는 경우에 간혹 인터페이스를 사용하지 않고 관계를 형성하기도 한다.
`jdbcContext는 그 자체로 JDBC 컨텍스트를 제공해주는 서비스 객체로서 의미가 있을 뿐, 구현 방법이 바뀔 가능성은 없다.`
- jdbc의 일반적인 작업흐름을 담고있는 부분은 다른 dao에서도 사용이 가능하기 때문에 클래스를 분리하여 컨텍스트를 DI 받을 수 있게끔 수정할 수 있다.
5.1 jdbc context를 스프링을 통해 DI받기
   - 싱글톤으로 관리가 가능하며, datasource와 같은 다른 스프링 빈을 주입받을 수 있다.
5.2 클라이언트(userDao)에게 DI받기
   - 스프링을 이용하지 않는다면, 직접 context를 사용하는 클라이언트에게 생성과 초기화를 위임한다.
   - datasource같은 스프링 빈을 주입받기 위해서 스프링 빈인 클라이언트(userDao)에게 DI까지 위임한다.
   - 클라이언트(userDao)와 datasource만 스프링 빈으로 등록한 뒤, 스프링을 이용해 userDao의 수정자 메소드를 통해서 datasource를 주입한뒤, 수정자 메소드 내부에서 jdbcContext를 생성하여 직접 datasource를 jdbcContext에 주입시킨다.

6. 템플릿 / 콜백 패턴
 - 전략패턴 : 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름(컨텍스트)에 그 일부분(전략)만 자주 바뀌는 경우
 - 전략패턴 + 익명 내부클래스 = 템플릿 / 콜백 패턴
 - 전략패턴의 컨텍스트(일정한 작업흐름) =&amp;gt; 템플릿, 익명 내부클래스 =&amp;gt; 콜백
 - 콜백은 보통 단일 메소드 인터페이스를 사용, 컨텍스트(템플릿)에서 여러 종류의 전략을 사용해야 한다면 한개 이상의 콜백 오브젝트를 사용할 수 있음
 - 콜백 메소드에는 대개 컨텍스트의 작업(작업 흐름)중 만들어지는 컨텍스트 정보를 전달받을 파라미터가 존재한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;작업 흐름도
1. 클라이언트 역할: 콜백 객체를 만들고, 콜백이 참조할 정보를 제공하는 역할, 템플릿을 호출할때 콜백 전달
2. 템플릿 역할: 내부 작업을 진행하다가 생성된 참조정보를 가지고 콜백객체의 메소드 호출
3. 콜백 역할: 클라이언트 메소드 정보와, 템플릿이 제공하는 참조정보를 이용해 작업 수행 후, 템플릿에게 결과 리턴
4. 템플릿 역할: 콜백의 결과를 사용해 작업 마저 수행, 경우에 따라서 최종결과를 클라이언트에게 다시 돌려줄 수도 있음&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 일반적인 DI와 다르게 매번 메소드를 호출할 때마다 콜백 오브젝트를 새로 전달 받음
- 콜백 객체는 익명 내부클래스로써, 자신을 생성한 클라이언트 내부 메소드 정보를 직접 참조한다는 것이 특징( 클라이언트와 콜백간의 강한결합)
- __변하는 것과 변하지 않는것을 분리하고 변하지 않는건 유연하게 재활용할 수 있게 만든다__
- 변하지 않는것을 메소드로 추출, 여러 클래스에서 사용하고 싶다면 클래스를 분리하여 메소드로 추출

7. 템플릿 / 콜백 패턴 적용 예시
  ```
  템플릿 / 콜백 패턴에서 가장 중요한 점은 템플릿과 콜백의 경계를 정하고 전달 내용들을 파악하는게 중요하다. (인터페이스를 정의하기 위함)
      1. 템플릿이 콜백에게 전달해 줄 참조 정보는 무엇인지
      2. 콜백이 템플릿에게 돌려줄 내용
      3. 템플릿이 작업을 마친 뒤 클라이언트에게 돌려줄 내용
  ```
  7.1 숫자 합 구하는 계산기 작성
  7.2 템플릿/콜백 패턴 적용
      7.2.1 템플릿-&amp;gt;콜백 (파일 컨텍스트 정보인 BufferedReader)
      7.2.2 콜백-&amp;gt;템플릿 (컨텍스트 내용의 연산결과 Integer)
      7.2.3 템플릿-&amp;gt;클라이언트 (콜백의 연산결과 전달 Integer)
  7.3 다양한 타입을 원한다면 제네릭 사용
  
8. jdbcTemplate
  jdbcTemplate은 내부적으로 템플릿/콜백 패턴을 사용하는 좋은예이다. 
  - update
  - query
  - queryForObject ... 
  ```
  __생각해볼 수 있는 확장포인트__
  예) 유저테이블
  query를 UserRowMapper와 사용할 수 있는데, UserRowMapper를 빈으로 등록시켜서 DI를 이용하고, 
  User 테이블 필드명과 User 오브젝트 프로퍼티의 매핑정보를 XML이나 기타 외부환경에 작성( 테이블 필드명, 매핑방식이 바뀌어도 userDao코드 수정 x)
  
  dao에서 sql 문장을 외부 리소스에서 읽어와 사용(db 테이블 스키마 변경이나, sql 변경 시 코드 수정 x)
  ```
  jdbcTemplate 외에도 클래스가 Template으로 끝나거나, 인터페이스 이름이 Callback인 경우 템플릿/콜백 패턴이 적용된 경우이다.


  

  
  


  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item></channel></rss>