<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsby-starter-blog-demo.netlify.com</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 13 Jan 2020 17:49:44 GMT</lastBuildDate><item><title><![CDATA[[gcj2019-qr3]Cryptopangrams]]></title><description><![CDATA[Cryptopangrams gcd(최대 공약수) 이 문제를 해결하는데 엄청나게 시간을 낭비했다. 풀이 1: 인접한 두 수의 최대 공약수 구하기(a * b = c, b * d = e 일때 c,e 의 최대 공약수는 b이다.) 접근…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr3/</guid><pubDate>Mon, 13 Jan 2020 17:32:51 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/000000000008830b&quot;&gt;Cryptopangrams&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;gcd(최대 공약수)&lt;/h2&gt;
&lt;p&gt;이 문제를 해결하는데 엄청나게 시간을 낭비했다.&lt;/p&gt;
&lt;p&gt;풀이 1: 인접한 두 수의 최대 공약수 구하기(a * b = c, b * d = e 일때 c,e 의 최대 공약수는 b이다.)&lt;/p&gt;
&lt;p&gt;접근 1으로 풀었을 때, 이 문제의 함정을 조심해야한다.&lt;/p&gt;
&lt;p&gt;접근 2: 풀이 1로만 접근했을 때에는 ABABABB 와 BABABAA 를 판별하지 못한다. 왜냐하면 AB와 BA의 최대 공약수는 자기자신 AB이기 때문이다.
즉, 최대공약수를 통해서 소수를 유추해내려면 적어도 2쌍의 다른 소수의 곱이 필요하다 (예: AB BC =&gt; gcd = B로 유추가능, AB BA =&gt; gcd AB 유추 불가능)&lt;/p&gt;
&lt;p&gt;접근 3: 접근 2까지 했으나 visible set은 통과하나 hidden set은 통과를 못함. 결국 유투브에서 원인을 찾아낼 수 있었음
소수의 크기가 10^100이기때문에 BigInteger를 사용해야만 했는데 시스템 입력에서 읽어올때 &lt;strong&gt;BigInteger.valueOf(sc.nextInt())&lt;/strong&gt; 식으로 읽어오고 있던걸 &lt;strong&gt;sc.nextBigInteger()&lt;/strong&gt;로 읽어오니까 통과함 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package codejam.qr2019.q3;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.*;

public class Solution {

    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int tc = sc.nextInt();
        sc.nextLine();
        for( int i = 0 ; i &amp;lt; tc ; i++ ) {
            SortedSet&amp;lt;BigInteger&amp;gt; primes = new TreeSet&amp;lt;&amp;gt;();
            BigInteger n = sc.nextBigInteger();
            int l = sc.nextInt();
            List&amp;lt;BigInteger&amp;gt; input = new ArrayList&amp;lt;&amp;gt;();
            List&amp;lt;BigInteger&amp;gt; primesOrder = new ArrayList&amp;lt;&amp;gt;();
            BigInteger prev = sc.nextBigInteger();
            int idx = 0;
            for( int j = 1 ; j &amp;lt; l; j++) {
                BigInteger number = sc.nextBigInteger();
                BigInteger prevNumber =prev;
                if( prevNumber.compareTo(number) != 0 ) {
                    BigInteger prime = gcd(number, prevNumber);
                    if( j % 2 != 0) {
                        //BABAA ABABB
                        //BAC
                        // AAAAB
                        BigInteger other = prevNumber.divide(prime);
                        for( int k = 0 ; k &amp;lt;= j ; k++) {
                            primesOrder.add(k %2 == 0 ? other: prime);
                        }
                        primesOrder.add(number.divide(prime));
                    } else {
                        //ABABAA
                        BigInteger other = prevNumber.divide(prime);
                        for( int k = 0 ; k &amp;lt;= j ; k++) {
                            primesOrder.add(k %2 == 0 ? prime: other);
                        }
                        primesOrder.add(number.divide(prime));
                    }
                    idx = j;
                    break;
                }
            }
            for( int j = idx+1; j &amp;lt; l ; j++) {
                // 12 23 34 ..  end-1 end
                BigInteger num = sc.nextBigInteger();
                BigInteger prevNum = primesOrder.get(primesOrder.size()-1);
                BigInteger number = num.divide(prevNum);
                primesOrder.add(number);
            }
//            primesOrder.add(input.get(input.size()-1).divide(primesOrder.get(primesOrder.size()-1)));
            primes.addAll(primesOrder);

//            Assert.check(primes.size() == 26);
//            Assert.check(primes.first().compareTo(primes.last()) &amp;lt; 0);

            Iterator&amp;lt;BigInteger&amp;gt; it = primes.iterator();
            Map&amp;lt;BigInteger, Integer&amp;gt; mapping = new HashMap&amp;lt;&amp;gt;();
            int cnt = 0 ;
            while(it.hasNext()) {
                mapping.put(it.next(), cnt++);
            }
            char[] alphabet = &amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot;.toCharArray();
            System.out.print(String.format(&amp;quot;Case #%d: &amp;quot;,i+1));
            for( BigInteger p : primesOrder) {
                System.out.print(alphabet[mapping.get(p)]);
            }
            System.out.println(&amp;quot;&amp;quot;);

        }


    }

    public static BigInteger gcd(BigInteger a , BigInteger b) {
        if( a.compareTo(b) &amp;lt; 0) {
            BigInteger tmp = a;
            a = b;
            b = tmp;
        }
        while(b.compareTo(BigInteger.ZERO) != 0) {
            BigInteger r = a.mod(b);
            a = b;
            b = r;
        }
        return a;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 7]]></title><description><![CDATA[스프링 기술 응용 SQL 분리 기존의 Dao를 인터페이스로 구현하여 데이터 액세스 기술에 독립적으로 변경할 수 있게 되었다. 그러나 테이블의 정보를 담고있는 sql이 변경된다면,
dao의 변경은 sql에 독립적인 dao를 만들기 위해서 sql…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring7/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring7/</guid><pubDate>Sun, 12 Jan 2020 17:18:17 GMT</pubDate><content:encoded>&lt;h1&gt;스프링 기술 응용&lt;/h1&gt;
&lt;h2&gt;SQL 분리&lt;/h2&gt;
&lt;p&gt;기존의 Dao를 인터페이스로 구현하여 데이터 액세스 기술에 독립적으로 변경할 수 있게 되었다. 그러나 테이블의 정보를 담고있는 sql이 변경된다면,
dao의 변경은 sql에 독립적인 dao를 만들기 위해서 sql을 분리시켜보자. sql을 분리시키기 위해서는 변하는 작업과 변하지 않는 작업을 구분한다.
변하는 작업은 기존 dao의 데이터 액세스 로직이고, 변하는 로직은 sql이다. 즉 변하는 부분을 스프링 컨테이너를 통해서 DI받도록 수정해본다. &lt;/p&gt;
&lt;p&gt;문제점: dao가 sql에 의존적이기 때문에 sql이 변경될 시(생각보다 잦음), dao를 함께 수정해줘야 함
해결: sql을 DI받는다. &lt;/p&gt;
&lt;p&gt;문제점: sql이 새로 추가될때마다, 새로운 프로퍼티 추가 및 수정메소드를 만드는 변경이 뒤 따른다.
해결: sql을 콜렉션 형태로 DI받는다.&lt;/p&gt;
&lt;p&gt;문제점: sql과 DI 설정정보가 섞여있으면 관리하기에 좋지 않을뿐더러, sql을 꼭 빈 설정정보에(xml)뿐 아니라, 별도의 파일이나, db, 원격서버에서 sql을 읽어올 수 있도록 확장이 불가능하다. 또한 스프링 설정파일로부터 주입받는 정보들은 어플리케이션을 다시 시작하기 전까지는 변경이 어렵다.
해결: sql을 제공받을 수 있는 기능을 확장이 용이하도록, dao에 sql을 제공해주는 기능을 독립 시킨다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sql 제공 인터페이스 input: sql key / output: sql
ß&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[[boj]9663]]></title><description><![CDATA[boj9663 backtracking]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-9663/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-9663/</guid><pubDate>Sun, 12 Jan 2020 08:53:22 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/6603&quot;&gt;boj9663&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;backtracking&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package boj;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.stream.IntStream;

import static java.lang.Math.abs;

public class Boj9663 {
    boolean[][] board;
    static boolean[] x;
    static boolean[] ru;
    static boolean[] rd;
    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int n = sc.nextInt();
        x = new boolean[14];
        ru = new boolean[27];
        rd = new boolean[27];
        System.out.println(putQueen(n,0,n, new boolean[n][n], new ArrayList&amp;lt;&amp;gt;()));
    }

    //backtracking
    //input: n, st-index, board
    //output: int
    public static int putQueen(int n, int cur, int remain, boolean[][] board, List&amp;lt;Integer&amp;gt; queens) {
        if( cur &amp;gt;= n &amp;amp;&amp;amp; remain &amp;gt; 0) {
            return 0;
        } else if( cur &amp;gt;= n ) {
            return 1;
        }
       // can put?
        int res = 0;
        for( int i = 0; i &amp;lt; n ; i++) {
            if( canPut(cur , i , board, queens)) {
                x[i] = ru[cur+i] = rd[cur-i+board.length-1] = true;
                res += putQueen(n,cur+1, remain-1, board, queens);
                x[i] = ru[cur+i] = rd[cur-i+board.length-1] = false;
            }
        }
        return res;

    }

    private static boolean canPut(int y, int xx, boolean[][] board, List&amp;lt;Integer&amp;gt; queens) {
        return !x[xx] &amp;amp;&amp;amp; !ru[y+xx] &amp;amp;&amp;amp; !rd[y-xx+board.length-1];
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[gcj2019-qr2]Foregone Solution]]></title><description><![CDATA[qr2019-2 backtracking]]></description><link>https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr2/</guid><pubDate>Sun, 12 Jan 2020 08:53:22 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da&quot;&gt;qr2019-2&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;backtracking&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package codejam.qr2019.q2;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.util.Scanner;

/**
 * https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da
 * 거꾸로 올라가는방식은?
 * 일단 첫번째와 끝은 이미 정해져있음
 * 만날때에는 서로 다른방향으로 가야하기 때문에 방향이 강제됨
 * n칸이라고할때 n을 두가지 방향으로 어떻게 배치할것인가 S n-1번 E n-1번 움직여야함
 * 상대가 s로 n-1번움직였다면 아래에있으면 안됨 즉 s를 다쓰면 안됨
 * 상대가 s를 n-1번쓸때까지 s를 남겨두려면 s를 쓸때 e를 쓰면됨?
 * 반대방향으로 갈경우 겹치지 않는 이유는 반대의 경우를 가정하고 생각한다.
 * (가정)반대방향으로만 갔을경우에 어느순간 상대방과 같은 방향으로 이동한다.
 * 어느지점에서 마주쳤다고 가정했을경우 상대방과 나는 (결과론적으로) 같은 수의 동쪽과 같은수의 남쪽을 사용했을 경우이다.
 * 그 경우에 다음 이동방향은 상대방과 무조건 반대이므로 겹치지 않게된다.
 */
public class Solution {
    public static void main(String[] args) throws FileNotFoundException {
//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(&amp;quot;codejam/qr2019/q2/input.txt&amp;quot;))));
        int tc = sc.nextInt();
        backtracking(sc, tc);
    }

    private static void inverseDirection(Scanner sc, int tc) {
        for(int i =0 ; i &amp;lt; tc ; i++) {
            int n = sc.nextInt();
            sc.nextLine();
            String move = sc.nextLine();
            char[] newMove = new char[move.length()];
            int j = 0;
            for( char a : move.toCharArray()) {
                if( a == &amp;#39;S&amp;#39;) newMove[j++] = &amp;#39;E&amp;#39;;
                else newMove[j++] = &amp;#39;S&amp;#39;;
            }
            System.out.println(String.format(&amp;quot;Case #%d: %s&amp;quot;,i+1, new String(newMove)));
        }
    }

    private static void backtracking(Scanner sc, int tc) {
        for( int i = 0 ; i &amp;lt; tc; i++) {
            int n = sc.nextInt();
            sc.nextLine();
            String move = sc.nextLine();
            String path = backtrackingInternal(n,new int[]{0,0},new int[]{0,0},move,&amp;quot;SE&amp;quot;);
            System.out.println(path);
        }
    }
    private static boolean samePosition(int[] e, int[]m) {
        return e[0] == m[0] &amp;amp;&amp;amp; e[1] == m[1];
    }
    private static boolean boundGrid(int y,int x, int n) {
        return y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; n &amp;amp;&amp;amp; x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n;
    }
    //input : 현재상태 상대방과 나의 위치와 상대방의 이동방향, 나의 가능한 이동방향
    //output : 중복되지 않는 경로
    private static String backtrackingInternal(int n, int[] e, int[] m, String ep, String mps) {
        if( samePosition(e,m) &amp;amp;&amp;amp; ep.length() == 0 ) {
            return &amp;quot;&amp;quot;;
        }

        // 이동가능 후보가 없거나 패스가 중복되거나
        if( (samePosition(e,m) &amp;amp;&amp;amp; ep.substring(0,1).equals(mps))) {
            return null;
        } else if(mps.contains(ep.substring(0,1))){
            mps = mps.replace(ep.substring(0,1),&amp;quot;&amp;quot;);
        }


        for( char d : mps.toCharArray()) {

            if( d == &amp;#39;E&amp;#39; ) {
                //이동
                m[1]++;
                if( ep.charAt(0) == &amp;#39;E&amp;#39;) {
                    e[1]++;
                } else {
                    e[0]++;
                }
                //후보군설정
                String candidates = boundGrid(m[0],m[1]+1,n) ? &amp;quot;E&amp;quot;: &amp;quot;&amp;quot;;
                candidates += (boundGrid(m[0]+1,m[1],n)) ? &amp;quot;S&amp;quot; : &amp;quot;&amp;quot;;
                String path = backtrackingInternal(n, e,m,ep.substring(1),candidates);
                m[1]--;
                if( ep.charAt(0) == &amp;#39;E&amp;#39;) {
                    e[1]--;
                } else {
                    e[0]--;
                }
                if(  path != null) {
                    return  &amp;quot;E&amp;quot; + path;
                }


            } else {
                m[0]++;
                if( ep.charAt(0) == &amp;#39;E&amp;#39;) {
                    e[1]++;
                } else {
                    e[0]++;
                }
                String candidates = boundGrid(m[0],m[1]+1,n) ? &amp;quot;E&amp;quot;:&amp;quot;&amp;quot;;
                candidates += (boundGrid(m[0]+1,m[1],n))?&amp;quot;S&amp;quot;:&amp;quot;&amp;quot;;
                String path = backtrackingInternal(n,e,m,ep.substring(1),candidates);
                m[0]--;
                if( ep.charAt(0) == &amp;#39;E&amp;#39;) {
                    e[1]--;
                } else {
                    e[0]--;
                }
                if( path != null) {
                    return &amp;quot;S&amp;quot; + path;
                }


            }
        }


        return null;
    }



}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[boj]6603]]></title><description><![CDATA[로또 조합 생각보다 조합을 구현하는 법이 어렵다고 느꼈다. 순열의 경우에는 더 간단하게 구현이 되었던거 같은데 조합의 경우에는 
집합의 전체갯수, 뽑는 갯수, 현재 index…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-6603/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-6603/</guid><pubDate>Sat, 11 Jan 2020 08:51:53 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/6603&quot;&gt;로또&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;조합&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;생각보다 조합을 구현하는 법이 어렵다고 느꼈다. 순열의 경우에는 더 간단하게 구현이 되었던거 같은데 조합의 경우에는
집합의 전체갯수, 뽑는 갯수, 현재 index(집합을 모두 순회했는데 뽑아야하는 갯수가 남아있다면 조합의 경우가 없는 경우이다.)
nCr = n-1Cr-1 + n-1Cr 의 의미를 돌아보면 n번째 원소를 뽑는경우 나머지에서 r-1개의 원소를 뽑는 경우의수와 n을 뽑지 않아서 나머지에서 r개의 원소를 뽑는경우이다. 즉 재귀호출을 구현할 때에도 집합을 순회하면서 현재 위치를 index로 저장해두면서 현재 index의 원소를 뽑는경우와 안뽑는경우로 나누어 재귀호출을 한다.
기저조건은 뽑아야하는 갯수를 다 뽑았을 경우이다.
그 외 집합을 모두 순회한경우에도 뽑아야하는 갯수를 다 뽑지 못한경우는 조합을 조립하지 못하는 경우이므로 넘어간다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package boj;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Boj6603 {
    public static void main(String[] args) throws FileNotFoundException {
//        7 1 2 3 4 5 6 7
//        8 1 2 3 5 8 13 21 34
//        0
//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(&amp;quot;boj/6603.txt&amp;quot;))));
        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int n = sc.nextInt();
        while(n != 0) {
            int[] arr = new int[n];
            for( int i =0 ; i &amp;lt; n ; i++) {
                arr[i]= sc.nextInt();
            }
            printLotto(IntStream.of(arr).boxed().collect(Collectors.toList()),6,0,new ArrayList&amp;lt;&amp;gt;());
           n = sc.nextInt();
           System.out.println(&amp;quot;&amp;quot;);
        }
    }

    // 조합
    // input: 집합, 뽑아야하는 조합개수, 지금까지 뽑은 숫자들
    // output: void
    // 어떻게 조합을 중복제거할 수 있을까
    public static void printLotto(List&amp;lt;Integer&amp;gt; group, int k, int cur, List&amp;lt;Integer&amp;gt; arr) {
        if( arr.size() == k) {
            out(arr);
        } else if( cur == group.size()) return;
        else {

            arr.add(group.get(cur));
            printLotto(group, k, cur + 1, arr);
            arr.remove(arr.size() - 1);
            printLotto(group, k, cur + 1, arr);
        }
    }

    public static void out(List&amp;lt;Integer&amp;gt; list) {
        StringBuilder sb = new StringBuilder();
        for(Integer i : list) {
            sb.append(&amp;quot; &amp;quot; + i);
        }
        System.out.println(sb.substring(1));
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[gcj2019-qr1]Foregone Solution]]></title><description><![CDATA[Foregone Solution 생각 4는 2 2 로 나뉘기 때문에 4를 2로 변경해주면 된다.
숫자가 크기때문에 스트링으로 출력
숫자형태로 만들기 위해서 앞의 0은 제거]]></description><link>https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/gcj2019-qr1/</guid><pubDate>Thu, 09 Jan 2020 16:44:23 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/0000000000088231&quot;&gt;Foregone Solution&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;생각&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;4는 2 2 로 나뉘기 때문에 4를 2로 변경해주면 된다.
숫자가 크기때문에 스트링으로 출력
숫자형태로 만들기 위해서 앞의 0은 제거&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package codejam.qr2019.q1;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int tc = in.nextInt();
        in.nextLine();
        for(int i = 0; i &amp;lt; tc ; i++) {
            String num = in.nextLine();
            String num1 = num.replaceAll(&amp;quot;4&amp;quot;,&amp;quot;2&amp;quot;);
            String num2 = num.replaceAll(&amp;quot;[^4]&amp;quot;,&amp;quot;0&amp;quot;)
                    .replaceAll(&amp;quot;4&amp;quot;,&amp;quot;2&amp;quot;)
                    .replaceAll(&amp;quot;^0*2&amp;quot;,&amp;quot;2&amp;quot;)
                    ;
            System.out.println(String.format(&amp;quot;Case #%d: %s %s&amp;quot;,i+1,num1,num2));
        }

    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]ClockSync]]></title><description><![CDATA[CLOCKSYNC 생각 (알고리즘: 완전탐색) 완전 탐색이므로 한번씩 눌러보면서 12시로 맞는지 체크하자
4번씩 누르면 초기화가 되기때문에 0번에서 3번까지 눌러보면서 
모든 경우의 수를 체크한다. 주의할 점은…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-clocksync/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-clocksync/</guid><pubDate>Thu, 09 Jan 2020 16:44:23 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/CLOCKSYNC&quot;&gt;CLOCKSYNC&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;생각 (알고리즘: 완전탐색)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;완전 탐색이므로 한번씩 눌러보면서 12시로 맞는지 체크하자
4번씩 누르면 초기화가 되기때문에 0번에서 3번까지 눌러보면서
모든 경우의 수를 체크한다. 주의할 점은 3번까지 눌러놓고 상태를 초기화 해줘야한다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;보통 인풋과 아웃풋을 정하는 부분이 힘든데
아웃풋의 경우 알고리즘이 원하는 답안이 될 경우가 크다.
문제가 원하는 답은 최소 클릭횟수 이기때문에, 재귀함수로 문제를 풀기위해서는 어느 시점의 최소 클릭횟수를 리턴해주면된다.
인풋의 경우 상태값이 되는경우가 많다. (시계의 시침의 현재 상태), 또한 진행상황을 기록해야하므로 진행중인 순번도 함께 오는경우가 많다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.clocksync;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    static int[][] switches = new int[10][];
    static int[] clocks = new int[16];
    public static void main(String[] args) throws FileNotFoundException {
        switches[0] = new int[]{0,1,2};
        switches[1] = new int[]{3, 7, 9, 11};
        switches[2] = new int[]{4, 10, 14, 15};
        switches[3] = new int[]{0, 4, 5, 6, 7};
        switches[4] = new int[]{6, 7, 8, 10, 12};
        switches[5] = new int[]{0, 2, 14, 15};
        switches[6] = new int[]{3, 14, 15};
        switches[7] = new int[]{4, 5, 7, 14, 15};
        switches[8] = new int[]{1, 2, 3, 4, 5};
        switches[9] = new int[]{3, 4, 5, 9, 13};

//        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        Scanner sc = new Scanner(new FileInputStream(&amp;quot;algospot/clocksync/input.txt&amp;quot;));


        int tc = sc.nextInt();
        for( int i =0; i &amp;lt; tc ; i++) {
            clocks = new int[16];
            for(int j = 0 ; j &amp;lt; 16; j++) {
                clocks[j] = sc.nextInt();
            }

            //버튼을 한개씩 다 눌러본다
            // 4번누르면 제자리 이므로 3번씩만 눌러본다

            int res;
            if( (res = click(clocks, 0)) &amp;lt; Integer.MAX_VALUE )  {
                System.out.println(res);
            } else {
                System.out.println(-1);
            }
        }
    }

    //재귀
    //input: 시계들, 버튼, 누른버튼
    //output: 현상황에서의 num번부터 누를때 최소횟수
    static int click(int[] clocks,int num) {
        if( checkTime(clocks)) {
            return 0;
        }
        if( num == 10) {
            return Integer.MAX_VALUE;
        }

        //4번씩 눌러본다. 안누른거 포함
        int res = Integer.MAX_VALUE;
        for(int i=0; i &amp;lt; 4; i++) {
            if( i&amp;gt; 0) push(clocks,num);
            int min = click(clocks,num+1);
            if( min != Integer.MAX_VALUE) {
                res = Math.min(res , min + i);
            }
        }
        //3번까지 눌렀으므로 초기화해줌
        push(clocks,num);
        return res;
    }
    static void push(int[] clocks,int num) {
        for (int m : switches[num]) {
            clocks[m] = clocks[m] == 12 ? 3 : clocks[m]+3;
        }
    }
    static boolean checkTime(int[] clocks) {
        return Arrays.stream(clocks).allMatch(i-&amp;gt;i==12);
    }
    static int total(int[] buttons) {
        return Arrays.stream(buttons).sum();
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]tsp1]]></title><description><![CDATA[TSP1 재귀 호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-tsp1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-tsp1/</guid><pubDate>Mon, 06 Jan 2020 16:15:24 GMT</pubDate><content:encoded>&lt;h1&gt;TSP1&lt;/h1&gt;
&lt;h2&gt;재귀 호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.tsp1;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc = new Scanner(new FileInputStream(&amp;quot;algospot/tsp1/input.txt&amp;quot;));
        int tc = sc.nextInt();
        for( int i = 0; i &amp;lt; tc; i++) {
            int cities = sc.nextInt();
            double[][] map = new double[cities][cities];

            for( int j = 0 ; j &amp;lt; cities*cities;j++) {
                int y = j / cities;
                int x = j % cities;
                map[y][x] = sc.nextDouble();
            }
            double res = Double.MAX_VALUE;
            for( int k = 0 ; k &amp;lt; cities; k++) {
                boolean[] visits = new boolean[cities];
                visits[k] = true;
                res = Math.min(res,traverse(map, visits, k));
            }
            System.out.println(res);

        }

    }

    // input: 도시간 거리 정보 double[][], 방문여부 boolean[], 시작점 int
    // output: 최소 여행 길이
    public static double traverse(double[][] map, boolean[] visits, int st) {

        int next = -1;
        for( int i = 0;  i &amp;lt; visits.length ; i++) {
            if( !visits[i]) {
                next = i;
                break;
            }
        }
        // 모두 방문했다면
        if( next == -1) {
            return 0;
        }
        double minDist = Double.MAX_VALUE;
        for(int i = 0 ; i &amp;lt; visits.length; i++) {
            if(!visits[i]) {
                visits[i]= true;
                double dist = map[st][i] + traverse(map,visits,i);
                visits[i]= false;
                if( dist &amp;lt; minDist) {
                    minDist = dist;
                }
            }
        }
        return minDist;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]boardcover]]></title><description><![CDATA[BOARDCOVER 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-boardcover/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-boardcover/</guid><pubDate>Sat, 04 Jan 2020 17:40:56 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/BOARDCOVER&quot;&gt;BOARDCOVER&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public class Main {

    private static char[][][] block = new char[][][] {
            {{&amp;#39;#&amp;#39;,&amp;#39;#&amp;#39;},
                    {&amp;#39;#&amp;#39;,&amp;#39;.&amp;#39;}},
            {{&amp;#39;#&amp;#39;,&amp;#39;#&amp;#39;},
                    {&amp;#39;.&amp;#39;,&amp;#39;#&amp;#39;}},
            {{&amp;#39;.&amp;#39;,&amp;#39;#&amp;#39;},
                    {&amp;#39;#&amp;#39;,&amp;#39;#&amp;#39;}},
            {{&amp;#39;#&amp;#39;,&amp;#39;.&amp;#39;},
                    {&amp;#39;#&amp;#39;,&amp;#39;#&amp;#39;}},
    };

    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc = new Scanner(new FileInputStream(&amp;quot;algospot/boardcover/input.txt&amp;quot;));
        int tc = sc.nextInt();
        IntStream.range(0,tc)
                .forEach(i-&amp;gt; {
                    //tc
                    int row = sc.nextInt();
                    int col = sc.nextInt();
                    sc.nextLine();

                    char[][] map = new char[row][];

                    // map reading
                    final int[] sum = {0};
                    IntStream.range(0,row)
                            .forEach(ii-&amp;gt;{
                                map[ii] = sc.nextLine().toCharArray();
                                sum[0] += IntStream.range(0,map[ii].length)
                                        .mapToObj(index-&amp;gt;map[ii][index])
                                        .filter(c-&amp;gt;c==&amp;#39;.&amp;#39;)
                                        .count();
                            });
                    System.out.println(getBlockNum(map,sum[0]));

                });
    }

    // input: map, 남은 칸수
    // output: block을 놓을 수 있는 가능한 수
    public static int getBlockNum(final char[][] map, int remain) {
        if( remain % 3 != 0)
            return 0;
        if( remain == 0 )
            return 1;

        // 맨 왼쪽 위쪽부터 블록을 채워감
        int first = IntStream.range(0,map.length * map[0].length)
                .filter(i-&amp;gt;map[i/map[0].length][i%map[0].length] == &amp;#39;.&amp;#39;)
                .findFirst().getAsInt();
        int r = first / map[0].length;
        int c = first % map[0].length;
        int res= 0 ;

        for( int i = 0; i &amp;lt; 4 ; i++) {
            char[][] b = block[i];
            if( isBlockFit(map, b, r, c)) {
                addBlock(map,b,r,c);
                res += getBlockNum(map, remain-3);
                removeBlock(map,b,r,c);
            }
        }
        return res;
    }

    private static void removeBlock(char[][] map, char[][] b, int r, int c) {
        if(b[0][0] == &amp;#39;.&amp;#39;) c--;
        for( int i = 0; i &amp;lt; 2 ; i++) {
            for( int j = 0 ; j &amp;lt; 2 ; j++) {
                if( b[i][j] == &amp;#39;#&amp;#39;) {
                    map[r+i][c+j] = &amp;#39;.&amp;#39;;
                }
            }
        }
    }

    private static void addBlock(char[][] map, char[][] b, int r, int c) {
        if(b[0][0] == &amp;#39;.&amp;#39;) c--;
        for( int i = 0; i &amp;lt; 2 ; i++) {
            for( int j = 0 ; j &amp;lt; 2 ; j++) {
                if( b[i][j] == &amp;#39;#&amp;#39;) {
                    map[r+i][c+j] = &amp;#39;#&amp;#39;;
                }
            }
        }
    }

    private static boolean isBlockFit(char[][] map, char[][] b, int r, int c) {
        if(b[0][0] == &amp;#39;.&amp;#39;) c--;
        if(!(r &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; map.length &amp;amp;&amp;amp; c &amp;gt;=0 &amp;amp;&amp;amp; c &amp;lt; map[0].length
        &amp;amp;&amp;amp; r+1 &amp;gt;= 0 &amp;amp;&amp;amp; r+1 &amp;lt; map.length &amp;amp;&amp;amp; c+1&amp;gt;=0 &amp;amp;&amp;amp; c+1 &amp;lt; map[0].length)) return false;
        for( int i = 0; i &amp;lt; 2 ; i++) {
            for( int j = 0 ; j &amp;lt; 2 ; j++) {
                if( map[r+i][c+j] == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; b[i][j] == &amp;#39;#&amp;#39;) {
                    return false;
                }
            }
        }
        return true;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 6]]></title><description><![CDATA[AOP…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring6/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring6/</guid><pubDate>Sat, 04 Jan 2020 16:00:39 GMT</pubDate><content:encoded>&lt;h1&gt;AOP&lt;/h1&gt;
&lt;h2&gt;프록시&lt;/h2&gt;
&lt;p&gt;서비스 추상화를 통해서, 트랜잭션을 적용하는 내용을 데이터 액세스 기술에 관계없이 적용할 수 있게끔 &lt;code class=&quot;language-text&quot;&gt;전략패턴&lt;/code&gt;으로 분리 시켰지만,
비지니스 로직자체에 트랜잭션을 적용시키는(부가기능) 코드는 그대로 남아있다. 트랜잭션을 적용시키는 부분까지도 비지니스 로직에서 제거하기 위해서
인터페이스를 통해 구현부분을 분리시켜 &lt;code class=&quot;language-text&quot;&gt;부기가능&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;핵심기능&lt;/code&gt;을 사용하도록 구조를 만든다.&lt;/p&gt;
&lt;p&gt;여기서 주의할 점은 클라이언트가 직접 &lt;code class=&quot;language-text&quot;&gt;핵심기능&lt;/code&gt;을 사용하지 못하도록 &lt;code class=&quot;language-text&quot;&gt;부가기능&lt;/code&gt;이 마치 &lt;code class=&quot;language-text&quot;&gt;핵심기능&lt;/code&gt;인것처럼 꾸며 클라이언트의 요청을 가로채야 한다는 사실이다. 여기서 &lt;code class=&quot;language-text&quot;&gt;부가기능&lt;/code&gt;은 프록시, &lt;code class=&quot;language-text&quot;&gt;핵심기능&lt;/code&gt;은 타겟이라고 부른다.&lt;/p&gt;
&lt;p&gt;프록시는 두가지로 구분할 수 있는데&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트가 타겟에 접근하는 방법을 제어하기 위해서&lt;/li&gt;
&lt;li&gt;타겟에 부가적은 기능을 부여해주기 위해서&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;각각을 목적에 따라 디자인 패턴에서는 다른 패턴으로 구분한다.&lt;/p&gt;
&lt;h2&gt;데코레이터 패턴&lt;/h2&gt;
&lt;p&gt;부가기능을 부여하기 위해서 프록시를 사용하는 패턴이다. 프록시를 여러개를 사용해 각각 다른 부가기능을 타겟 기능에 부여할 수 있다. &lt;/p&gt;
&lt;p&gt;예) 선물포장하기&lt;/p&gt;
&lt;p&gt;선물포장요청-&gt; 리본묶기 -&gt; 포장지 감싸기 -&gt; 선물&lt;/p&gt;
&lt;h2&gt;프록시 패턴&lt;/h2&gt;
&lt;p&gt;타겟에 접근하는 방법을 제어하기 위해서 사용하는 패턴이다. &lt;strong&gt;프록시 패턴의 프록시는 타겟의 기능을 확장하거나 추가하지 않는다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;예) lazy init&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;타겟이 당장 쓰이지 않지만, 참조값이 필요할 때 프록시를 미리 생성해두고 클라이언트가 프록시를 통해 메소드를 호출할 때, 타겟을 생성해서 요청을 위임한다. 즉, 타겟을 직접 사용할 때까지 최대한 생성을 늦춘다. &lt;/li&gt;
&lt;li&gt;원격 오브젝트에 대한 접근방법을 제공해줄 때 사용할 수 있다. 원격 오브젝트에 대한 프록시를 만들어두고 클라이언트는 마치 로컬 오브젝트에게 요청하듯이 작업을 요청하고, 프록시는 내부에서 원격오브젝트를 실행하여 결과를 돌려주는 식이다.&lt;/li&gt;
&lt;li&gt;타겟에 대한 접근권한을 제어하기 위해서도 사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;예) Collections.unmodifiableCollection&lt;/p&gt;
&lt;p&gt;데코레이터와 프록시는 유사해보이지만, 생성을 지연하는 프록시의 경우 구체적인 생성 방법을 알아야하므로 타겟에 대한 구체적인 정보를 알고 있는 경우가 많다.&lt;/p&gt;
&lt;h2&gt;프록시 작성의 문제점&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;타겟의 인터페이스를 구현하는게 번거롭다. 단순 위임형식이어도 일일이 코드를 작성해야하고, 타겟의 메소드가 추가되거나 변경될 경우 함께 수정해야한다.&lt;/li&gt;
&lt;li&gt;부가기능 코드가 중복될 가능성이 많다. 각 메소드마다 부가기능이 들어간다면 부가기능은 각각 메소드마다 항상 중복되어 나타나게 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;다이나믹 프록시&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;프록시 팩토리&lt;/code&gt;에 의해서 런타임 시 다이나믹하게 만들어지는 객체이다. 타겟의 메소드 수가 몇개이던 상관없이 타겟 인터페이스의 정보와 프록시 메소드 호출 시 실행되는 &lt;code class=&quot;language-text&quot;&gt;InvocationHandler&lt;/code&gt;만 구현하면 프록시 적용이 가능하다. 또한 타겟의 적용 대상이 제한되있지 않으므로 재사용성이 높다.&lt;/p&gt;
&lt;p&gt;예) 리턴 타입이 string인 것만 uppercase적용, 메소드 이름이 say로 시작하는 경우에만 uppercase 적용&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;주의&lt;/strong&gt;
InvocationHandler를 구현할 때, 타겟의 Exception은 InvocationTargetException으로 감싸져 던져지므로 InvocationTargetException으로 캐치를 한뒤 , getTargetException으로 해당 예외처리를 해야한다.&lt;/p&gt;
&lt;h2&gt;다이나믹 프록시 문제점&lt;/h2&gt;
&lt;p&gt;다이나믹 프록시와 InvocationHandler를 통해서 프록시를 적용할 수 있으므로, 프록시를 스프링 DI를 통해 주입시킬 수 있어야한다. 하지만 &lt;strong&gt;DI의 대상이 되는 다이나믹 프록시 객체는 클래스 명이 없으므로 일반적으로 DI될 수 있는 방법이 없다&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;스프링의 빈을 만드는 방법은 클래스의 디폴터 생성자를 이용하는 방법 이외에도 여러가지 방법을 제공하는데 그 중 하나가 &lt;code class=&quot;language-text&quot;&gt;팩토리 빈&lt;/code&gt;을 이용하는 방법이다.
&lt;code class=&quot;language-text&quot;&gt;팩토리 빈&lt;/code&gt;을 만드는 방법에는 여러가지가 있는데 가장 간단한 방법은 FactoryBean 인터페이스를 구현하는것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;팩토리 빈&lt;/h3&gt;
&lt;p&gt;팩토리 빈의 등록방법은 여타 빈의 등록방법과 다르지 않다. 아래 예제에서 등록되는 aaa의 빈의 경우 FactoryBean의 객체가 등록되는것이 아닌
FactoryBean의 getObject 메소드가 생성해주는 객체가 aaa빈으로 등록이되며, 타입은 팩토리 빈의 getObjectType이 리턴하는 타입으로 결정된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;bean id =&amp;quot;aaa&amp;quot; class=&amp;quot;factoryBeanclass&amp;quot;&amp;gt; 
    &amp;lt;property name=&amp;quot;bbb&amp;quot; value=&amp;quot;testString&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;팩토리 빈은 빈 이름앞에 &lt;code class=&quot;language-text&quot;&gt;&amp;amp;&lt;/code&gt;를 붙여주면 얻을 수 있다.&lt;/li&gt;
&lt;li&gt;팩토리 빈은 빈을 생성할 때 필요한 정보들을 프로퍼티로 가지고 있다가, 빈을 생성할 때 해당 프로퍼티를 전달하면서 객체를 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;즉 프록시를 생성하는 팩토리 빈과 타겟을 빈으로 등록하여 프록시를 빈으로 등록하여 사용할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;팩토리 빈의 장점과 한계&lt;/h2&gt;
&lt;h3&gt;장점&lt;/h3&gt;
&lt;p&gt;프록시 팩토리 빈의 장점은 타겟에 제한없이 재사용이 가능하다는 점이다. 또한 다이나믹 프록시의 문제점 2가지 일일이 메소드를 구현해야한다는 점과,
부가기능의 코드가 메소드마다 중복되어 나타나는 문제점을 &lt;code class=&quot;language-text&quot;&gt;프록시 팩토리 빈&lt;/code&gt;으로 해결할 수 있다.&lt;/p&gt;
&lt;h3&gt;한계&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;한번에 여러 클래스에 공통적인 부가기능을 제공하는 것은 불가능하다. (하나의 클래스는 가능, 즉 여러개의 팩토리 빈 설정이 중복) - 200개의 클래스에 여러 부가기능을 적용시키려면 200 * 부가기능갯수 만큼의 팩토리 빈 설정이 필요 &lt;/li&gt;
&lt;li&gt;InvocationHandler는 타겟 객체를 프로퍼티로 지니고 있으므로, 프록시 팩토리 빈 갯수만큼 만들어진다. &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;프록시 팩토리 빈&lt;/h2&gt;
&lt;p&gt;jdk에서는 다이나믹 프록시 외에도 프록시를 만들 수 있도록 다양한 기술을 지원한다. 따라서 스프링은 일관된 방법으로 프록시를 만들 수 있게끔 추상화 된 레이어를 제공한다.&lt;/p&gt;
&lt;h3&gt;MethodInterceptor vs InvocationHandler&lt;/h3&gt;
&lt;p&gt;invocationHandler.invoke는 타겟에 대한 정보를 제공하지 않기 때문에 직접 invocationHandler가 타겟을 알고 있어야 하지만, MethodInterceptor의 invoke는 proxyFactoryBean으로부터 타겟 정보도 제공받으므로, MethodInterceptor의 경우 타겟과 독립적으로 만들어지고,사용될 수 있다.&lt;/p&gt;
&lt;p&gt;타겟으로부터 독립될 수 있다면 MethodInterceptor는 타겟에 독립적으로 빈으로 등록되어 여러 타겟이 공유할 수 있다(싱글톤 패턴)
포인트컷 역시 타겟에 독립될 수 있다면 빈으로 등록되어 여러 타겟이 공유할 수 있다(싱글톤 패턴)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;중복 문제의 접근 방법
1. jdbc api를 사용하는 dao 코드에서 메소드 마다 try/catch/finally 블록 중복 발생
    - 바뀌는 부분과 바뀌지 않는 부분으로 분리, 템플릿/콜백 패턴으로 해결
2. 반복적인 위임 코드가 필요한 프록시
    - 다이나믹 프록시라는 런타임 코드 자동생성 기법 사용하여 해결&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;팩토리 빈의 한계를 스프링 프록시 팩토리 빈으로 개선&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;팩토리 빈의 문제상황 인지&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;한번에 여러 클래스에 부가기능 제공 불가능&lt;/li&gt;
&lt;li&gt;InvocationHandler는 타겟을 의존하고 있으므로, 타겟 적용 갯수만큼 늘어남&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제상황을 어떻게 해결할지 고민&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;한번에 여러 클래스에 부가기능 제공 불가능에서 변하는 부분과 변하지 않는 부분을 설정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변하는 부분: 부가기능을 적용할 실제 타겟&lt;/li&gt;
&lt;li&gt;변하지 않는부분: 타겟의 타입에 맞는 프록시 생성 작업&lt;/li&gt;
&lt;li&gt;고려 방향: 부가기능을 적용할 실제 타겟의 리스트를 주입받아 프록시 생성 작업을 자동으로 할 수 있다면?? =&gt; 빈 후처리기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InvocationHandler는 타겟을 의존하고 있으므로, 중복해서 발생하는 문제&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변하는 부분: 실제 부가기능을 적용할 타겟&lt;/li&gt;
&lt;li&gt;변하지 않는 부분: 적용할 부가기능&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고려 방향: 타겟을 주입받아서 부가기능을 적용시킬 수 있다면?? =&gt; 어드바이스, 포인트 컷&lt;/p&gt;
&lt;h2&gt;빈 후처리기&lt;/h2&gt;
&lt;p&gt;빈 후처리기는 빈 설정파일을 통해 생성된 빈 객체들을 조건에 맞게 수정하거나, 대체할 수 있다. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;DefaultAdvisorAutoProxyCreator 동작 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;등록된 빈중에서 Advisor를 구현한 객체들을 모두 찾는다.&lt;/li&gt;
&lt;li&gt;생성되는 모든 빈에 대해서 어드바이저 포인트컷의 적용대상일 경우 프록시를 만들어서 원래 빈을 대체한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;AspectJ 포인트컷 표현식&lt;/h3&gt;
&lt;p&gt;AspectJ 표현식의 대상을 표현하는데 다양한 방법이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;execution - 메소드의 시그니처를 비교하는 방식 (ex: Object.class.getMethod(“getClass”))&lt;/li&gt;
&lt;li&gt;bean - 빈이름으로 대상을 설정 (클래스와 메소드기준을 넘어섬)&lt;/li&gt;
&lt;li&gt;@annotation - 특정 어노테이션으로 대상을 설정(ex: @anootation(org.springframework.transaction.Transactional))&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;주의점: AspectJ 포현식의 타입패턴의 경우 객체의 클래스만을 비교하는것이 아닌 객체의 모든 타입을 비교하여 대상을 결정한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ex: A-&gt;B(C) [A: 자식 클래스 , B: 부모 클래스, (C): 부모 인터페이스] 라고할때 클래스 명으로 대상을 정할때 A 객체는 A타입이기도하면서 B 타입이기도 하며, C타입이기도 하다. 따라서 클래스 명 조건이 A,B,C중에 하나라도 적용된다면 대상에 포함된다.(AspectJ 타입패턴에 한해)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;리마인드&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;서비스 추상화
비지니스 로직에 트랜잭션 경계설정 -&gt; 트랜잭션 기술에 종속적인 코드 발생 -&gt; 서비스 추상으로 일관된 경계설정(트랜잭션 구현기술 DI)
추상화란: 인터페이스와 DI를 통해 &lt;code class=&quot;language-text&quot;&gt;무엇을 하는지는(추상흐름)&lt;/code&gt; 남기고 &lt;code class=&quot;language-text&quot;&gt;어떻게 하는지(구체적 구현)&lt;/code&gt;를 분리한것&lt;/li&gt;
&lt;li&gt;데코레이션 패턴
비지니스 로직에 트랜잭션 경계설정 코드 혼재 -&gt; 데코레이션 패턴으로 분리&lt;/li&gt;
&lt;li&gt;다이나믹 프록시 &amp;#x26; 프록시 팩토리 빈
데코레이션 패턴을 적용하기 위해서 모든 메소드 구현 및 트랜잭션(부가기능) 중복발생 -&gt; 다이나믹 프록시 적용 -&gt; 여러 클래스에 적용할 때 중복 발생 -&gt; 프록시 팩토리 빈(프록시 기술 추상화) 적용 -&gt; 어드바이스, 포인트컷을 타겟에 독립적으로 사용 가능&lt;/li&gt;
&lt;li&gt;자동 프록시 생성
트랜잭션 적용 대상마다 프록시 팩토리 빈 적용하여 중복 발생 -&gt; 빈 후처리기 적용 -&gt; AspectJ를 통한 포인트컷 표현식 적용&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;AOP 용어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;타겟 - 부가기능을 적용할 대상&lt;/li&gt;
&lt;li&gt;어드바이스 - 부가기능&lt;/li&gt;
&lt;li&gt;조인포인트 - 어드바이스가 적용될 수 있는 위치(프록시의 경우 메소드 실행단계)&lt;/li&gt;
&lt;li&gt;포인트컷 - 조인포인트를 선별하는 작업 혹은 모듈&lt;/li&gt;
&lt;li&gt;프록시 - 클라이언트와 타겟 사이에서 요청을 대신 받아 타겟에 위임하면서 부가기능을 부여하는 객체&lt;/li&gt;
&lt;li&gt;어드바이저 - 포인트컷 + 어드바이스(스프링 aop 용어, 단순한 애스팩트)&lt;/li&gt;
&lt;li&gt;애스팩트 - aop의 기본모듈 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;프록시 AOP 준비작업&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;자동 프록시 생성기 - DefaultAdvisorAutoProxyCreator&lt;/li&gt;
&lt;li&gt;어드바이스&lt;/li&gt;
&lt;li&gt;포인트컷&lt;/li&gt;
&lt;li&gt;어드바이저&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[[algospot]picnic]]></title><description><![CDATA[PICNIC 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-picnic/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-picnic/</guid><pubDate>Fri, 03 Jan 2020 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/PICNIC&quot;&gt;PICNIC&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.picnic;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.*;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) throws FileNotFoundException {

//        Scanner sc = new Scanner(new FileInputStream(&amp;quot;algospot/picnic/test.txt&amp;quot;));
        Scanner sc=  new Scanner(System.in);
        int tc = sc.nextInt();
        for( int i = 0; i &amp;lt; tc ; i++ ) {
            int total = sc.nextInt();
            int friend = sc.nextInt();
            int[][] friends = new int[10][10];
            for(int j = 0 ; j &amp;lt; friend ; j++) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                friends[a][b] = 1;
                friends[b][a] = 1;
            }
            System.out.println(getFriendNumber(new int[total], friends, total));

        }
    }

    // 친구 목록이 주어졌을 때의 친구들끼리 짝을 맺을 수 있는 경우의 수
    static int getFriendNumber(int[] children, int[][] friends, int remain) {
        // 짝이 다 맞으면 경우의 수 1 추가
        if( remain == 0 ) {
            return 1;
        }
        final int[] res = {0};
        // 가장 첫번째부터 짝을 맺어준다
        int first=IntStream.range(0,children.length)
                .filter(i-&amp;gt;children[i] == 0)
                .findFirst().getAsInt();
        IntStream.range(first,children.length)
                .filter(j-&amp;gt;friends[first][j] == 1 &amp;amp;&amp;amp; children[j] == 0)
                .forEach(j-&amp;gt;{
                    children[first]=1;
                    children[j]=1;

                    res[0] +=getFriendNumber(children,friends,remain-2);
                    children[first]=0;
                    children[j]=0;


                });

        return res[0];
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[boj]1914]]></title><description><![CDATA[하노이 탑 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-1914/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-1914/</guid><pubDate>Fri, 03 Jan 2020 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1914&quot;&gt;하노이 탑&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public class Boj1914 {
    int res;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        BigInteger res = BigInteger.valueOf(2).pow(n).subtract(BigInteger.ONE);
        System.out.println(res);
        if( n &amp;lt;= 20) hanoi(n,1,3);
    }

    // 문제의 조각 n개의 조각을 1-&amp;gt;3으로 옮기는 문제
    // 처음 시작하는 판의 갯수 n의 크기에 따라 재귀함수의 크기가 달라진다.
    // n = 1 1-&amp;gt;3 단순히 옮기면 됨
    // n = 2 1-&amp;gt;2, 1-&amp;gt;3 , 2-&amp;gt;3
    // n = 3 1-&amp;gt;3, 1-&amp;gt;2, 3-&amp;gt;2, 1-&amp;gt;3, 2-&amp;gt;1, 2-&amp;gt;3, 1-&amp;gt;3
    // n = 4 1-&amp;gt;2, 1-&amp;gt;3, 2-&amp;gt;3, 1-&amp;gt;2, 3-&amp;gt;1, 3-&amp;gt;2, 1-&amp;gt;2, 1-&amp;gt;3, 2-&amp;gt;3, 2-&amp;gt;1, 3-&amp;gt;1, 2-&amp;gt;3, 1-&amp;gt;2, 1-&amp;gt;3, 2-&amp;gt;3
    // n = k 일때 추상적 흐름
    // k-1개의 원반을 목적지 이외의 기둥에 옮겨놓는다.(구체적으로는 모름)
    // k 번째 원반을 목적지에 옮겨놓음
    // k-1개의 원반을 다시 목적지로 옮긴다.( 구체적으로는 모름)
    // 문제의 조각: n(원판의 갯수), st(시작점), end(목표), 순서기록여부 리턴: 횟수
    // 기저조건: n = 1 인경우 그냥 옮기면 됨
    // 문제의 조각 내에 순서를 리턴하게 되면 안됨. 20 이하일때만 리턴하도록 되있기 때문에
    // 시간 초과가 나므로 캐시를 사용해야하는데 n, st,end에 대해서 순서도를 캐시할거임
    // 1. 맥스값 오류 - long을 벗어남
    // 2. 메모리 오버 - 여러 풀이들을 보니 그냥 2^n-1 최소횟수를 리턴하도록 되있음


    public static long hanoi(int n , int st, int end ) {
        if( n == 1) {
            System.out.println(&amp;quot;&amp;quot;+st +&amp;quot; &amp;quot; + end);
//            wrapper.add(new int[]{st,end});
            return 1;
        }

        long cnt1 = hanoi(n-1, st, 6-st-end);
        long cnt2 = hanoi(1,st,end);
        long cnt3 = hanoi(n-1,6-st-end,end);

        return cnt1+cnt2+cnt3;
    }


}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[algospot]boggle]]></title><description><![CDATA[BOGGLE 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-boggle/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-boggle/</guid><pubDate>Tue, 31 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/BOGGLE&quot;&gt;BOGGLE&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.boggle;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {
    static char[][] arr;
    static int[][] directions = {
            {-1,-1},
            {-1,0},
            {-1,1},
            {0,-1},
            {0,1},
            {1,-1},
            {1,0},
            {1,1}
    };
    static int[][][] cache ;
    public static void main(String[] args) throws IOException {

//        BufferedReader br = new BufferedReader((new InputStreamReader(new FileInputStream(&amp;quot;algospot/boggle/test.txt&amp;quot;))));
        BufferedReader br = new BufferedReader((new InputStreamReader(System.in)));
        int tc = Integer.valueOf(br.readLine());
        for( int i = 0 ; i &amp;lt; tc ; i++) {
            arr = new char[5][5];
            arr[0] = br.readLine().toCharArray();
            arr[1] = br.readLine().toCharArray();
            arr[2] = br.readLine().toCharArray();
            arr[3] = br.readLine().toCharArray();
            arr[4] = br.readLine().toCharArray();


            int wordNum = Integer.valueOf(br.readLine());

            for( int j = 0 ; j &amp;lt; wordNum ; j++) {
                cache = new int[5][5][10];
                String word = br.readLine();
                if( findWord(word)) {
                    System.out.println(String.format(&amp;quot;%s %s&amp;quot;,word,&amp;quot;YES&amp;quot;));
                } else {
                    System.out.println(String.format(&amp;quot;%s %s&amp;quot;,word,&amp;quot;NO&amp;quot;));
                }
            }
        }

    }

    public static boolean findWord(String word) {
        return IntStream
                .range(0,25)
                .anyMatch(i-&amp;gt;{
                    int y = i / 5;
                    int x = i % 5;
                    return findWord(y,x,word.toCharArray());
                });
    }

    public static boolean findWord(int y, int x , char[] word) {
        if( cache[y][x][word.length-1] == 1) {
            return true;
        } else if( cache[y][x][word.length-1] == -1) {
            return false;
        }
        if(word.length == 1 ) {
            return word[0] == arr[y][x];
        }

        if( word[0] == arr[y][x]) {
            boolean res = Stream.of(directions)
                    .anyMatch(i-&amp;gt;{
                        int yy = y + i[0];
                        int xx = x + i[1];
                        if( yy &amp;gt;= 0 &amp;amp;&amp;amp; yy &amp;lt; 5 &amp;amp;&amp;amp; xx &amp;gt;=0 &amp;amp;&amp;amp; xx &amp;lt; 5) return findWord(yy,xx,new String(word).substring(1).toCharArray());
                        return false;
                    });
            if(res) cache[y][x][word.length-1]= 1;
            else cache[y][x][word.length-1] = -1;
            return res;
        }

        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[boj]1074]]></title><description><![CDATA[Z 재귀호출 문제: z로 탐색할 때, n,r,c가 주어졌을 때 순서를 리턴
문제의 조각: nrc가 주어졌을때 순서를 리턴
기저조건 : n이 0인경우는 무조건 순서가 1
그 외 : 1 2 3 4 구역 나누기
1구역이라면 1구역 내에서 순서 리턴…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-1074/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-1074/</guid><pubDate>Tue, 31 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1074&quot;&gt;Z&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;문제: z로 탐색할 때, n,r,c가 주어졌을 때 순서를 리턴
문제의 조각: nrc가 주어졌을때 순서를 리턴
기저조건 : n이 0인경우는 무조건 순서가 1
그 외 : 1 2 3 4 구역 나누기
1구역이라면 1구역 내에서 순서 리턴
2구역이라면 1구역 갯수 + 2구역 내에서 순서 리턴
3구역이라면 2구역 까지 갯수 + 3구역 내에서 순서
4구역이라면 3구역 까지 갯수 + 4구역 내에서 순서&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;static int getZOrder(int n , int r , int c) {
        if( n == 0) {
            return 1;
        }
        int num = 1 &amp;lt;&amp;lt; n-1;
        //1
        if( num &amp;gt; r &amp;amp;&amp;amp; num &amp;gt; c) {
           return getZOrder(n-1, r,c);
        }
        //2
        else if( num &amp;gt; r &amp;amp;&amp;amp; num &amp;lt;= c) {
            return (num *num) + getZOrder(n-1, r, c- num);
        }
        //3
        else if( num &amp;lt;= r &amp;amp;&amp;amp; num &amp;gt; c) {
            return (num *num * 2) + getZOrder(n-1,r-num , c);
        }
        //4
        else {
            return (num *num * 3) + getZOrder(n-1, r-num, c-num);
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 2]]></title><description><![CDATA[…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring2/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;2장&lt;/h1&gt;
&lt;p&gt;테스트&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;단위 테스트를 이용해서 기존의 코드가 정상 동작하는것을 확신할 수 있고, 테스트하고자 하는 기능에 집중해 테스트 할 수 있으므로, 장애 대응이 용이하다.
단위 테스트를 이용하면 많은 수의 테스트 케이스를 일일이 수행하는 작업과 결과값을 검증하는 작업을 자동화할 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트 코드 작성&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;junit은 프레임워크이기 때문에 ioc을 이용하여 테스트를 진행한다. 그렇기 때문에 main의 테스트 함수를 junit 테스트 코드로 변경해야한다.
main 함수의 경우에는 제어권을 갖는다는 의미이기 때문이다.

테스트 메소드는 &amp;quot;pulic&amp;quot;이어야하고, &amp;quot;@Test&amp;quot; 어노테이션을 붙여야 한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트가 이끄는 개발&lt;/h2&gt;
&lt;p&gt;   테스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 실제 비지니스 로직을 수정하여 완성한다.
테스트 코드를 먼저 작성할 때에는 추가하고 싶은 기능을 코드로 표현해야 하는데,
테스트 코드의 표현은 조건, 행위, 결과로 표현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;조건: 어떤 조건을 가지고 ( 사용자 정보가 없을때)
행위: 무엇을 할 때 (존재하지 않는 id로 조회를 하면)
결과: 어떤 결과가 나온다.(exception이 발생한다.)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트 컨텍스트 관리&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;테스트 시에 공통적인 로직은 @Before 나 @After를 이용해서 각 테스트 전과 후에 수행할 수 있다.
또한 테스트는 각 메소드마다 독립성을 유지하기 위해서 새롭게 테스트객체가 생성되는데, 매번 테스트 컨텍스트를 인스턴스 변수에 두고 새로 생성하는것은 비효율적이다.
따라서, 각 테스트 메소드마다 컨텍스트를 공유하기 위해서 클래스마다 딱 한번 실행되는 @BeforeClass를 사용해 스테틱 변수에 저장하여 사용하거나, 스프링이 직접 제공하는
어플리케이션 컨텍스트 테스트 지원 기능을 사용하면 된다.

어플리케이션 컨텍스트는 @ContextConfiguration을 사용한 뒤, ApplicationContext를 주입받는 식으로 작성하면 된다.
테스트 컨텍스트는 메소드간의 공유뿐 아니라 테스트 클래스간 컨텍스트 설정이 같다면 공유도 가능하다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;DI와 테스트&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;컴포넌트 간, 인스턴스간 관계가 절대 변하지 않는 경우에는 DI를 사용하지 않아도 될까? 그렇지 않다.
DI는 구현체를 동적으로 변경할 수 있다는 장점(프록시 패턴) 외에도 직접 DI를 통해서 작은 부분만을 테스트할 수 있는 유용한 기술이다.
```
DataSource를 운영계와 테스트계를 따로 분리할 경우에,
1. @DirtiesContext를 사용하여 @Before시마다 dao의 DataSource를 직접 SingleConnectionDataSource로 DI할 수 있다.
2. 별도의 DI 설정파일을 만들어(ex: test-applicationContext.xml) @ContextConfiguration의 설정파일로 사용하여 운영계와 별도의 설정을 가지고 테스트를 실행할 수 있다.
3. 스프링의 컨테이너 없이 @Before를 이용해서 직접 dao객체를 생성하고 SingleConnectionDataSource를 생성하여 DI시켜줄 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   3가지 방법 중 우선적으로 스프링 컨테이너 없이 테스트할 수 있는 방법을 고려하고, 여러 오브젝트와 복잡한 의존관계를 갖고있는 오브젝트라면
스프링 설정을 이용한 DI방식을 고려하자
`&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;학습 테스트&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;자신이 작성하지 않은 프레임워크나, 다른 개발팀에서 만든 라이브러리 등에 대해서 테스트를 작성하여, 깊은 이해를 이끌어 내는 테스트 작성 방식이다.

 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 1]]></title><description><![CDATA[1장 관심사의 분리
모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다
문제는 변화에 따른 작업은 한곳에 집중되지 않다는 경우가 많다는 점이다. 예) db…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring1/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;1장&lt;/h1&gt;
&lt;p&gt;관심사의 분리
모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다
문제는 변화에 따른 작업은 한곳에 집중되지 않다는 경우가 많다는 점이다. 예) db 정보 변경
즉, 변화가 한 번에 한가지 관심에 집중되서 발생하기 때문에, 관심이 한군데에 집중되게 하여 작업과 영향도를 최소화&lt;/p&gt;
&lt;p&gt;관심사 분리 방법 ( db접속정보에 대한 관심사 분리) &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;중복 로직을 메소드로 추출&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 제 3자가 해당 클래스를 사용하려고 할 때, 자신들의 상황에 맞게 수정이 불가능&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;상속을 통한 확장
확장 포인트를 protected로 제공하여 상속을 통한 확장이 가능하도록 제공&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;템플릿 메소드 패턴: 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 제공하는 패턴
팩토리 메소드 패턴: 추상 메소드를 구현할 때, 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 이미 상속중인 클래스는 해당 패턴 적용 불가능, 상속을 통한 클래스 관계 밀접하기 때문에
슈퍼 클래스의 변화가 서브클래스의 변화에 영향을 주기 쉬움&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;클래스 분리
db접속정보를 생성하는 새로운 클래스 생성 후 dao에서 참조&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 제 3자가 사용할 때, db접속정보를 자신에 맞게 변경하려면 dao를 수정해야 함.
dao가 변경될 수 있는 정보를 담당하는 클래스에 대해 너무 많이 알고있기 때문에 종속적이 됨&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;인터페이스 분리
dao와 접속정보를 생성하는 인터페이스를 만들어 함께 제공&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 인터페이스의 어떤 구현체를 사용할지에 대한 관심사가 아직 생성자에 남아있어서 dao를 수정하기 전에는 자유롭지 못함.&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;클라이언트 객체로 관심 분리
dao에서 직접 구현체를 정하는 대신 클라이언트 객체에서 dao객체와 db접속정보를 생성하는 객체를 생성하여 객체간 관계를 설정해줌으로써
dao는 데이터 액세스 로직에만 집중할 수 있게됨&lt;/li&gt;
&lt;li&gt;개방 폐쇄 원칙
확장포인트는 인터페이스를 통해 개방하고, 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 하나의 관심사로 굳게 폐쇄되어 있다.&lt;/li&gt;
&lt;li&gt;높은 응집도 / 낮은 결합도
하나의 변경 사항에 수정할 부분이 많다면 그만큼 버그의 위험성이 높아진다. 인터페이스를 이용해 기능을 독립적으로 분리 시킨경우에,
해당 기능의 높은 응집력으로 변화에 대처하기 수월하다.(해당 인터페이스 구현체 교체)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;낮은 결합도는 인터페이스를 통해서 느슨한 연결을 의미한다. 느슨한 연결을 통해서 기능이 변경될 시 인터페이스 구현체를 교체함으로써,
변화에 대응하기 쉽다.&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;전략 패턴
컨텍스트 - 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 부분을 인터페이스로 확장포인트를 만든다.
보통 컨텍스트의 사용자(클라이언트)가 사용 전략을 컨텍스트에게 제공해주는 방식이 일반적이다.&lt;/li&gt;
&lt;li&gt;제어의 역전
제어권 이전을 통한 제어의 역전, 라이브러리와 프레임워크의 차이점을 통해서 제어의 역전을 확인 가능,
라이브러리를 사용하는 어플리케이션 코드는 흐름을 직접 제어하면서 필요한 기능이 있을 경우 라이브러리를 사용한다.
반면, 프레임워크의 경우 어플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크에 클래스를 등록해두고,
프레임워크가 흐름을 주도하는 중에 어플리케이션 코드를 사용하도록 만드는 방식&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어플리케이션 컨텍스트 &amp;#x26; 빈팩토리
어플리케이션 컨텍스트는 앱 전반의 기능을 통틀어 지칭하는 경우가 많고, 빈팩토리는 빈의 생성,조회 등 관리하는 측면을 지칭할 때 쓰인다.
오브젝트 팩토리를 사용하는 대신 스프링 컨테이너를 사용하면 좋은점은 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;클라이언트가 구체적인 팩토리 클래스를 알 필요가 없고,&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오브젝터 생성 및 관계설정 이외에 많은 부가기능이 있기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;싱글톤 레지스트리
스프링 컨테이너는 기본적으로 컨테이너와 주기를 함께하는 싱글톤 스코프로 단 하나의 객체만이 생성된다.    &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;객체 비교 동일성, 동등성&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;동일성 == 연산으로 동일한 객체인지 판단&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동등성 equals 연산으로 동일한 정보를 담고있는지 판단&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;의존관계 주입(DI)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;의존
a가 b를 의존한다는 것은 b가 변경되었을 때, a도 영향을 받을 수 있지만 반대의 경우는 영향을 받지 않는다. 즉 의존에는 방향이 존재한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;클래스 모델이나 코드에는 런타임 시점의 관계가 드러나지 않아야 하며, 그러기 위해서는 인터페이스를 의존해야한다.&lt;/li&gt;
&lt;li&gt;런타임 시점의 관계는 컨테이너와 같은 제 3의 존재가 구성한다.&lt;/li&gt;
&lt;li&gt;의존관계는외부에서 제공해줌으로써 구성된다.&lt;/li&gt;
&lt;li&gt;의존관계 검색(DL)
의존관계 주입과 반대로 클래스가 능동적으로 자신이 사용할 클래스를 검색한느 경우를 말한다. 예를 들어 application context의 getBean을 사용한 경우다.
의존관계 검색은 컴포넌트가 컨네이터와 같은 성격이 다른 오브젝트에 의존성을 갖게되므로 바람직하지 않다.
다만 main이나 서버환경에서 사용자의 요청을 받았을 경우에 적어도 한번은 의존관계 검색을 통해서 오브젝트를 가져와야 한다. 왜냐하면 DI를 이용해 주입받을 방법이 없기 때문이다.
또한 의존관게 검색의 경우 클라이언트는 스프링 빈일 필요가 없으나 주입의 경우에는 클라이언트와 의존오브젝트 모두 스프링 빈이어야 한다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Algo]]></title><description><![CDATA[완전탐색 재귀호출 1~n의 합을 구할때 작은 조각으로 나눠 문제해결 n만 따로 빼냄: 1~n-1 조각(재귀)와 n 조각을 연산 1만 따로 빼냄: 2~n 조각은 애초에 1~n까지의 합을 구한다는 원래의 문제와 다른 형태이므로 재귀로 사용 x…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algo/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algo/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;완전탐색&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;p&gt;1~n의 합을 구할때 작은 조각으로 나눠 문제해결&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n만 따로 빼냄: 1~n-1 조각(재귀)와 n 조각을 연산&lt;/li&gt;
&lt;li&gt;1만 따로 빼냄: 2~n 조각은 애초에 1~n까지의 합을 구한다는 원래의 문제와 다른 형태이므로 재귀로 사용 x
&lt;strong&gt;기저사례&lt;/strong&gt;: 더이상 쪼개지지 않는 최소한의 작업 (존재하는 모든 입력이 항상 &lt;strong&gt;기저사례&lt;/strong&gt;의 답을 이용할 수 있어야한다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;접근방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;최대 입력의 크기를 가늠하여 시간안에 도출할 수 있는지 예상&lt;/li&gt;
&lt;li&gt;가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈 뒤, 각 선택은 답의 후보를 만드는 과정의 한조각이 된다.&lt;/li&gt;
&lt;li&gt;한 조각을 택해 답의 일부를 만들고, 나머지는 답을 재귀호출을 통해 완성&lt;/li&gt;
&lt;li&gt;조각이 하나 이하로 남은 경우에 답을 생성했으므로, 이것을 기저사례로 선택해 처리&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;이론적 배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문제와 부분문제의 정의&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;문제: 주어진 자연수 정렬&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;문제: {4,2,50,2} 정렬&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;둘은 다른문제임. 전자는 입력을 정의하지 않은 반면, 후자는 특정한 입력을 지정하였기 때문&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;문제란 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 뜻한다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 5]]></title><description><![CDATA[서비스 추상화 조건 유저에 등급을 추가하고, 등급 업 조건을 설정 등급은 금, 은, 동 등금 동->은 로그인 50회 등급 은->금 추천 3…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring5/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring5/</guid><pubDate>Thu, 26 Dec 2019 16:00:39 GMT</pubDate><content:encoded>&lt;h1&gt;서비스 추상화&lt;/h1&gt;
&lt;h2&gt;조건&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;유저에 등급을 추가하고, 등급 업 조건을 설정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;등급은 금, 은, 동&lt;/li&gt;
&lt;li&gt;등금 동-&gt;은 로그인 50회&lt;/li&gt;
&lt;li&gt;등급 은-&gt;금 추천 30회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고려해야할 점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중복된 부분 유무&lt;/li&gt;
&lt;li&gt;코드를 이해하기 쉬운지&lt;/li&gt;
&lt;li&gt;코드의 위치가 적합한지&lt;/li&gt;
&lt;li&gt;앞으로 변경이 일어난다면 어떤것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있는지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if/else if/else 블록: 레벨의 변화단계, 업그레이드 조건, 조건이 충족되었을 때 작업이 섞여있어서 이해하기 쉽지않음&lt;/li&gt;
&lt;li&gt;레벨이 늘어난다면?: if 블록 갯수 증가, level enum 수정,&lt;/li&gt;
&lt;li&gt;레벨 업 작업이 복잡해진다면?: 등급 업하는 service 메소드가 길어지고 복잡해짐(이해하기 힘들어짐)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if 조건문이 현재 레벨과 레벨 업 조건을 동시에 비교하는 부분?: 레벨이 동이면서 로그인이 49인 유저와 새로운 레벨의 유저가 else블록에서 함께 처리됨&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;즉 상당히 변화에 취약하고 다루기 힘든 코드, 문제점이 무엇인지 파악하는것조차 힘듦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리팩토링&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;추상적인 흐름에서부터 로직 작성: 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 썩여있음.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function upgrade() {
list users;
foreach users 
    canlevelup? upgrade : nothing
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;canlevelup? &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function canlevelup(user) {
level = userlevel
level is basic login &amp;gt;= 50
level is silver recommend &amp;gt;= 30
other false
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;upgrade&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function upgrad(user) {
level = userlevel
user.level = level.nextLevel
update user
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기능의 분리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;레벨을 업그레이드하는 정책을 유연하게 변경할 수 있도록 개선(전략패턴)&lt;/li&gt;
&lt;li&gt;userService에서 레벨 업그레이드 정책을 분리한다. (interface를 통해 분리 후 di로 주입)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;객체지향적 코드&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;다른 오브젝트의 데이터를 가져와서 작업하는 대신, 데이터를 갖고있는 오브젝트에게 작업을 해달라고 요청한다.&lt;/strong&gt;
기존: userService가 user의 레벨을 가져와 조건을 판단하여 level수정
변경: userService가 user에게 레벨 수정요청, user가 level에게 다음level 요청&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션
jdbc의 트랜잭션은 하나의 connection을 사용하다가 닫는 사이에 일어난다. jdbc의 기본 설정은 db작업을 수행한 직후에 자동으로 커밋이 되도록 되어있으므로(따라서 작업마다 커밋해서 트랜잭션을 끝내버린다), 이 설정을 끔으로써 시작을 설정하고 commit이나 rollback으로 끝을 설정한다.(트랜잭션 경계설정)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;중요한 점은 트랜잭션은 하나의 connection으로부터 사용하는것이므로 트랜잭션의 경계는 하나의 connection이 만들어지고 닫히는 범위 내에 존재해야한다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;.&quot;&gt;&lt;pre class=&quot;language-.&quot;&gt;&lt;code class=&quot;language-.&quot;&gt;connection = datasource.getConnection() // connection 생성 
connection.setAutoCommit(false) // 트랜잭션 시작 설정
connection.commit() or rollback() // 트랜잭션 끝 설정
connection.close()                // connection close &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 서비스에서 트랜잭션 경계를 위의 방법으로 설정하기 위해서는 다음과 같은 문제점이 따른다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdbc api를 사용해 순수 비지니스로직만을 담아내지 못하고&lt;/li&gt;
&lt;li&gt;dao메소드와 service메소드에 connection 파라미터가 추가된다.(경계설정한 connection을 공유하기 위해서)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dao interface에 connection 파라미터가 들어간다는것은 데이터 액세스 기술에 종속적이라는 의미이다(jpa나 하이버네이트 구현방식 변경하려면 interface부터 모두 변경해야한다.)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;트랜잭션의 종류&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;로컬 트랜잭션: jdbc의 connection을 이용한 트랜잭션 방식 (하나의 connection에 종속적이다)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글로벌 트랜잭션: 여러 db에 대한 작업을 하나의 트랜잭션으로 묶을때 사용하는 방식(트랜잭션매니저 이용)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;트랜잭션 동기화 방식을(jdbc connection을 이용한) 통해 트랜잭션 경계를 구성할 수 있지만 다음과 같은 문제점이 따른다. &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;jdbc api connection을 이용한 방식이기 때문에 글로벌 트랜잭션 적용이 불가능하다( 적용하려면 service 로직 수정)&lt;/li&gt;
&lt;li&gt;jPA나 hibernate의 경우에 독자적인 트랜잭션 관리 api를 사용하므로 적용이 불가능하다( 적용하려면 service 로직 수정)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;즉 기술환경에 종속적인 코드가 된다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스 추상화&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 서비스 추상화란 트랜잭션과 같이 기능은 유사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 인터페이스와 일관성 있는 접근 방법을 제공해주는 것이나 JavaMail 처럼 테스트를 어렵게 만드는 api를 사용할 때도 적용이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Session]]></title><description><![CDATA[Session 최근 세션 관련한 이슈를 해결하면서 관련된 내용을 정리한다. 클라이언트에서 서비스를 이용하는데 간헐적으로 session is already invalidated…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/session/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/session/</guid><pubDate>Thu, 26 Dec 2019 12:59:42 GMT</pubDate><content:encoded>&lt;h1&gt;Session&lt;/h1&gt;
&lt;p&gt;최근 세션 관련한 이슈를 해결하면서 관련된 내용을 정리한다.&lt;/p&gt;
&lt;p&gt;클라이언트에서 서비스를 이용하는데 간헐적으로 session is already invalidated 라는 에러 메세지를 뱉는것이다.
해당 로그를 찾아보니 클라이언트에서 무슨 이유인지는 모르나 동시다발적으로 한번에 4개의 동일한 요청을 날리는 것을 볼 수 있었다.&lt;/p&gt;
&lt;p&gt;기존 리소스서버 공통 인증로직에서는 세션의 유무를 체크한 뒤, 유효한 세션이 아니라면 session.invalidate() 이후 새로운 세션을 새로 생성하는 방식으로 작동하고 있었지만, 동시에 4개의 동일한 요청이 들어왔을 경우 동시성의 문제로 request.getSession(false)가 2개의 요청에 대해서 세션을 리턴해준 뒤, 순차적으로 해당 세션을 invalidate()를 시켰고, 당연히 첫번째 스레드에 의해 invalidate된 세션은 두번째 스레드에 의한 invalidate 호출에 의해서 에러가 발생했던 것이다.&lt;/p&gt;
&lt;p&gt;해당 부분은 SecurityContext를 위해서 세션을 체크하는것이므로, 세션 invalidate 대신, SecurityContextHolder.clearContext()로 수정하였다.&lt;/p&gt;
&lt;h2&gt;구조&lt;/h2&gt;
&lt;p&gt;SecurityContextPersistenceFilter: SecurityContextRepository를 이용해서 SecurityContext를 요청시에 load하거나 save한다.
SecurityContextRepository: Security를 저장하는 역할을 담당한다. sessionCreationPolicy에 따라 해당 전략을 변경한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sessionCreationPolicy 가 stateless일 경우 - NullSecurityContextRepository&lt;/li&gt;
&lt;li&gt;그외 HttpSessionSecurityContextRepository를 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;추상적 흐름(Security context)&lt;/h2&gt;
&lt;p&gt;SecurityContextPersistenceFilter -&gt; SecurityContext 작업 -&gt; SessionManagementFilter&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;요청에 대한 Seucrity Context를 로드한다.&lt;/li&gt;
&lt;li&gt;인증을 통해서 Context를 작업한다.&lt;/li&gt;
&lt;li&gt;해당 요청에 Security Context가 존재하지 않는다면 세션인증전략을 진행하고 Security를 저장한다.&lt;/li&gt;
&lt;li&gt;3.에서 요청에 context가 존재하여 진행되지 않았다면 해당 context를 다음 요청을 위해 저장한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;참조&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/spring-security-session&quot;&gt;baeldung&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Links]]></title><description><![CDATA[links markdown markdown markdown2 github action github action & typescript intellij working directory]]></description><link>https://gatsby-starter-blog-demo.netlify.com/links/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/links/</guid><pubDate>Thu, 26 Dec 2019 12:59:42 GMT</pubDate><content:encoded>&lt;h1&gt;links&lt;/h1&gt;
&lt;h2&gt;markdown&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://guides.github.com/features/mastering-markdown/&quot;&gt;markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wikidocs.net/1678&quot;&gt;markdown2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;github action&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ahnheejong.name/articles/receive-new-room-notification-mails-using-github-action/&quot;&gt;github action &amp;#x26; typescript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;intellij&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/19838334/what-is-a-working-directory-in-intellij-idea&quot;&gt;working directory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 4]]></title><description><![CDATA[예외 예외의 핵심원칙 모든 예외는 적절하게 복구되던지, 작업을 중단하고 운영자 혹은 개발자에게 통보되야 한다. 예외 종류 체크예외: RuntimeException을 상속받지 않는 Exception 언체크예외: RuntimeException…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring4/</guid><pubDate>Fri, 20 Dec 2019 18:19:01 GMT</pubDate><content:encoded>&lt;h2&gt;예외&lt;/h2&gt;
&lt;h3&gt;예외의 핵심원칙&lt;/h3&gt;
&lt;p&gt;모든 예외는 적절하게 복구되던지, 작업을 중단하고 운영자 혹은 개발자에게 통보되야 한다.&lt;/p&gt;
&lt;h3&gt;예외 종류&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;체크예외: RuntimeException을 상속받지 않는 Exception&lt;/li&gt;
&lt;li&gt;언체크예외: RuntimeException을 상속받은 Exception&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;예외 처리방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;복구 - 예외상황을 알맞게 처리한다.&lt;/li&gt;
&lt;li&gt;회피 - 예외를 처리하지 않고 호출한 메소드로 예외를 던진다.&lt;/li&gt;
&lt;li&gt;전환 - 예외 상황을 명확하게 표현할 수 있는 예외형식으로 전환하거나, 체크 예외를 언체크 예외로 변경하는(의미없는 try catch구문 남발 방지) 경우 전환하여 예외를 던진다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;예외처리 전략&lt;/h3&gt;
&lt;p&gt;일반적으로 체크예외는 일반적인 예외, 언체크 예외는 시스템 장애나 프로그램상 오류이다.
초기의 자바가 독립형 앱을 구성할 때에는 작업이 중단되지 않게 상황을 복구 시켜줘야만 했다. (예: 파일 열기 시 파일을 찾을 수 없는경우)
그러나 서버환경에서는 각 요청이 독립적인 작업으로 취급되므로, 예외 발생 시 작업을 중지하고 사용자와 소통하여 복구할 수 있는 방법이 없다.&lt;/p&gt;
&lt;p&gt;스프링은 DataAccessException을 통해서 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다. Dao를 데이터 액세스 기술에서 독립 시키려면 인터페이스 도입과 런타임 예외 전환(jdbcTemplate), 기술에 독립적인 추상화된 예외로 전환이 필요하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 3]]></title><description><![CDATA[템플릿 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙은(OCP…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring3/</guid><pubDate>Mon, 16 Dec 2019 17:30:23 GMT</pubDate><content:encoded>&lt;h2&gt;템플릿&lt;/h2&gt;
&lt;p&gt;객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙은(OCP) 변하는 시점이 다른 부분을 독립적으로 변경될 수 있도록 분리하여 효율적인 구조를 만든다.
템플릿은 이러한 원칙을 활용한 예로써, 변경이 거의 일어나지 않는 부분을 변경이 잦은 부분과 독립시켜 효과적으로 활용하는 방법이다.&lt;/p&gt;
&lt;h3&gt;jdbc&lt;/h3&gt;
&lt;p&gt;jdbc는 보통 Connection과 PreparedStatement라는 공유 리소스를 사용하는데, 요청이 많은 서버환경에서 매번 리소스를 생성하는 대신,
풀 방식으로 미리 일정 갯수의 리소스를 만들어두고 필요할 때마다 할당 및 반환하는 구조이다.&lt;/p&gt;
&lt;p&gt;따라서 jdbc 이용시에는 항상 예외처리를 포함하여야 로직을 수행하면서 에러 발생 시, 공유 리소스를 반환할 수 있다. 반환되지 못한 공유리소스가 쌓이게 되면 리소스 부족으로 서버가 중단될 수 있는 위험이 있기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Connection&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; datasource&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;PreparedStatement&lt;/span&gt; ps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;prepareStatement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sql&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        c&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jdbc를 이용하는 dao의 경우에 위와 같은 예외처리는 항상 중복되어 발생한다. 따라서 아래와 같이 코드의 관심사를 분리시킬 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;변하지 않지만 많은 곳에서 중복되는 코드 - 예외처리 및 Connection&lt;/li&gt;
&lt;li&gt;로직에 따라서 자주 변하는 코드 - preparedStatement (로직마다 쿼리가 달라지므로..)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;코드 분리방법&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;메소드 추출 - 변하는 부분을 메소드로 추출 ( 위의 경우에 변하지 않는 부분이 변하는 부분을 감싸서 추출하기 어려우므로 반대로 추출)&lt;/li&gt;
&lt;li&gt;그러나 변하는 부분은 dao 로직마다 새롭게 만들어야 하는 부분이므로 효과가 없어보인다.&lt;/li&gt;
&lt;li&gt;템플릿 메소드 패턴 - 상속을 통해서 기능확장을 시도한다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분을 추상 메소드로 확장포인트를 제공한다.&lt;/li&gt;
&lt;li&gt;관심사는 분리가 되었지만, dao의 로직 갯수만큼 서브클래스를 만들어서 사용해야 한다. (delete, add, update 등..)&lt;/li&gt;
&lt;li&gt;전략 패턴 - 개방 폐쇄 원칙을 잘 지키면서도, 템플릿 메소드 패턴보다 확장성이 뛰어난 패턴&lt;/li&gt;
&lt;li&gt;확장에 해당하는 부분을 별도의 클래스로 만들어서 인터페이스를 통해 위임하는 방식&lt;/li&gt;
&lt;li&gt;일정한 구조(예외처리)로 동작하다가 특정 확장기능(서비스로직 쿼리)을 수행할 때, 인터페이스를 통해 외부 전략 클래스에 위임&lt;/li&gt;
&lt;li&gt;DI를 이용한 클라이언트 / 컨텍스트 분리&lt;/li&gt;
&lt;li&gt;단순히 전략패턴만을 사용해서는 컨텍스트에서 직접 구현 클래스를 의존하게되어 좋지 않다&lt;/li&gt;
&lt;li&gt;클라이언트가 관계설정의 책임을 가지고 전략을 선택 및 생성하여 컨텍스트에 전달하는 역할을 맡는다.(object Factory)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또 나타난 문제점: 클라이언트(전략패턴 선택)와 컨텍스트(전략패턴 이용)를 분리하였지만 문제는&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;4.1 각 메소드마다 전략패턴 구현체를 각각 만들어줘야해서 클래스 파일의 갯수가 늘어난다. 예) add, update ,delete -&amp;gt; addStatement, updateStatement, deleteStatment (statement 생성전략 구현체)
4.2 전략 객체에 전달할 부가정보를 위한 생성자 및 인스턴스 변수를 번거롭게 만들어야 한다. &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 해결법: 각 메소드 안에 사용하는 전략 클래스를 로컬클래스로 정의한 뒤 사용하기. (클래스 파일 갯수도 줄고, 자신의 선언된 곳의 컨텍스트에 접근 가능)
익명 내부 함수를 사용하면 더 간결한 코드 가능&lt;/p&gt;
&lt;p&gt; 중첩클래스: 스태틱 클래스, 내부 클래스 (멤버클래스, 로컬클래스(메소드 레벨 정의, 로컬변수와 비슷한 개념), 익명 클래스)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;5. 클래스 분리
- 보통의 경우에는 인터페이스를 사이에 두고 분리를 하지만, userDao와 jdbcContext와 같은 긴밀한 관계를 갖는 경우에 간혹 인터페이스를 사용하지 않고 관계를 형성하기도 한다.
`jdbcContext는 그 자체로 JDBC 컨텍스트를 제공해주는 서비스 객체로서 의미가 있을 뿐, 구현 방법이 바뀔 가능성은 없다.`
- jdbc의 일반적인 작업흐름을 담고있는 부분은 다른 dao에서도 사용이 가능하기 때문에 클래스를 분리하여 컨텍스트를 DI 받을 수 있게끔 수정할 수 있다.
5.1 jdbc context를 스프링을 통해 DI받기
   - 싱글톤으로 관리가 가능하며, datasource와 같은 다른 스프링 빈을 주입받을 수 있다.
5.2 클라이언트(userDao)에게 DI받기
   - 스프링을 이용하지 않는다면, 직접 context를 사용하는 클라이언트에게 생성과 초기화를 위임한다.
   - datasource같은 스프링 빈을 주입받기 위해서 스프링 빈인 클라이언트(userDao)에게 DI까지 위임한다.
   - 클라이언트(userDao)와 datasource만 스프링 빈으로 등록한 뒤, 스프링을 이용해 userDao의 수정자 메소드를 통해서 datasource를 주입한뒤, 수정자 메소드 내부에서 jdbcContext를 생성하여 직접 datasource를 jdbcContext에 주입시킨다.

6. 템플릿 / 콜백 패턴
 - 전략패턴 : 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름(컨텍스트)에 그 일부분(전략)만 자주 바뀌는 경우
 - 전략패턴 + 익명 내부클래스 = 템플릿 / 콜백 패턴
 - 전략패턴의 컨텍스트(일정한 작업흐름) =&amp;gt; 템플릿, 익명 내부클래스 =&amp;gt; 콜백
 - 콜백은 보통 단일 메소드 인터페이스를 사용, 컨텍스트(템플릿)에서 여러 종류의 전략을 사용해야 한다면 한개 이상의 콜백 오브젝트를 사용할 수 있음
 - 콜백 메소드에는 대개 컨텍스트의 작업(작업 흐름)중 만들어지는 컨텍스트 정보를 전달받을 파라미터가 존재한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;작업 흐름도
1. 클라이언트 역할: 콜백 객체를 만들고, 콜백이 참조할 정보를 제공하는 역할, 템플릿을 호출할때 콜백 전달
2. 템플릿 역할: 내부 작업을 진행하다가 생성된 참조정보를 가지고 콜백객체의 메소드 호출
3. 콜백 역할: 클라이언트 메소드 정보와, 템플릿이 제공하는 참조정보를 이용해 작업 수행 후, 템플릿에게 결과 리턴
4. 템플릿 역할: 콜백의 결과를 사용해 작업 마저 수행, 경우에 따라서 최종결과를 클라이언트에게 다시 돌려줄 수도 있음&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 일반적인 DI와 다르게 매번 메소드를 호출할 때마다 콜백 오브젝트를 새로 전달 받음
- 콜백 객체는 익명 내부클래스로써, 자신을 생성한 클라이언트 내부 메소드 정보를 직접 참조한다는 것이 특징( 클라이언트와 콜백간의 강한결합)
- __변하는 것과 변하지 않는것을 분리하고 변하지 않는건 유연하게 재활용할 수 있게 만든다__
- 변하지 않는것을 메소드로 추출, 여러 클래스에서 사용하고 싶다면 클래스를 분리하여 메소드로 추출

7. 템플릿 / 콜백 패턴 적용 예시
  ```
  템플릿 / 콜백 패턴에서 가장 중요한 점은 템플릿과 콜백의 경계를 정하고 전달 내용들을 파악하는게 중요하다. (인터페이스를 정의하기 위함)
      1. 템플릿이 콜백에게 전달해 줄 참조 정보는 무엇인지
      2. 콜백이 템플릿에게 돌려줄 내용
      3. 템플릿이 작업을 마친 뒤 클라이언트에게 돌려줄 내용
  ```
  7.1 숫자 합 구하는 계산기 작성
  7.2 템플릿/콜백 패턴 적용
      7.2.1 템플릿-&amp;gt;콜백 (파일 컨텍스트 정보인 BufferedReader)
      7.2.2 콜백-&amp;gt;템플릿 (컨텍스트 내용의 연산결과 Integer)
      7.2.3 템플릿-&amp;gt;클라이언트 (콜백의 연산결과 전달 Integer)
  7.3 다양한 타입을 원한다면 제네릭 사용
  
8. jdbcTemplate
  jdbcTemplate은 내부적으로 템플릿/콜백 패턴을 사용하는 좋은예이다. 
  - update
  - query
  - queryForObject ... 
  ```
  __생각해볼 수 있는 확장포인트__
  예) 유저테이블
  query를 UserRowMapper와 사용할 수 있는데, UserRowMapper를 빈으로 등록시켜서 DI를 이용하고, 
  User 테이블 필드명과 User 오브젝트 프로퍼티의 매핑정보를 XML이나 기타 외부환경에 작성( 테이블 필드명, 매핑방식이 바뀌어도 userDao코드 수정 x)
  
  dao에서 sql 문장을 외부 리소스에서 읽어와 사용(db 테이블 스키마 변경이나, sql 변경 시 코드 수정 x)
  ```
  jdbcTemplate 외에도 클래스가 Template으로 끝나거나, 인터페이스 이름이 Callback인 경우 템플릿/콜백 패턴이 적용된 경우이다.


  

  
  


  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item></channel></rss>