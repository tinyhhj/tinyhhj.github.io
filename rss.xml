<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsby-starter-blog-demo.netlify.com</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 31 Dec 2019 07:33:36 GMT</lastBuildDate><item><title><![CDATA[[algospot]boggle]]></title><description><![CDATA[BOGGLE 재귀호출]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algospot-boggle/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algospot-boggle/</guid><pubDate>Tue, 31 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/BOGGLE&quot;&gt;BOGGLE&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.boggle;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {
    static char[][] arr;
    static int[][] directions = {
            {-1,-1},
            {-1,0},
            {-1,1},
            {0,-1},
            {0,1},
            {1,-1},
            {1,0},
            {1,1}
    };
    static int[][][] cache ;
    public static void main(String[] args) throws IOException {

//        BufferedReader br = new BufferedReader((new InputStreamReader(new FileInputStream(&amp;quot;algospot/boggle/test.txt&amp;quot;))));
        BufferedReader br = new BufferedReader((new InputStreamReader(System.in)));
        int tc = Integer.valueOf(br.readLine());
        for( int i = 0 ; i &amp;lt; tc ; i++) {
            arr = new char[5][5];
            arr[0] = br.readLine().toCharArray();
            arr[1] = br.readLine().toCharArray();
            arr[2] = br.readLine().toCharArray();
            arr[3] = br.readLine().toCharArray();
            arr[4] = br.readLine().toCharArray();


            int wordNum = Integer.valueOf(br.readLine());

            for( int j = 0 ; j &amp;lt; wordNum ; j++) {
                cache = new int[5][5][10];
                String word = br.readLine();
                if( findWord(word)) {
                    System.out.println(String.format(&amp;quot;%s %s&amp;quot;,word,&amp;quot;YES&amp;quot;));
                } else {
                    System.out.println(String.format(&amp;quot;%s %s&amp;quot;,word,&amp;quot;NO&amp;quot;));
                }
            }
        }

    }

    public static boolean findWord(String word) {
        return IntStream
                .range(0,25)
                .anyMatch(i-&amp;gt;{
                    int y = i / 5;
                    int x = i % 5;
                    return findWord(y,x,word.toCharArray());
                });
    }

    public static boolean findWord(int y, int x , char[] word) {
        if( cache[y][x][word.length-1] == 1) {
            return true;
        } else if( cache[y][x][word.length-1] == -1) {
            return false;
        }
        if(word.length == 1 ) {
            return word[0] == arr[y][x];
        }

        if( word[0] == arr[y][x]) {
            boolean res = Stream.of(directions)
                    .anyMatch(i-&amp;gt;{
                        int yy = y + i[0];
                        int xx = x + i[1];
                        if( yy &amp;gt;= 0 &amp;amp;&amp;amp; yy &amp;lt; 5 &amp;amp;&amp;amp; xx &amp;gt;=0 &amp;amp;&amp;amp; xx &amp;lt; 5) return findWord(yy,xx,new String(word).substring(1).toCharArray());
                        return false;
                    });
            if(res) cache[y][x][word.length-1]= 1;
            else cache[y][x][word.length-1] = -1;
            return res;
        }

        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[[boj]1074]]></title><description><![CDATA[Z 재귀호출 문제: z로 탐색할 때, n,r,c가 주어졌을 때 순서를 리턴
문제의 조각: nrc가 주어졌을때 순서를 리턴
기저조건 : n이 0인경우는 무조건 순서가 1
그 외 : 1 2 3 4 구역 나누기
1구역이라면 1구역 내에서 순서 리턴…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/boj-1074/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/boj-1074/</guid><pubDate>Tue, 31 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1074&quot;&gt;Z&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;문제: z로 탐색할 때, n,r,c가 주어졌을 때 순서를 리턴
문제의 조각: nrc가 주어졌을때 순서를 리턴
기저조건 : n이 0인경우는 무조건 순서가 1
그 외 : 1 2 3 4 구역 나누기
1구역이라면 1구역 내에서 순서 리턴
2구역이라면 1구역 갯수 + 2구역 내에서 순서 리턴
3구역이라면 2구역 까지 갯수 + 3구역 내에서 순서
4구역이라면 3구역 까지 갯수 + 4구역 내에서 순서&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;static int getZOrder(int n , int r , int c) {
        if( n == 0) {
            return 1;
        }
        int num = 1 &amp;lt;&amp;lt; n-1;
        //1
        if( num &amp;gt; r &amp;amp;&amp;amp; num &amp;gt; c) {
           return getZOrder(n-1, r,c);
        }
        //2
        else if( num &amp;gt; r &amp;amp;&amp;amp; num &amp;lt;= c) {
            return (num *num) + getZOrder(n-1, r, c- num);
        }
        //3
        else if( num &amp;lt;= r &amp;amp;&amp;amp; num &amp;gt; c) {
            return (num *num * 2) + getZOrder(n-1,r-num , c);
        }
        //4
        else {
            return (num *num * 3) + getZOrder(n-1, r-num, c-num);
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 2]]></title><description><![CDATA[…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring2/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;2장&lt;/h1&gt;
&lt;p&gt;테스트&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;단위 테스트를 이용해서 기존의 코드가 정상 동작하는것을 확신할 수 있고, 테스트하고자 하는 기능에 집중해 테스트 할 수 있으므로, 장애 대응이 용이하다.
단위 테스트를 이용하면 많은 수의 테스트 케이스를 일일이 수행하는 작업과 결과값을 검증하는 작업을 자동화할 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트 코드 작성&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;junit은 프레임워크이기 때문에 ioc을 이용하여 테스트를 진행한다. 그렇기 때문에 main의 테스트 함수를 junit 테스트 코드로 변경해야한다.
main 함수의 경우에는 제어권을 갖는다는 의미이기 때문이다.

테스트 메소드는 &amp;quot;pulic&amp;quot;이어야하고, &amp;quot;@Test&amp;quot; 어노테이션을 붙여야 한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트가 이끄는 개발&lt;/h2&gt;
&lt;p&gt;   테스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 실제 비지니스 로직을 수정하여 완성한다.
테스트 코드를 먼저 작성할 때에는 추가하고 싶은 기능을 코드로 표현해야 하는데,
테스트 코드의 표현은 조건, 행위, 결과로 표현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;조건: 어떤 조건을 가지고 ( 사용자 정보가 없을때)
행위: 무엇을 할 때 (존재하지 않는 id로 조회를 하면)
결과: 어떤 결과가 나온다.(exception이 발생한다.)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;테스트 컨텍스트 관리&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;테스트 시에 공통적인 로직은 @Before 나 @After를 이용해서 각 테스트 전과 후에 수행할 수 있다.
또한 테스트는 각 메소드마다 독립성을 유지하기 위해서 새롭게 테스트객체가 생성되는데, 매번 테스트 컨텍스트를 인스턴스 변수에 두고 새로 생성하는것은 비효율적이다.
따라서, 각 테스트 메소드마다 컨텍스트를 공유하기 위해서 클래스마다 딱 한번 실행되는 @BeforeClass를 사용해 스테틱 변수에 저장하여 사용하거나, 스프링이 직접 제공하는
어플리케이션 컨텍스트 테스트 지원 기능을 사용하면 된다.

어플리케이션 컨텍스트는 @ContextConfiguration을 사용한 뒤, ApplicationContext를 주입받는 식으로 작성하면 된다.
테스트 컨텍스트는 메소드간의 공유뿐 아니라 테스트 클래스간 컨텍스트 설정이 같다면 공유도 가능하다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;DI와 테스트&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;컴포넌트 간, 인스턴스간 관계가 절대 변하지 않는 경우에는 DI를 사용하지 않아도 될까? 그렇지 않다.
DI는 구현체를 동적으로 변경할 수 있다는 장점(프록시 패턴) 외에도 직접 DI를 통해서 작은 부분만을 테스트할 수 있는 유용한 기술이다.
```
DataSource를 운영계와 테스트계를 따로 분리할 경우에,
1. @DirtiesContext를 사용하여 @Before시마다 dao의 DataSource를 직접 SingleConnectionDataSource로 DI할 수 있다.
2. 별도의 DI 설정파일을 만들어(ex: test-applicationContext.xml) @ContextConfiguration의 설정파일로 사용하여 운영계와 별도의 설정을 가지고 테스트를 실행할 수 있다.
3. 스프링의 컨테이너 없이 @Before를 이용해서 직접 dao객체를 생성하고 SingleConnectionDataSource를 생성하여 DI시켜줄 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   3가지 방법 중 우선적으로 스프링 컨테이너 없이 테스트할 수 있는 방법을 고려하고, 여러 오브젝트와 복잡한 의존관계를 갖고있는 오브젝트라면
스프링 설정을 이용한 DI방식을 고려하자
`&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;학습 테스트&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;자신이 작성하지 않은 프레임워크나, 다른 개발팀에서 만든 라이브러리 등에 대해서 테스트를 작성하여, 깊은 이해를 이끌어 내는 테스트 작성 방식이다.

 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 1]]></title><description><![CDATA[1장 관심사의 분리
모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다
문제는 변화에 따른 작업은 한곳에 집중되지 않다는 경우가 많다는 점이다. 예) db…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring1/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;1장&lt;/h1&gt;
&lt;p&gt;관심사의 분리
모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다
문제는 변화에 따른 작업은 한곳에 집중되지 않다는 경우가 많다는 점이다. 예) db 정보 변경
즉, 변화가 한 번에 한가지 관심에 집중되서 발생하기 때문에, 관심이 한군데에 집중되게 하여 작업과 영향도를 최소화&lt;/p&gt;
&lt;p&gt;관심사 분리 방법 ( db접속정보에 대한 관심사 분리) &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;중복 로직을 메소드로 추출&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 제 3자가 해당 클래스를 사용하려고 할 때, 자신들의 상황에 맞게 수정이 불가능&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;상속을 통한 확장
확장 포인트를 protected로 제공하여 상속을 통한 확장이 가능하도록 제공&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;템플릿 메소드 패턴: 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 제공하는 패턴
팩토리 메소드 패턴: 추상 메소드를 구현할 때, 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 이미 상속중인 클래스는 해당 패턴 적용 불가능, 상속을 통한 클래스 관계 밀접하기 때문에
슈퍼 클래스의 변화가 서브클래스의 변화에 영향을 주기 쉬움&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;클래스 분리
db접속정보를 생성하는 새로운 클래스 생성 후 dao에서 참조&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 제 3자가 사용할 때, db접속정보를 자신에 맞게 변경하려면 dao를 수정해야 함.
dao가 변경될 수 있는 정보를 담당하는 클래스에 대해 너무 많이 알고있기 때문에 종속적이 됨&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;인터페이스 분리
dao와 접속정보를 생성하는 인터페이스를 만들어 함께 제공&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-&gt; 문제: 인터페이스의 어떤 구현체를 사용할지에 대한 관심사가 아직 생성자에 남아있어서 dao를 수정하기 전에는 자유롭지 못함.&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;클라이언트 객체로 관심 분리
dao에서 직접 구현체를 정하는 대신 클라이언트 객체에서 dao객체와 db접속정보를 생성하는 객체를 생성하여 객체간 관계를 설정해줌으로써
dao는 데이터 액세스 로직에만 집중할 수 있게됨&lt;/li&gt;
&lt;li&gt;개방 폐쇄 원칙
확장포인트는 인터페이스를 통해 개방하고, 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 하나의 관심사로 굳게 폐쇄되어 있다.&lt;/li&gt;
&lt;li&gt;높은 응집도 / 낮은 결합도
하나의 변경 사항에 수정할 부분이 많다면 그만큼 버그의 위험성이 높아진다. 인터페이스를 이용해 기능을 독립적으로 분리 시킨경우에,
해당 기능의 높은 응집력으로 변화에 대처하기 수월하다.(해당 인터페이스 구현체 교체)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;낮은 결합도는 인터페이스를 통해서 느슨한 연결을 의미한다. 느슨한 연결을 통해서 기능이 변경될 시 인터페이스 구현체를 교체함으로써,
변화에 대응하기 쉽다.&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;전략 패턴
컨텍스트 - 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 부분을 인터페이스로 확장포인트를 만든다.
보통 컨텍스트의 사용자(클라이언트)가 사용 전략을 컨텍스트에게 제공해주는 방식이 일반적이다.&lt;/li&gt;
&lt;li&gt;제어의 역전
제어권 이전을 통한 제어의 역전, 라이브러리와 프레임워크의 차이점을 통해서 제어의 역전을 확인 가능,
라이브러리를 사용하는 어플리케이션 코드는 흐름을 직접 제어하면서 필요한 기능이 있을 경우 라이브러리를 사용한다.
반면, 프레임워크의 경우 어플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크에 클래스를 등록해두고,
프레임워크가 흐름을 주도하는 중에 어플리케이션 코드를 사용하도록 만드는 방식&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어플리케이션 컨텍스트 &amp;#x26; 빈팩토리
어플리케이션 컨텍스트는 앱 전반의 기능을 통틀어 지칭하는 경우가 많고, 빈팩토리는 빈의 생성,조회 등 관리하는 측면을 지칭할 때 쓰인다.
오브젝트 팩토리를 사용하는 대신 스프링 컨테이너를 사용하면 좋은점은 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;클라이언트가 구체적인 팩토리 클래스를 알 필요가 없고,&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오브젝터 생성 및 관계설정 이외에 많은 부가기능이 있기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;싱글톤 레지스트리
스프링 컨테이너는 기본적으로 컨테이너와 주기를 함께하는 싱글톤 스코프로 단 하나의 객체만이 생성된다.    &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;객체 비교 동일성, 동등성&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;동일성 == 연산으로 동일한 객체인지 판단&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동등성 equals 연산으로 동일한 정보를 담고있는지 판단&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;의존관계 주입(DI)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;의존
a가 b를 의존한다는 것은 b가 변경되었을 때, a도 영향을 받을 수 있지만 반대의 경우는 영향을 받지 않는다. 즉 의존에는 방향이 존재한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;클래스 모델이나 코드에는 런타임 시점의 관계가 드러나지 않아야 하며, 그러기 위해서는 인터페이스를 의존해야한다.&lt;/li&gt;
&lt;li&gt;런타임 시점의 관계는 컨테이너와 같은 제 3의 존재가 구성한다.&lt;/li&gt;
&lt;li&gt;의존관계는외부에서 제공해줌으로써 구성된다.&lt;/li&gt;
&lt;li&gt;의존관계 검색(DL)
의존관계 주입과 반대로 클래스가 능동적으로 자신이 사용할 클래스를 검색한느 경우를 말한다. 예를 들어 application context의 getBean을 사용한 경우다.
의존관계 검색은 컴포넌트가 컨네이터와 같은 성격이 다른 오브젝트에 의존성을 갖게되므로 바람직하지 않다.
다만 main이나 서버환경에서 사용자의 요청을 받았을 경우에 적어도 한번은 의존관계 검색을 통해서 오브젝트를 가져와야 한다. 왜냐하면 DI를 이용해 주입받을 방법이 없기 때문이다.
또한 의존관게 검색의 경우 클라이언트는 스프링 빈일 필요가 없으나 주입의 경우에는 클라이언트와 의존오브젝트 모두 스프링 빈이어야 한다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Algo]]></title><description><![CDATA[완전탐색 재귀호출 1~n의 합을 구할때 작은 조각으로 나눠 문제해결 n만 따로 빼냄: 1~n-1 조각(재귀)와 n 조각을 연산 1만 따로 빼냄: 2~n 조각은 애초에 1~n까지의 합을 구한다는 원래의 문제와 다른 형태이므로 재귀로 사용 x…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/algo/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/algo/</guid><pubDate>Thu, 26 Dec 2019 17:31:38 GMT</pubDate><content:encoded>&lt;h1&gt;완전탐색&lt;/h1&gt;
&lt;h2&gt;재귀호출&lt;/h2&gt;
&lt;p&gt;1~n의 합을 구할때 작은 조각으로 나눠 문제해결&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n만 따로 빼냄: 1~n-1 조각(재귀)와 n 조각을 연산&lt;/li&gt;
&lt;li&gt;1만 따로 빼냄: 2~n 조각은 애초에 1~n까지의 합을 구한다는 원래의 문제와 다른 형태이므로 재귀로 사용 x
&lt;strong&gt;기저사례&lt;/strong&gt;: 더이상 쪼개지지 않는 최소한의 작업 (존재하는 모든 입력이 항상 &lt;strong&gt;기저사례&lt;/strong&gt;의 답을 이용할 수 있어야한다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/BOGGLE&quot;&gt;BOGGLE&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;전&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import java.io.*;
import java.util.stream.IntStream;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(&amp;quot;test.txt&amp;quot;)));
        String testcase = br.readLine();

        for( int i =0 ; i &amp;lt; Integer.valueOf(testcase) ; i++) {
            char[][] arr = new char[5][5];
            for( int j =0 ; j &amp;lt; 5 ; j++) {
                arr[j] = br.readLine().toCharArray();
            }
            int num = Integer.valueOf(br.readLine());
            for( int k = 0 ; k &amp;lt; num; k++) {
                char[] word = br.readLine().toCharArray();
                boolean find = false;
                int y = -1, x = 0;
                for(int z = 0 ; z &amp;lt; 25; z++) {
                    if( z % 5 == 0) {
                        y++;
                        x=0;
                    } else {
                        x++;
                    }
                    if( findWord(arr, y,x,word)) {
                        System.out.println(new String(word)+ &amp;quot; &amp;quot; + &amp;quot;YES&amp;quot;);
                        find = true;
                        break;
                    }
                }
                if( !find) {
                    System.out.println(new String(word)+ &amp;quot; &amp;quot; + &amp;quot;NO&amp;quot;);
                }

            }
        }

    }

    private static boolean findWord(char[][] arr, int y, int x , char[] word) {
        if( word.length == 1) {
            if( arr[y][x] == word[0]) return true;
            else return false;
        }
        if( arr[y][x] == word[0]) {
            int yy = y-2, xx = x-1;
            for( int kk =0 ; kk &amp;lt; 9 ; kk++) {
                if( kk % 3 == 0) {
                    yy++;
                    xx = x-1;
                } else {
                    xx++;
                }
                if( kk == 4) continue;
                if( yy &amp;gt;=0 &amp;amp;&amp;amp; yy&amp;lt;5&amp;amp;&amp;amp;xx &amp;gt;=0 &amp;amp;&amp;amp; xx&amp;lt;5) {
                    if( findWord(arr,yy,xx,new String(word).substring(1).toCharArray())) {
                        return true;
                    }
                }
            }

        }
        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;해결&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package algospot.boggle;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {
    static char[][] arr;
    static int[][] directions = {
            {-1,-1},
            {-1,0},
            {-1,1},
            {0,-1},
            {0,1},
            {1,-1},
            {1,0},
            {1,1}
    };
    static int[][][] cache ;
    public static void main(String[] args) throws IOException {

//        BufferedReader br = new BufferedReader((new InputStreamReader(new FileInputStream(&amp;quot;algospot/boggle/test.txt&amp;quot;))));
        BufferedReader br = new BufferedReader((new InputStreamReader(System.in)));
        int tc = Integer.valueOf(br.readLine());
        for( int i = 0 ; i &amp;lt; tc ; i++) {
            arr = new char[5][5];
            arr[0] = br.readLine().toCharArray();
            arr[1] = br.readLine().toCharArray();
            arr[2] = br.readLine().toCharArray();
            arr[3] = br.readLine().toCharArray();
            arr[4] = br.readLine().toCharArray();


            int wordNum = Integer.valueOf(br.readLine());

            for( int j = 0 ; j &amp;lt; wordNum ; j++) {
                cache = new int[5][5][10];
                String word = br.readLine();
                if( findWord(word)) {
                    System.out.println(String.format(&amp;quot;%s %s&amp;quot;,word,&amp;quot;YES&amp;quot;));
                } else {
                    System.out.println(String.format(&amp;quot;%s %s&amp;quot;,word,&amp;quot;NO&amp;quot;));
                }
            }
        }

    }

    public static boolean findWord(String word) {
        return IntStream
                .range(0,25)
                .anyMatch(i-&amp;gt;{
                    int y = i / 5;
                    int x = i % 5;
                    return findWord(y,x,word.toCharArray());
                });
    }

    public static boolean findWord(int y, int x , char[] word) {
        if( cache[y][x][word.length-1] == 1) {
            return true;
        } else if( cache[y][x][word.length-1] == -1) {
            return false;
        }
        if(word.length == 1 ) {
            return word[0] == arr[y][x];
        }

        if( word[0] == arr[y][x]) {
            boolean res = Stream.of(directions)
                    .anyMatch(i-&amp;gt;{
                        int yy = y + i[0];
                        int xx = x + i[1];
                        if( yy &amp;gt;= 0 &amp;amp;&amp;amp; yy &amp;lt; 5 &amp;amp;&amp;amp; xx &amp;gt;=0 &amp;amp;&amp;amp; xx &amp;lt; 5) return findWord(yy,xx,new String(word).substring(1).toCharArray());
                        return false;
                    });
            if(res) cache[y][x][word.length-1]= 1;
            else cache[y][x][word.length-1] = -1;
            return res;
        }

        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 5]]></title><description><![CDATA[서비스 추상화 조건 유저에 등급을 추가하고, 등급 업 조건을 설정 등급은 금, 은, 동 등금 동->은 로그인 50회 등급 은->금 추천 3…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring5/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring5/</guid><pubDate>Thu, 26 Dec 2019 16:00:39 GMT</pubDate><content:encoded>&lt;h1&gt;서비스 추상화&lt;/h1&gt;
&lt;h2&gt;조건&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;유저에 등급을 추가하고, 등급 업 조건을 설정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;등급은 금, 은, 동&lt;/li&gt;
&lt;li&gt;등금 동-&gt;은 로그인 50회&lt;/li&gt;
&lt;li&gt;등급 은-&gt;금 추천 30회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고려해야할 점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중복된 부분 유무&lt;/li&gt;
&lt;li&gt;코드를 이해하기 쉬운지&lt;/li&gt;
&lt;li&gt;코드의 위치가 적합한지&lt;/li&gt;
&lt;li&gt;앞으로 변경이 일어난다면 어떤것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있는지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if/else if/else 블록: 레벨의 변화단계, 업그레이드 조건, 조건이 충족되었을 때 작업이 섞여있어서 이해하기 쉽지않음&lt;/li&gt;
&lt;li&gt;레벨이 늘어난다면?: if 블록 갯수 증가, level enum 수정,&lt;/li&gt;
&lt;li&gt;레벨 업 작업이 복잡해진다면?: 등급 업하는 service 메소드가 길어지고 복잡해짐(이해하기 힘들어짐)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if 조건문이 현재 레벨과 레벨 업 조건을 동시에 비교하는 부분?: 레벨이 동이면서 로그인이 49인 유저와 새로운 레벨의 유저가 else블록에서 함께 처리됨&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;즉 상당히 변화에 취약하고 다루기 힘든 코드, 문제점이 무엇인지 파악하는것조차 힘듦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리팩토링&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;추상적인 흐름에서부터 로직 작성: 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 썩여있음.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function upgrade() {
list users;
foreach users 
    canlevelup? upgrade : nothing
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Session]]></title><description><![CDATA[Session 최근 세션 관련한 이슈를 해결하면서 관련된 내용을 정리한다. 클라이언트에서 서비스를 이용하는데 간헐적으로 session is already invalidated…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/session/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/session/</guid><pubDate>Thu, 26 Dec 2019 12:59:42 GMT</pubDate><content:encoded>&lt;h1&gt;Session&lt;/h1&gt;
&lt;p&gt;최근 세션 관련한 이슈를 해결하면서 관련된 내용을 정리한다.&lt;/p&gt;
&lt;p&gt;클라이언트에서 서비스를 이용하는데 간헐적으로 session is already invalidated 라는 에러 메세지를 뱉는것이다.
해당 로그를 찾아보니 클라이언트에서 무슨 이유인지는 모르나 동시다발적으로 한번에 4개의 동일한 요청을 날리는 것을 볼 수 있었다.&lt;/p&gt;
&lt;p&gt;기존 리소스서버 공통 인증로직에서는 세션의 유무를 체크한 뒤, 유효한 세션이 아니라면 session.invalidate() 이후 새로운 세션을 새로 생성하는 방식으로 작동하고 있었지만, 동시에 4개의 동일한 요청이 들어왔을 경우 동시성의 문제로 request.getSession(false)가 2개의 요청에 대해서 세션을 리턴해준 뒤, 순차적으로 해당 세션을 invalidate()를 시켰고, 당연히 첫번째 스레드에 의해 invalidate된 세션은 두번째 스레드에 의한 invalidate 호출에 의해서 에러가 발생했던 것이다.&lt;/p&gt;
&lt;p&gt;해당 부분은 SecurityContext를 위해서 세션을 체크하는것이므로, 세션 invalidate 대신, SecurityContextHolder.clearContext()로 수정하였다.&lt;/p&gt;
&lt;h2&gt;구조&lt;/h2&gt;
&lt;p&gt;SecurityContextPersistenceFilter: SecurityContextRepository를 이용해서 SecurityContext를 요청시에 load하거나 save한다.
SecurityContextRepository: Security를 저장하는 역할을 담당한다. sessionCreationPolicy에 따라 해당 전략을 변경한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sessionCreationPolicy 가 stateless일 경우 - NullSecurityContextRepository&lt;/li&gt;
&lt;li&gt;그외 HttpSessionSecurityContextRepository를 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;추상적 흐름(Security context)&lt;/h2&gt;
&lt;p&gt;SecurityContextPersistenceFilter -&gt; SecurityContext 작업 -&gt; SessionManagementFilter&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;요청에 대한 Seucrity Context를 로드한다.&lt;/li&gt;
&lt;li&gt;인증을 통해서 Context를 작업한다.&lt;/li&gt;
&lt;li&gt;해당 요청에 Security Context가 존재하지 않는다면 세션인증전략을 진행하고 Security를 저장한다.&lt;/li&gt;
&lt;li&gt;3.에서 요청에 context가 존재하여 진행되지 않았다면 해당 context를 다음 요청을 위해 저장한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;참조&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/spring-security-session&quot;&gt;baeldung&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Links]]></title><description><![CDATA[links markdown markdown markdown2]]></description><link>https://gatsby-starter-blog-demo.netlify.com/links/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/links/</guid><pubDate>Thu, 26 Dec 2019 12:59:42 GMT</pubDate><content:encoded>&lt;h1&gt;links&lt;/h1&gt;
&lt;h2&gt;markdown&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://guides.github.com/features/mastering-markdown/&quot;&gt;markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wikidocs.net/1678&quot;&gt;markdown2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 4]]></title><description><![CDATA[예외 예외의 핵심원칙 모든 예외는 적절하게 복구되던지, 작업을 중단하고 운영자 혹은 개발자에게 통보되야 한다. 예외 종류 체크예외: RuntimeException을 상속받지 않는 Exception 언체크예외: RuntimeException…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring4/</guid><pubDate>Fri, 20 Dec 2019 18:19:01 GMT</pubDate><content:encoded>&lt;h2&gt;예외&lt;/h2&gt;
&lt;h3&gt;예외의 핵심원칙&lt;/h3&gt;
&lt;p&gt;모든 예외는 적절하게 복구되던지, 작업을 중단하고 운영자 혹은 개발자에게 통보되야 한다.&lt;/p&gt;
&lt;h3&gt;예외 종류&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;체크예외: RuntimeException을 상속받지 않는 Exception&lt;/li&gt;
&lt;li&gt;언체크예외: RuntimeException을 상속받은 Exception&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;예외 처리방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;복구 - 예외상황을 알맞게 처리한다.&lt;/li&gt;
&lt;li&gt;회피 - 예외를 처리하지 않고 호출한 메소드로 예외를 던진다.&lt;/li&gt;
&lt;li&gt;전환 - 예외 상황을 명확하게 표현할 수 있는 예외형식으로 전환하거나, 체크 예외를 언체크 예외로 변경하는(의미없는 try catch구문 남발 방지) 경우 전환하여 예외를 던진다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;예외처리 전략&lt;/h3&gt;
&lt;p&gt;일반적으로 체크예외는 일반적인 예외, 언체크 예외는 시스템 장애나 프로그램상 오류이다.
초기의 자바가 독립형 앱을 구성할 때에는 작업이 중단되지 않게 상황을 복구 시켜줘야만 했다. (예: 파일 열기 시 파일을 찾을 수 없는경우)
그러나 서버환경에서는 각 요청이 독립적인 작업으로 취급되므로, 예외 발생 시 작업을 중지하고 사용자와 소통하여 복구할 수 있는 방법이 없다.&lt;/p&gt;
&lt;p&gt;스프링은 DataAccessException을 통해서 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다. Dao를 데이터 액세스 기술에서 독립 시키려면 인터페이스 도입과 런타임 예외 전환(jdbcTemplate), 기술에 독립적인 추상화된 예외로 전환이 필요하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Chap. 3]]></title><description><![CDATA[템플릿 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙은(OCP…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/spring3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/spring3/</guid><pubDate>Mon, 16 Dec 2019 17:30:23 GMT</pubDate><content:encoded>&lt;h2&gt;템플릿&lt;/h2&gt;
&lt;p&gt;객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙은(OCP) 변하는 시점이 다른 부분을 독립적으로 변경될 수 있도록 분리하여 효율적인 구조를 만든다.
템플릿은 이러한 원칙을 활용한 예로써, 변경이 거의 일어나지 않는 부분을 변경이 잦은 부분과 독립시켜 효과적으로 활용하는 방법이다.&lt;/p&gt;
&lt;h3&gt;jdbc&lt;/h3&gt;
&lt;p&gt;jdbc는 보통 Connection과 PreparedStatement라는 공유 리소스를 사용하는데, 요청이 많은 서버환경에서 매번 리소스를 생성하는 대신,
풀 방식으로 미리 일정 갯수의 리소스를 만들어두고 필요할 때마다 할당 및 반환하는 구조이다.&lt;/p&gt;
&lt;p&gt;따라서 jdbc 이용시에는 항상 예외처리를 포함하여야 로직을 수행하면서 에러 발생 시, 공유 리소스를 반환할 수 있다. 반환되지 못한 공유리소스가 쌓이게 되면 리소스 부족으로 서버가 중단될 수 있는 위험이 있기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Connection&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; datasource&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;PreparedStatement&lt;/span&gt; ps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;prepareStatement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sql&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        c&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jdbc를 이용하는 dao의 경우에 위와 같은 예외처리는 항상 중복되어 발생한다. 따라서 아래와 같이 코드의 관심사를 분리시킬 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;변하지 않지만 많은 곳에서 중복되는 코드 - 예외처리 및 Connection&lt;/li&gt;
&lt;li&gt;로직에 따라서 자주 변하는 코드 - preparedStatement (로직마다 쿼리가 달라지므로..)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;코드 분리방법&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;메소드 추출 - 변하는 부분을 메소드로 추출 ( 위의 경우에 변하지 않는 부분이 변하는 부분을 감싸서 추출하기 어려우므로 반대로 추출)&lt;/li&gt;
&lt;li&gt;그러나 변하는 부분은 dao 로직마다 새롭게 만들어야 하는 부분이므로 효과가 없어보인다.&lt;/li&gt;
&lt;li&gt;템플릿 메소드 패턴 - 상속을 통해서 기능확장을 시도한다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분을 추상 메소드로 확장포인트를 제공한다.&lt;/li&gt;
&lt;li&gt;관심사는 분리가 되었지만, dao의 로직 갯수만큼 서브클래스를 만들어서 사용해야 한다. (delete, add, update 등..)&lt;/li&gt;
&lt;li&gt;전략 패턴 - 개방 폐쇄 원칙을 잘 지키면서도, 템플릿 메소드 패턴보다 확장성이 뛰어난 패턴&lt;/li&gt;
&lt;li&gt;확장에 해당하는 부분을 별도의 클래스로 만들어서 인터페이스를 통해 위임하는 방식&lt;/li&gt;
&lt;li&gt;일정한 구조(예외처리)로 동작하다가 특정 확장기능(서비스로직 쿼리)을 수행할 때, 인터페이스를 통해 외부 전략 클래스에 위임&lt;/li&gt;
&lt;li&gt;DI를 이용한 클라이언트 / 컨텍스트 분리&lt;/li&gt;
&lt;li&gt;단순히 전략패턴만을 사용해서는 컨텍스트에서 직접 구현 클래스를 의존하게되어 좋지 않다&lt;/li&gt;
&lt;li&gt;클라이언트가 관계설정의 책임을 가지고 전략을 선택 및 생성하여 컨텍스트에 전달하는 역할을 맡는다.(object Factory)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또 나타난 문제점: 클라이언트(전략패턴 선택)와 컨텍스트(전략패턴 이용)를 분리하였지만 문제는&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;4.1 각 메소드마다 전략패턴 구현체를 각각 만들어줘야해서 클래스 파일의 갯수가 늘어난다. 예) add, update ,delete -&amp;gt; addStatement, updateStatement, deleteStatment (statement 생성전략 구현체)
4.2 전략 객체에 전달할 부가정보를 위한 생성자 및 인스턴스 변수를 번거롭게 만들어야 한다. &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 해결법: 각 메소드 안에 사용하는 전략 클래스를 로컬클래스로 정의한 뒤 사용하기. (클래스 파일 갯수도 줄고, 자신의 선언된 곳의 컨텍스트에 접근 가능)
익명 내부 함수를 사용하면 더 간결한 코드 가능&lt;/p&gt;
&lt;p&gt; 중첩클래스: 스태틱 클래스, 내부 클래스 (멤버클래스, 로컬클래스(메소드 레벨 정의, 로컬변수와 비슷한 개념), 익명 클래스)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;5. 클래스 분리
- 보통의 경우에는 인터페이스를 사이에 두고 분리를 하지만, userDao와 jdbcContext와 같은 긴밀한 관계를 갖는 경우에 간혹 인터페이스를 사용하지 않고 관계를 형성하기도 한다.
`jdbcContext는 그 자체로 JDBC 컨텍스트를 제공해주는 서비스 객체로서 의미가 있을 뿐, 구현 방법이 바뀔 가능성은 없다.`
- jdbc의 일반적인 작업흐름을 담고있는 부분은 다른 dao에서도 사용이 가능하기 때문에 클래스를 분리하여 컨텍스트를 DI 받을 수 있게끔 수정할 수 있다.
5.1 jdbc context를 스프링을 통해 DI받기
   - 싱글톤으로 관리가 가능하며, datasource와 같은 다른 스프링 빈을 주입받을 수 있다.
5.2 클라이언트(userDao)에게 DI받기
   - 스프링을 이용하지 않는다면, 직접 context를 사용하는 클라이언트에게 생성과 초기화를 위임한다.
   - datasource같은 스프링 빈을 주입받기 위해서 스프링 빈인 클라이언트(userDao)에게 DI까지 위임한다.
   - 클라이언트(userDao)와 datasource만 스프링 빈으로 등록한 뒤, 스프링을 이용해 userDao의 수정자 메소드를 통해서 datasource를 주입한뒤, 수정자 메소드 내부에서 jdbcContext를 생성하여 직접 datasource를 jdbcContext에 주입시킨다.

6. 템플릿 / 콜백 패턴
 - 전략패턴 : 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름(컨텍스트)에 그 일부분(전략)만 자주 바뀌는 경우
 - 전략패턴 + 익명 내부클래스 = 템플릿 / 콜백 패턴
 - 전략패턴의 컨텍스트(일정한 작업흐름) =&amp;gt; 템플릿, 익명 내부클래스 =&amp;gt; 콜백
 - 콜백은 보통 단일 메소드 인터페이스를 사용, 컨텍스트(템플릿)에서 여러 종류의 전략을 사용해야 한다면 한개 이상의 콜백 오브젝트를 사용할 수 있음
 - 콜백 메소드에는 대개 컨텍스트의 작업(작업 흐름)중 만들어지는 컨텍스트 정보를 전달받을 파라미터가 존재한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;작업 흐름도
1. 클라이언트 역할: 콜백 객체를 만들고, 콜백이 참조할 정보를 제공하는 역할, 템플릿을 호출할때 콜백 전달
2. 템플릿 역할: 내부 작업을 진행하다가 생성된 참조정보를 가지고 콜백객체의 메소드 호출
3. 콜백 역할: 클라이언트 메소드 정보와, 템플릿이 제공하는 참조정보를 이용해 작업 수행 후, 템플릿에게 결과 리턴
4. 템플릿 역할: 콜백의 결과를 사용해 작업 마저 수행, 경우에 따라서 최종결과를 클라이언트에게 다시 돌려줄 수도 있음&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 일반적인 DI와 다르게 매번 메소드를 호출할 때마다 콜백 오브젝트를 새로 전달 받음
- 콜백 객체는 익명 내부클래스로써, 자신을 생성한 클라이언트 내부 메소드 정보를 직접 참조한다는 것이 특징( 클라이언트와 콜백간의 강한결합)
- __변하는 것과 변하지 않는것을 분리하고 변하지 않는건 유연하게 재활용할 수 있게 만든다__
- 변하지 않는것을 메소드로 추출, 여러 클래스에서 사용하고 싶다면 클래스를 분리하여 메소드로 추출

7. 템플릿 / 콜백 패턴 적용 예시
  ```
  템플릿 / 콜백 패턴에서 가장 중요한 점은 템플릿과 콜백의 경계를 정하고 전달 내용들을 파악하는게 중요하다. (인터페이스를 정의하기 위함)
      1. 템플릿이 콜백에게 전달해 줄 참조 정보는 무엇인지
      2. 콜백이 템플릿에게 돌려줄 내용
      3. 템플릿이 작업을 마친 뒤 클라이언트에게 돌려줄 내용
  ```
  7.1 숫자 합 구하는 계산기 작성
  7.2 템플릿/콜백 패턴 적용
      7.2.1 템플릿-&amp;gt;콜백 (파일 컨텍스트 정보인 BufferedReader)
      7.2.2 콜백-&amp;gt;템플릿 (컨텍스트 내용의 연산결과 Integer)
      7.2.3 템플릿-&amp;gt;클라이언트 (콜백의 연산결과 전달 Integer)
  7.3 다양한 타입을 원한다면 제네릭 사용
  
8. jdbcTemplate
  jdbcTemplate은 내부적으로 템플릿/콜백 패턴을 사용하는 좋은예이다. 
  - update
  - query
  - queryForObject ... 
  ```
  __생각해볼 수 있는 확장포인트__
  예) 유저테이블
  query를 UserRowMapper와 사용할 수 있는데, UserRowMapper를 빈으로 등록시켜서 DI를 이용하고, 
  User 테이블 필드명과 User 오브젝트 프로퍼티의 매핑정보를 XML이나 기타 외부환경에 작성( 테이블 필드명, 매핑방식이 바뀌어도 userDao코드 수정 x)
  
  dao에서 sql 문장을 외부 리소스에서 읽어와 사용(db 테이블 스키마 변경이나, sql 변경 시 코드 수정 x)
  ```
  jdbcTemplate 외에도 클래스가 Template으로 끝나거나, 인터페이스 이름이 Callback인 경우 템플릿/콜백 패턴이 적용된 경우이다.


  

  
  


  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item></channel></rss>