---
title: "Spring Chap. 3"
date: "2019-12-16T17:30:23.777Z"
description: "Toby Spring"
---

## 템플릿

객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙은(OCP) 변하는 시점이 다른 부분을 독립적으로 변경될 수 있도록 분리하여 효율적인 구조를 만든다.
템플릿은 이러한 원칙을 활용한 예로써, 변경이 거의 일어나지 않는 부분을 변경이 잦은 부분과 독립시켜 효과적으로 활용하는 방법이다.

### jdbc

jdbc는 보통 Connection과 PreparedStatement라는 공유 리소스를 사용하는데, 요청이 많은 서버환경에서 매번 리소스를 생성하는 대신, 
풀 방식으로 미리 일정 갯수의 리소스를 만들어두고 필요할 때마다 할당 및 반환하는 구조이다.

따라서 jdbc 이용시에는 항상 예외처리를 포함하여야 로직을 수행하면서 에러 발생 시, 공유 리소스를 반환할 수 있다. 반환되지 못한 공유리소스가 쌓이게 되면 리소스 부족으로 서버가 중단될 수 있는 위험이 있기 때문이다.

```java
try{
    Connection c = datasource.getConnection();
    PreparedStatement ps = c.prepareStatement(..sql..);
} finally {
    if( c != null) {
        c.close();
    }
}   
```

jdbc를 이용하는 dao의 경우에 위와 같은 예외처리는 항상 중복되어 발생한다. 따라서 아래와 같이 코드의 관심사를 분리시킬 수 있다.

1. 변하지 않지만 많은 곳에서 중복되는 코드 - 예외처리 및 Connection
2. 로직에 따라서 자주 변하는 코드 - preparedStatement (로직마다 쿼리가 달라지므로..)

#### 코드 분리방법

1. 메소드 추출 - 변하는 부분을 메소드로 추출 ( 위의 경우에 변하지 않는 부분이 변하는 부분을 감싸서 추출하기 어려우므로 반대로 추출)
 - 그러나 변하는 부분은 dao 로직마다 새롭게 만들어야 하는 부분이므로 효과가 없어보인다.
2. 템플릿 메소드 패턴 - 상속을 통해서 기능확장을 시도한다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분을 추상 메소드로 확장포인트를 제공한다.
 - 관심사는 분리가 되었지만, dao의 로직 갯수만큼 서브클래스를 만들어서 사용해야 한다. (delete, add, update 등..)
3. 전략 패턴 - 개방 폐쇄 원칙을 잘 지키면서도, 템플릿 메소드 패턴보다 확장성이 뛰어난 패턴
 - 확장에 해당하는 부분을 별도의 클래스로 만들어서 인터페이스를 통해 위임하는 방식
 - 일정한 구조(예외처리)로 동작하다가 특정 확장기능(서비스로직 쿼리)을 수행할 때, 인터페이스를 통해 외부 전략 클래스에 위임
4. DI를 이용한 클라이언트 / 컨텍스트 분리
 - 단순히 전략패턴만을 사용해서는 컨텍스트에서 직접 구현 클래스를 의존하게되어 좋지 않다
 - 클라이언트가 관계설정의 책임을 가지고 전략을 선택 및 생성하여 컨텍스트에 전달하는 역할을 맡는다.(object Factory)
 - 또 나타난 문제점: 클라이언트(전략패턴 선택)와 컨텍스트(전략패턴 이용)를 분리하였지만 문제는
 ```
 4.1 각 메소드마다 전략패턴 구현체를 각각 만들어줘야해서 클래스 파일의 갯수가 늘어난다. 예) add, update ,delete -> addStatement, updateStatement, deleteStatment (statement 생성전략 구현체)
 4.2 전략 객체에 전달할 부가정보를 위한 생성자 및 인스턴스 변수를 번거롭게 만들어야 한다. 

 해결법: 각 메소드 안에 사용하는 전략 클래스를 로컬클래스로 정의한 뒤 사용하기. (클래스 파일 갯수도 줄고, 자신의 선언된 곳의 컨텍스트에 접근 가능)
 익명 내부 함수를 사용하면 더 간결한 코드 가능
 
 중첩클래스: 스태틱 클래스, 내부 클래스 (멤버클래스, 로컬클래스(메소드 레벨 정의, 로컬변수와 비슷한 개념), 익명 클래스)
 ``` 
5. 클래스 분리
 - 보통의 경우에는 인터페이스를 사이에 두고 분리를 하지만, userDao와 jdbcContext와 같은 긴밀한 관계를 갖는 경우에 간혹 인터페이스를 사용하지 않고 관계를 형성하기도 한다.
 `jdbcContext는 그 자체로 JDBC 컨텍스트를 제공해주는 서비스 객체로서 의미가 있을 뿐, 구현 방법이 바뀔 가능성은 없다.`
 - jdbc의 일반적인 작업흐름을 담고있는 부분은 다른 dao에서도 사용이 가능하기 때문에 클래스를 분리하여 컨텍스트를 DI 받을 수 있게끔 수정할 수 있다.
 5.1 jdbc context를 스프링을 통해 DI받기
    - 싱글톤으로 관리가 가능하며, datasource와 같은 다른 스프링 빈을 주입받을 수 있다.
 5.2 클라이언트(userDao)에게 DI받기
    - 스프링을 이용하지 않는다면, 직접 context를 사용하는 클라이언트에게 생성과 초기화를 위임한다.
    - datasource같은 스프링 빈을 주입받기 위해서 스프링 빈인 클라이언트(userDao)에게 DI까지 위임한다.
    - 클라이언트(userDao)와 datasource만 스프링 빈으로 등록한 뒤, 스프링을 이용해 userDao의 수정자 메소드를 통해서 datasource를 주입한뒤, 수정자 메소드 내부에서 jdbcContext를 생성하여 직접 datasource를 jdbcContext에 주입시킨다.

6. 템플릿 / 콜백 패턴
  - 전략패턴 : 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름(컨텍스트)에 그 일부분(전략)만 자주 바뀌는 경우
  - 전략패턴 + 익명 내부클래스 = 템플릿 / 콜백 패턴
  - 전략패턴의 컨텍스트(일정한 작업흐름) => 템플릿, 익명 내부클래스 => 콜백
  - 콜백은 보통 단일 메소드 인터페이스를 사용, 컨텍스트(템플릿)에서 여러 종류의 전략을 사용해야 한다면 한개 이상의 콜백 오브젝트를 사용할 수 있음
  - 콜백 메소드에는 대개 컨텍스트의 작업(작업 흐름)중 만들어지는 컨텍스트 정보를 전달받을 파라미터가 존재한다.
  ```
    작업 흐름도
    1. 클라이언트 역할: 콜백 객체를 만들고, 콜백이 참조할 정보를 제공하는 역할, 템플릿을 호출할때 콜백 전달
    2. 템플릿 역할: 내부 작업을 진행하다가 생성된 참조정보를 가지고 콜백객체의 메소드 호출
    3. 콜백 역할: 클라이언트 메소드 정보와, 템플릿이 제공하는 참조정보를 이용해 작업 수행 후, 템플릿에게 결과 리턴
    4. 템플릿 역할: 콜백의 결과를 사용해 작업 마저 수행, 경우에 따라서 최종결과를 클라이언트에게 다시 돌려줄 수도 있음
  ```
  - 일반적인 DI와 다르게 매번 메소드를 호출할 때마다 콜백 오브젝트를 새로 전달 받음
  - 콜백 객체는 익명 내부클래스로써, 자신을 생성한 클라이언트 내부 메소드 정보를 직접 참조한다는 것이 특징( 클라이언트와 콜백간의 강한결합)
  - __변하는 것과 변하지 않는것을 분리하고 변하지 않는건 유연하게 재활용할 수 있게 만든다__
  - 변하지 않는것을 메소드로 추출, 여러 클래스에서 사용하고 싶다면 클래스를 분리하여 메소드로 추출

7. 템플릿 / 콜백 패턴 적용 예시
    ```
    템플릿 / 콜백 패턴에서 가장 중요한 점은 템플릿과 콜백의 경계를 정하고 전달 내용들을 파악하는게 중요하다. (인터페이스를 정의하기 위함)
        1. 템플릿이 콜백에게 전달해 줄 참조 정보는 무엇인지
        2. 콜백이 템플릿에게 돌려줄 내용
        3. 템플릿이 작업을 마친 뒤 클라이언트에게 돌려줄 내용
    ```
    7.1 숫자 합 구하는 계산기 작성
    7.2 템플릿/콜백 패턴 적용
        7.2.1 템플릿->콜백 (파일 컨텍스트 정보인 BufferedReader)
        7.2.2 콜백->템플릿 (컨텍스트 내용의 연산결과 Integer)
        7.2.3 템플릿->클라이언트 (콜백의 연산결과 전달 Integer)
    7.3 다양한 타입을 원한다면 제네릭 사용
    
8. jdbcTemplate
    jdbcTemplate은 내부적으로 템플릿/콜백 패턴을 사용하는 좋은예이다. 
    - update
    - query
    - queryForObject ... 
    ```
    __생각해볼 수 있는 확장포인트__
    예) 유저테이블
    query를 UserRowMapper와 사용할 수 있는데, UserRowMapper를 빈으로 등록시켜서 DI를 이용하고, 
    User 테이블 필드명과 User 오브젝트 프로퍼티의 매핑정보를 XML이나 기타 외부환경에 작성( 테이블 필드명, 매핑방식이 바뀌어도 userDao코드 수정 x)
    
    dao에서 sql 문장을 외부 리소스에서 읽어와 사용(db 테이블 스키마 변경이나, sql 변경 시 코드 수정 x)
    ```
    jdbcTemplate 외에도 클래스가 Template으로 끝나거나, 인터페이스 이름이 Callback인 경우 템플릿/콜백 패턴이 적용된 경우이다.


    

    
    

 
    

